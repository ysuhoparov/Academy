<?xml version="1.0" encoding="windows-1251"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink">
 <description>
  <title-info>
   <genre>comp_programming</genre>
   <author>
    <first-name>јлександр</first-name>
    <last-name>—тепанов</last-name>
    <email>stepanov@mti.sgi.com</email>
   </author>
   <author>
    <first-name>ћенг</first-name>
    <last-name>Ћи</last-name>
    <email>lee@hlp.hp.com</email>
   </author>
   <book-title>–” ќ¬ќƒ—“¬ќ ѕќ —“јЌƒј–“Ќќ… Ѕ»ЅЋ»ќ“≈ ≈ ЎјЅЋќЌќ¬ (STL)</book-title>
   <date>1999</date>
   <lang>ru</lang>
   <src-lang>en</src-lang>
   <translator>
    <first-name>јлексей</first-name>
    <last-name>—уханов</last-name>
   </translator>
   <translator>
    <first-name>јндрей</first-name>
    <last-name> утырин</last-name>
   </translator>
  </title-info>
  <document-info>
   <author>
    <nickname>honorato bonafe</nickname>
   </author>
   <program-used>Fiction Book Designer, FB Editor v2.0</program-used>
   <date value="2009-09-02">02.09.2009</date>
   <id>FBD-9F0713-1705-7D48-14A2-7EFB-4F34-F62F8A</id>
   <version>1.0</version>
   <history>
    <p>1.0 chm-Ыfb2 </p>
   </history>
  </document-info>
  <publish-info>
   <publisher>ћќ— ќ¬— »… √ќ—”ƒј–—“¬≈ЌЌџ… »Ќ—“»“”“ –јƒ»ќ“≈’Ќ» », ЁЋ≈ “–ќЌ» » » ј¬“ќћј“» » (“≈’Ќ»„≈— »… ”Ќ»¬≈–—»“≈“)</publisher>
   <city>ћосква</city>
   <year>1999</year>
  </publish-info>
 </description>
 <body>
  <title>
   <p>јлександр —тепанов</p>
   <p>ћенг Ћи</p>
   <p>–” ќ¬ќƒ—“¬ќ ѕќ —“јЌƒј–“Ќќ… Ѕ»ЅЋ»ќ“≈ ≈ ЎјЅЋќЌќ¬ (STL)</p>
  </title>
  <section>
   <title>
    <p>¬ведение</p>
   </title>
   <p>—тандартна€ Ѕиблиотека Ўаблонов предоставл€ет набор хорошо сконструированных и согласованно работающих вместе обобщЄнных компонентов C++. ќсоба€ забота была про€влена дл€ обеспечени€ того, чтобы все шаблонные алгоритмы работали не только со структурами данных в библиотеке, но также и с встроенными структурами данных C++. Ќапример, все алгоритмы работают с обычными указател€ми. ќртогональный проект библиотеки позвол€ет программистам использовать библиотечные структуры данных со своими собственными алгоритмами, а библиотечные алгоритмы - со своими собственными структурами данных. ’орошо определЄнные семантические требовани€ и требовани€ сложности гарантируют, что компонент пользовател€ будет работать с библиотекой и что он будет работать эффективно. Ёта гибкость обеспечивает широкую применимость библиотеки.</p>
   <p>ƒругое важное соображение - эффективность. C++ успешен, потому что он объедин€ет выразительную мощность с эффективностью. ћного усилий было потрачено, чтобы проверить, что каждый шаблонный компонент в библиотеке имеет обобщЄнную реализацию, котора€ имеет эффективность выполнени€ с разницей в пределах нескольких процентов от эффективности соответствующей программы ручной кодировки.</p>
   <p>“ретьим соображением в проекте была разработка библиотечной структуры, котора€, будучи естественной и лЄгкой дл€ понимани€, основана на прочной теоретической основе.</p>
  </section>
  <section>
   <title>
    <p>—труктура библиотеки</p>
   </title>
   <p>Ѕиблиотека содержит п€ть основных видов компонентов:</p>
   <p>-†алгоритм (<emphasis>algorithm</emphasis>): определ€ет вычислительную процедуру.</p>
   <p>-†контейнер (<emphasis>container</emphasis>): управл€ет набором объектов в пам€ти.</p>
   <p>-†итератор (<emphasis>iterator</emphasis>): обеспечивает дл€ алгоритма средство доступа к содержимому контейнера.</p>
   <p>-†функциональный объект (<emphasis>function object</emphasis>): инкапсулирует функцию в объекте дл€ использовани€ другими компонентами.</p>
   <p>-†адаптер (<emphasis>adaptor</emphasis>): адаптирует компонент дл€ обеспечени€ различного интерфейса.</p>
   <p>“акое разделение позвол€ет нам уменьшить количество компонентов. Ќапример, вместо написани€ функции поиска элемента дл€ каждого вида контейнера мы обеспечиваем единственную версию, котора€ работает с каждым из них, пока удовлетвор€етс€ основной набор требований.</p>
   <p>—ледующее описание разъ€сн€ет структуру библиотеки. ≈сли программные компоненты сведены в таблицу как трЄхмерный массив, где одно измерение представл€ет различные типы данных (например, int, double), второе измерение представл€ет различные контейнеры (например, вектор, св€зный список, файл), а третье измерение представл€ет различные алгоритмы с контейнерами (например, поиск, сортировка, перемещение по кругу), если i, j и k - размеры измерений, тогда должно быть разработано i* j *k различных версий кода. ѕри использовании шаблонных функций, которые берут параметрами типы данных, нам нужно только j * k версий. ƒалее, если заставим наши алгоритмы работать с различными контейнерами, то нам нужно просто j+k версий. Ёто значительно упрощает разработку программ, а также позвол€ет очень гибким способом использовать компоненты в библиотеке вместе с определ€емыми пользователем компонентами. ѕользователь может легко определить специализированный контейнерный класс и использовать дл€ него библиотечную функцию сортировки. ƒл€ сортировки пользователь может выбрать какую-то другую функцию сравнени€ либо через обычный указатель на сравнивающую функцию, либо через функциональный объект (объект, дл€ которого определЄн operator()), который сравнивает. ≈сли пользователю необходимо выполнить передвижение через контейнер в обратном направлении, то используетс€ адаптер reverse_iterator.</p>
   <p>Ѕиблиотека расшир€ет основные средства C++ последовательным способом, так что программисту на C/C++ легко начать пользоватьс€ библиотекой. Ќапример, библиотека содержит шаблонную функцию merge (сли€ние).  огда пользователю нужно два массива a и b объединить в с, то это может быть выполнено так:</p>
   <p><code>int a[1000];</code></p>
   <p><code>int b[2000];</code></p>
   <p><code>int c[3000];</code></p>
   <p><code>Е</code></p>
   <p><code>merge(a, a+1000, b, b+2000, c);</code></p>
   <p> огда пользователь хочет объединить вектор и список (оба - шаблонные классы в библиотеке) и поместить результат в заново распределЄнную неинициализированную пам€ть, то это может быть выполнено так:</p>
   <p><code>vectorЛEmployeeЫ a;</code></p>
   <p><code>listЛEmployeeЫ b;</code></p>
   <p><code>Е</code></p>
   <p><code>Employee* с = allocate(a.size() + b.size(), (Employee*)0);</code></p>
   <p><code>merge(a.begin(), a.end(), b.begin(), b.end(), raw_storage_iteratorЛEmployee*, EmployeeЫ(c));</code></p>
   <p>где begin() и end() - функции-члены контейнеров, которые возвращают правильные типы итераторов или указателе-подобных объектов, позвол€ющие merge выполнить задание, а raw_storage_iterator - адаптер, который позвол€ет алгоритмам помещать результаты непосредственно в неинициализированную пам€ть, вызыва€ соответствующий конструктор копировани€.</p>
   <p>¬о многих случа€х полезно перемещатьс€ через потоки ввода-вывода таким же образом, как через обычные структуры данных. Ќапример, если мы хотим объединить две структуры данных и затем сохранить их в файле, было бы хорошо избежать создани€ вспомогательной структуры данных дл€ хранени€ результата, а поместить результат непосредственно в соответствующий файл. Ѕиблиотека обеспечивает и istream_iterator, и ostream_iterator шаблонные классы, чтобы многие из библиотечных алгоритмов могли работать с потоками ввода-вывода, которые представл€ют однородные блоки данных. ƒалее приводитс€ программа, котора€ читает файл, состо€щий из целых чисел, из стандартного ввода, удал€€ все числа, дел€щиес€ на параметр команды, и записывает результат в стандартный вывод:</p>
   <p><code>main(int argc, char** argv) {</code></p>
   <p><code>†if (argc!= 2) throw("usage: remove_if_divides integer\n ");</code></p>
   <p><code>†remove_copy_if(istream_iteratorЛintЫ(cin), istream_iteratorЛintЫ(), ostream_iteratorЛintЫ(cout, "\n"),††not1(bind2nd(modulusЛintЫ(), atoi(argv[1]))));</code></p>
   <p><code>}</code></p>
   <p>¬с€ работа выполн€етс€ алгоритмом remove_copy_if, который читает целые числа одно за другим, пока итератор ввода не становитс€ равным <emphasis>end-of-stream</emphasis> (<emphasis>конец-потока</emphasis>) итератору, который создаЄтс€ конструктором без параметров. (¬ообще все алгоритмы работают способом "отсюда досюда", использу€ два итератора, которые показывают начало и конец ввода.) ѕотом remove_copy_if записывает целые числа, которые выдерживают проверку, в выходной поток через итератор вывода, который св€зан с cout. ¬ качестве предиката remove_copy_if использует функциональный объект, созданный из функционального объекта modulusЛintЫ, который берЄт i и j и возвращает i % j как бинарный предикат, и превращает в унарный предикат, использу€ bind2nd, чтобы св€зать второй параметр с параметром командной строки atoi(argv[1]). ѕотом отрицание этого унарного предиката получаетс€ с помощью адаптера функции not1.</p>
   <p>Ќесколько более реалистичный пример - фильтрующа€ программа, котора€ берЄт файл и беспор€дочно перетасовывает его строки.</p>
   <p><code>main(int argc, char**) {</code></p>
   <p><code>†if (argc!= 1) throw("usage: shuffle\n");</code></p>
   <p><code>†vectorЛstringЫ v;</code></p>
   <p><code>†copy(istream_iteratorЛstringЫ(cin), istream_iteratorЛstringЫ(), inserter(v, v.end()));</code></p>
   <p><code>†random_shuffle(v.begin(), v.end());</code></p>
   <p><code>†copy(v.begin(), v.end(), ostream_iteratorЛstringЫ(cout));</code></p>
   <p><code>}</code></p>
   <p>¬ этом примере copy перемещает строки из стандартного ввода в вектор, но так как вектор предварительно не размещЄн в пам€ти, используетс€ итератор вставки, чтобы вставить в вектор строки одну за другой. (Ёта методика позвол€ет всем функци€м копировани€ работать в обычном режиме замены также, как в режиме вставки.) ѕотом random_shuffle перетасовывает вектор, а другой вызов copy копирует его в поток cout.</p>
  </section>
  <section>
   <title>
    <p>“ребовани€</p>
   </title>
   <p>ƒл€ гарантии совместной работы различные компоненты библиотеки должны удовлетвор€ть некоторым основным требовани€м. “ребовани€ должны быть общими, насколько это возможно, так что вместо высказывани€ "класс X должен определить функцию-член operator++() ", мы говорим "дл€ любого объекта x класса X определЄн ++x ". (Ќе определено, €вл€етс€ ли оператор членом или глобальной функцией.) “ребовани€ установлены в терминах чЄтких выражений, которые определ€ют допустимые услови€ типов, удовлетвор€ющих требовани€м. ƒл€ каждого набора требований имеетс€ таблица, котора€ определ€ет начальный набор допустимых выражений и их семантику. Ћюбой обобщЄнный алгоритм, который использует требовани€, должен быть написан в терминах допустимых выражений дл€ своих формальных параметров.</p>
   <p>≈сли требуетс€, чтобы была операци€ линейного времени сложности, это значит - не хуже, чем линейного времени, и операци€ посто€нного времени удовлетвор€ет требованию.</p>
   <p>¬ некоторых случа€х мы представили семантические требовани€, использующие код C++. “акой код предназначен как спецификаци€ эквивалентности одной конструкции другой, не об€зательно как способ, которым конструкци€ должна быть реализована (хот€ в некоторых случа€х данный код, однозначно, €вл€етс€ оптимальной реализацией).</p>
  </section>
  <section>
   <title>
    <p>ќсновные компоненты</p>
   </title>
   <section>
    <p>Ётот раздел содержит некоторые основные шаблонные функции и классы, которые используютс€ в остальной части библиотеки.</p>
   </section>
   <section>
    <title>
     <p>ќператоры (Operators)</p>
    </title>
    <p>„тобы избежать избыточных определений operator!= из operator== и operatorЫ, Л=, Ы= из operatorЛ, библиотека обеспечивает следующее:</p>
    <p><code>template Лclass Tl, class T2Ы</code></p>
    <p><code>inline bool operator!=(const T1&amp; x, const T2&amp; y) {</code></p>
    <p><code>†return !(x†== y);</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>template Лclass Tl, class T2Ы</code></p>
    <p><code>inline bool operatorЫ(const T1&amp; x, const T2&amp; y) {</code></p>
    <p><code>†return y Л x;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>template Лclass Tl, class T2Ы</code></p>
    <p><code>inline bool operatorЛ=(const T1&amp; x, const T2&amp; y) {</code></p>
    <p><code>†return !(y Л x);</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>template Лclass Tl, class T2Ы</code></p>
    <p><code>inline bool operatorЫ=(const T1&amp; x, const T2&amp; y) {</code></p>
    <p><code>†return !(x Л y);</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ѕара (Pair)</p>
    </title>
    <p>Ѕиблиотека включает шаблоны дл€ разнородных пар значений.</p>
    <p><code>template Лclass T1, class T2Ы</code></p>
    <p><code>struct pair {</code></p>
    <p><code>†T1 first;</code></p>
    <p><code>†T2 second;</code></p>
    <p><code>†pair() {}</code></p>
    <p><code>†pair(const T1&amp; x, const T2&amp; y): first(x), second(y) {}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>template Лclass T1, class T2Ы</code></p>
    <p><code>inline bool operator==(const pairЛTl,T2Ы&amp; x, const pairЛTl,T2Ы&amp; y) {</code></p>
    <p><code>†return x.first†== y.first &amp;&amp; x.second†== y.second;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>template Лclass T1, class T2Ы</code></p>
    <p><code>inline bool operatorЛ(const pairЛTl,T2Ы&amp; x, const pairЛTl,T2Ы&amp; y) {</code></p>
    <p><code>†return x.first Л y.first || (!(y.first Л x.first) &amp;&amp; x.second Л y.second);</code></p>
    <p><code>}</code></p>
    <p>Ѕиблиотека обеспечивает соответствующую шаблонную функцию make_pair, чтобы упростить конструкцию пар. ¬место выражени€, например:</p>
    <p><code>return pairЛint, doubleЫ(5, 3.1415926); // €вные типы,</code></p>
    <p>можно написать</p>
    <p><code>return make_pair(5, 3.1415926); // типы вывод€тс€.</code></p>
    <empty-line/>
    <p><code>template Лclass Tl, class T2Ы</code></p>
    <p><code>inline pairЛTl,T2Ы make_pair(const T1&amp; x, const T2&amp; y) {</code></p>
    <p><code>†return pairЛTl,T2Ы(x, y);</code></p>
    <p><code>}</code></p>
   </section>
  </section>
  <section>
   <title>
    <p>»тераторы</p>
   </title>
   <section>
    <p>»тераторы - это обобщение указателей, которые позвол€ют программисту работать с различными структурами данных (контейнерами) единообразным способом. „тобы создать шаблонные алгоритмы, которые правильно и эффективно работают с различными типами структур данных, нам нужно формализовать не только интерфейсы, но также семантику и предположени€ сложности итераторов. »тераторы - это объекты, которые имеют operator*, возвращающий значение некоторого класса или встроенного типа T, называемого <emphasis>значимым типом</emphasis> (<emphasis>value type</emphasis>) итератора. ƒл€ каждого типа итератора X, дл€ которого определено равенство, имеетс€ соответствующий знаковый целочисленный тип, называемый <emphasis>типом рассто€ни€</emphasis> (<emphasis>distanсe type</emphasis>) итератора.</p>
    <p>“ак как итераторы - обобщение указателей, их семантика - обобщение семантики указателей в C++. Ёто гарантирует, что кажда€ шаблонна€ функци€, котора€ использует итераторы, работает с обычными указател€ми. ≈сть п€ть категорий итераторов в зависимости от операций, определЄнных дл€ них: <emphasis>ввода</emphasis> (<emphasis>input iterators</emphasis>), <emphasis>вывода</emphasis> (<emphasis>output iterators</emphasis>), <emphasis>последовательные</emphasis> (<emphasis>forward iterators</emphasis>), <emphasis>двунаправленные</emphasis> (<emphasis>bidirectional iterators</emphasis>) и <emphasis>произвольного доступа</emphasis> (<emphasis>random access iterators</emphasis>.) ѕоследовательные итераторы удовлетвор€ют всем требовани€м итераторов ввода и вывода и могут использоватьс€ вс€кий раз, когда определ€етс€ тот или другой вид. ƒвунаправленные итераторы удовлетвор€ют всем требовани€м последовательных итераторов и могут использоватьс€ вс€кий раз, когда определ€етс€ последовательный итератор. »тераторы произвольного доступа удовлетвор€ют всем требовани€м двунаправленных итераторов и могут использоватьс€ вс€кий раз, когда определ€етс€ двунаправленный итератор. »меетс€ дополнительный атрибут, который могли быть иметь последовательные, двунаправленные и произвольного доступа итераторы, то есть они могут быть <emphasis>модифицируемые</emphasis> (<emphasis>mutable</emphasis>) или <emphasis>посто€нные</emphasis> (<emphasis>constant</emphasis>) в зависимости от того, ведЄт ли себ€ результат operator* как ссылка или как ссылка на константу. ѕосто€нные итераторы не удовлетвор€ют требовани€м итераторов вывода.</p>
    <p><strong>“аблица 1. ќтношени€ среди категорий итераторов</strong> </p>
    <table>
     <tr align="left">
      <td rowspan="2" align="left" valign="top">ѕроизвольного доступа -Ы ƒвунаправленные -Ы ѕоследовательные --&gt; </td>
      <td align="left" valign="top">-†Ы ¬вода </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">-†Ы ¬ывода</td>
     </tr>
    </table>
    <p>“очно также, как обычный указатель на массив гарантирует, что имеетс€ значение указател€, указывающего за последний элемент массива, так и дл€ любого типа итератора имеетс€ значение итератора, который указывает за последний элемент соответствующего контейнера. Ёти значени€ называютс€ <emphasis>законечными</emphasis> (<emphasis>past-the-end</emphasis>) значени€ми. «начени€ итератора, дл€ которых operator* определЄн, называютс€ <emphasis>разыменовываемыми</emphasis> (<emphasis>dereferenceable</emphasis>). Ѕиблиотека никогда не допускает, что законечные значени€ €вл€ютс€ разыменовываемыми. »тераторы могут также иметь <emphasis>исключительные</emphasis> (<emphasis>singular</emphasis>) значени€, которые не св€заны ни с каким контейнером. Ќапример, после объ€влени€ неинициализированного указател€ x (например, int* x;), всегда должно предполагатьс€, что x имеет исключительное значение указател€. –езультаты большинства выражений не определены дл€ исключительных значений. ≈динственное исключение - присваивание неисключительного значени€ итератору, который имеет исключительное значение. ¬ этом случае исключительное значение перезаписываетс€ таким же образом, как любое другое значение. –азыменовываемые и законечные значени€ всегда €вл€ютс€ неисключительными.</p>
    <p>»тератор j называетс€ <emphasis>доступным</emphasis> (<emphasis>reachable</emphasis>) из итератора i, если и только если имеетс€ конечна€ последовательность применений operator++ к i, котора€ делает i==j. ≈сли i и j относ€тс€ к одному и тому же контейнеру, тогда или j доступен из i, или i доступен из j, или оба доступны (i==j).</p>
    <p>Ѕольшинство алгоритмических шаблонов библиотеки, которые работают со структурами данных, имеют интерфейсы, которые используют диапазоны. ƒиапазон - это пара итераторов, которые указывают начало и конец вычислени€. »нтервал [i,i) - пустой диапазон; вообще, диапазон [i,j) относитс€ к элементам в структуре данных, начина€ с элемента, указываемого i, и до элемента, но не включа€ его, указываемого j. ƒиапазон [i,j) допустим, если и только если j доступен из i. –езультат применени€ алгоритмов библиотеки к недопустимым диапазонам не определЄн.</p>
    <p>¬се категории итераторов требуют только те функции, которые осуществимы дл€ данной категории со сложностью посто€нного времени (амортизированные). ѕоэтому таблицы требований дл€ итераторов не имеют столбца сложности.</p>
    <p>¬ следующих разделах мы принимаем: a и b - значени€ X, n - значение типа рассто€ни€ Distance, u, tmp и m - идентификаторы, r и s - леводопустимые (lvalues) значени€ X, t - значение значимого типа T.</p>
   </section>
   <section>
    <title>
     <p>»тераторы ввода (Input iterators)</p>
    </title>
    <p> ласс или встроенный тип X удовлетвор€ет требовани€м итератора ввода дл€ значимого типа T, если справедливы следующие выражени€:</p>
    <p><strong>“аблица 2. “ребовани€ итератора ввода</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнени€ </th>
      <th align="left" valign="top">утверждение/примечание состо€ние до/после </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X(a)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-†</td>
      <td align="left" valign="top">X(a) - копи€ a. примечание: предполагаетс€ деструктор. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X u(a); <emphasis>X u = a; </emphasis></td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-†</td>
      <td align="left" valign="top">после: u - копи€ a.</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">u = a </td>
      <td align="left" valign="top">X&amp;</td>
      <td align="left" valign="top">-†</td>
      <td align="left" valign="top">после: u - копи€ a. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a†== b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">-†</td>
      <td align="left" valign="top">если a - копи€ b, тогда a†== b возвращает true.†== - это отношение эквивалентности в области действи€ ==. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a!= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a == b)</td>
      <td align="left" valign="top">-†</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">*a </td>
      <td align="left" valign="top">обратимый в T</td>
      <td align="left" valign="top">-†</td>
      <td align="left" valign="top">до: a - разыменовываемое. если a - копи€ b, то *a эквивалентно *b. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">++r </td>
      <td align="left" valign="top">X&amp;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">до: r - разыменовываемое. после: r - разыменовываемое или r - законечное. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">void r++ </td>
      <td align="left" valign="top">void </td>
      <td align="left" valign="top">void ++r</td>
      <td align="left" valign="top">-†</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">*r++ </td>
      <td align="left" valign="top">“ </td>
      <td align="left" valign="top">{X tmp = r; ++r; return tmp;}</td>
      <td align="left" valign="top">-</td>
     </tr>
    </table>
    <p><strong>ѕ–»ћ≈„јЌ»≈.</strong> ƒл€ итераторов ввода нет никаких требований на тип или значение r++ кроме требовани€, чтобы *r++ работал соответственным образом. ¬ частности, r†== s не подразумевает, что ++r†== ++s. (–авенство не гарантирует свойство замены или ссылочной прозрачности.) „то касаетс€ ++r, то нет больше никаких требований на значени€ любых копий r за исключением того, что они могут быть безопасно уничтожены или присвоены. ѕосле выполнени€ ++r не требуетс€, чтобы были копии (предыдущего) r в области ==. јлгоритмы с итераторами ввода никогда не должны пытатьс€ проходить через тот же самый итератор дважды. ќни должны быть <emphasis>однопроходными</emphasis> (<emphasis>single pass</emphasis>) алгоритмами. <emphasis>Ќе требуетс€, чтобы значимый тип T был леводопустимым типом (lvalue type)</emphasis>. Ёти алгоритмы могут использоватьс€ с входными потоками как источниками входных данных через класс istream_iterator.</p>
   </section>
   <section>
    <title>
     <p>»тераторы вывода (Output iterators)</p>
    </title>
    <p> ласс или встроенный тип X удовлетвор€ет требовани€м итератора вывода, если справедливы следующие выражени€:</p>
    <p><strong>“аблица 3. “ребовани€ итератора вывода</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнени€ </th>
      <th align="left" valign="top">утверждение/примечание состо€ние до/после </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X(a)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">*a = t эквивалентно *X(a) = t. примечание: предполагаетс€ деструктор. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X u(a); <emphasis>X u = a; </emphasis></td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-†</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">*a = t </td>
      <td align="left" valign="top">результат не используетс€</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">++r </td>
      <td align="left" valign="top">X&amp;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r++ </td>
      <td align="left" valign="top">’ или ’&amp;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-†</td>
     </tr>
    </table>
    <p><strong>ѕ–»ћ≈„јЌ»≈.</strong> ≈динственное допустимое использование operator* - на левой стороне выражени€ присваивани€. <emphasis>ѕрисваивание через то же самое значение итератора происходит только однажды</emphasis>. јлгоритмы с итераторами вывода никогда не должны пытатьс€ проходить через тот же самый итератор дважды. ќни должны быть <emphasis>однопроходными</emphasis> (<emphasis>single pass</emphasis>) алгоритмами. –авенство и неравенство не об€зательно определены. јлгоритмы, которые берут итераторы вывода, могут использоватьс€ с выходными потоками дл€ помещени€ в них данных через класс ostream_iterator, также как с итераторами вставки и вставл€ющими указател€ми. ¬ частности, следующие два услови€ должны соблюдатьс€: во-первых, через любое значение итератора должно выполн€тьс€ присваивание до его увеличени€ (то есть, дл€ итератора вывода i недопустима последовательность кода i++; i++;); во-вторых, любое значение итератора вывода может иметь только одну активную копию в любое данное врем€ (например, недопустима последовательность кода i = j; *++i = a; *j = b;).</p>
   </section>
   <section>
    <title>
     <p>ѕоследовательные итераторы (Forward iterators)</p>
    </title>
    <p> ласс или встроенный тип X удовлетвор€ет требовани€м последовательного итератора, если справедливы следующие выражени€:</p>
    <p><strong>“аблица 4. “ребовани€ последовательного итератора</strong>†</p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнени€ </th>
      <th align="left" valign="top">утверждение/примечание состо€ние до/после</th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X u;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-†</td>
      <td align="left" valign="top">примечание: u может иметь исключительное значение. примечание: предполагаетс€ деструктор. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X()</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">примечание: X() может быть исключительным. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X(a);</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">a†== X(a) </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X u(a); X u = a;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">X u; u = a; </td>
      <td align="left" valign="top">после: u†== a. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a†== b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">-†</td>
      <td align="left" valign="top">==†- это отношение эквивалентности. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a!= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a†== b)</td>
      <td align="left" valign="top">-†</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r = a </td>
      <td align="left" valign="top">X&amp;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">после: r†== a. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">*a </td>
      <td align="left" valign="top">обратимый в T</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">до: a - разыменовываемое. a==b подразумевает *a==*b. ≈сли X - модифицируемый, то *a = t - допустимо. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">++r </td>
      <td align="left" valign="top">X&amp;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">до: r - разыменовываемое. после: r - разыменовываемое или r - законечное. r†== s и r - разыменовываемое подразумевает ++r==++s. &amp;r==&amp;++r. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r++ </td>
      <td align="left" valign="top">X </td>
      <td align="left" valign="top">{X tmp = r; <emphasis>++ r; return tmp;}</emphasis></td>
      <td align="left" valign="top">- </td>
     </tr>
    </table>
    <p><strong>ѕ–»ћ≈„јЌ»≈.</strong> “от факт, что r†== s подразумевает ++r†== ++s (что неверно дл€ итераторов ввода и вывода) и что удалено ограничение на число присваиваний через итератор (которое примен€етс€ к итераторам вывода), позвол€ет использование многопроходных однонаправленных алгоритмов с последовательными итераторами.</p>
   </section>
   <section>
    <title>
     <p>ƒвунаправленные итераторы (Bidirectional iterators)</p>
    </title>
    <p> ласс или встроенный тип X удовлетвор€ет требовани€м двунаправленного итератора, если к таблице, котора€ определ€ет последовательные итераторы, мы добавим следующие строки:</p>
    <p><strong>“аблица 5. “ребовани€ двунаправленного итератора (в дополнение к последовательному итератору)</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнени€ </th>
      <th align="left" valign="top">утверждение/примечание состо€ние до/после </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">--r </td>
      <td align="left" valign="top">X&amp;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">до: существует s такое, что r==++s. после: s - разыменовываемое. --(++r)==r. --r==--s подразумевает r==s.&amp;r==&amp;--r. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r-- </td>
      <td align="left" valign="top">X </td>
      <td align="left" valign="top">{X tmp = r; -<emphasis>-r; return tmp;}</emphasis></td>
      <td align="left" valign="top"><emphasis>-</emphasis> </td>
     </tr>
    </table>
    <p><strong>ѕ–»ћ≈„јЌ»≈.</strong> ƒвунаправленные итераторы позвол€ют алгоритмам перемещать итераторы назад так же, как вперЄд.</p>
   </section>
   <section>
    <title>
     <p>»тераторы произвольного доступа (Random access iterators)</p>
    </title>
    <p> ласс или встроенный тип X удовлетвор€ет требовани€м итераторов произвольного доступа, если к таблице, котора€ определ€ет двунаправленные итераторы, мы добавим следующие строки:</p>
    <p><strong>“аблица 6: “ребовани€ итератора произвольного доступа (в дополнение к двунаправленному итератору)</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнени€ </th>
      <th align="left" valign="top">утверждение/примечание состо€ние до/после </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r += n </td>
      <td align="left" valign="top">X&amp; </td>
      <td align="left" valign="top">{Distance m = n; if(m Ы= 0) while(m--) ++r; else while(m++) --r; return r;}</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a + n <emphasis>n + a </emphasis></td>
      <td align="left" valign="top">X </td>
      <td align="left" valign="top">{X tmp = a; <emphasis>return tmp += n;} </emphasis></td>
      <td align="left" valign="top">a + n†== n + a. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r -= n</td>
      <td align="left" valign="top">X&amp; </td>
      <td align="left" valign="top">return r += -n;</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a - n </td>
      <td align="left" valign="top">X </td>
      <td align="left" valign="top">{X tmp = a; <emphasis>return tmp -= n;}</emphasis></td>
      <td align="left" valign="top"><emphasis>-</emphasis></td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">b - a </td>
      <td align="left" valign="top">Distance</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">до: существует значение n типа Distance такое, что a+n=b. b==a+(b-a). </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a[n] </td>
      <td align="left" valign="top">обратимый в T</td>
      <td align="left" valign="top">*(a + n)</td>
      <td align="left" valign="top">-†</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a Л b </td>
      <td align="left" valign="top">обратимый в bool </td>
      <td align="left" valign="top">b - a Ы 0 </td>
      <td align="left" valign="top">Л - это отношение полного упор€дочени€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a Ы b </td>
      <td align="left" valign="top">обратимый в bool </td>
      <td align="left" valign="top">b Л a </td>
      <td align="left" valign="top">Ы - это отношение полного упор€дочени€, противоположное Л. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a Ы= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a Л b)</td>
      <td align="left" valign="top">-†</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a Л= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a Ы b)</td>
      <td align="left" valign="top">- </td>
     </tr>
    </table>
   </section>
   <section>
    <title>
     <p>“еги итераторов (Iterator tags)</p>
    </title>
    <section>
     <p>„тобы осуществл€ть алгоритмы только в терминах итераторов, часто бывает необходимо вывести тип значени€ и тип рассто€ни€ из итератора. ƒл€ решени€ этой задачи требуетс€, чтобы дл€ итератора i любой категории, отличной от итератора вывода, выражение value_type(i) возвращало (T*)(0), а выражение distance_type(i) возвращало (Distance*)(0). ƒл€ итераторов вывода эти выражени€ не требуютс€.</p>
    </section>
    <section>
     <title>
      <p>ѕримеры использовани€ тегов итераторов</p>
     </title>
     <p>ƒл€ всех типов обычных указателей мы можем определить value_type и distance_type с помощью следующего:</p>
     <p><code>template Лclass TЫ</code></p>
     <p><code>inline T* value_type(const T*) {return (T*)(0);}</code></p>
     <empty-line/>
     <p><code>template Лclass TЫ</code></p>
     <p><code>inline ptrdiff_t* distance_type(const T*) {return (ptrdiff_t*)(0);}</code></p>
     <p>“огда, если мы хотим осуществить обобщЄнную функцию reverse, мы пишем следующее:</p>
     <p><code>template Лclass BidirectionalIteratorЫ</code></p>
     <p><code>inline void reverse(BidirectionalIterator first, BidirectionalIterator last) {</code></p>
     <p><code>†_reverse(first, last, value_type(first), distance_type(first));</code></p>
     <p><code>}</code></p>
     <p>где _reverse определена следующим образом:</p>
     <p><code>template Лclass BidirectionalIterator, class T, class DistanceЫ</code></p>
     <p><code>void _reverse(BidirectionalIterator first, BidirectionalIterator last, T*, Distance*) {</code></p>
     <p><code>†Distance n;</code></p>
     <p><code>†distance(first, last, n); // смотри раздел "ќперации с итераторами"</code></p>
     <p><code>†--n;</code></p>
     <p><code>†while (n Ы 0) {</code></p>
     <p><code>† T tmp = *first;</code></p>
     <p><code>† *first++ = *--last;</code></p>
     <p><code>† *last = tmp;</code></p>
     <p><code>† n -= 2;</code></p>
     <p><code>†}</code></p>
     <p><code>}</code></p>
     <p>≈сли имеетс€ дополнительный тип указател€ _huge такой, что разность двух указателей _huge имеет тип long long, мы определ€ем:</p>
     <p><code>template Лclass TЫ</code></p>
     <p><code>inline T* value_type(const T _huge *) {return (T*) (0);}</code></p>
     <empty-line/>
     <p><code>template Лclass TЫ</code></p>
     <p><code>inline long long* distance_type(const T _huge *) {</code></p>
     <p><code>†return (long long*)(0);</code></p>
     <p><code>}</code></p>
     <p>„асто желательно дл€ шаблонной функции вы€снить, какова наиболее специфична€ категори€ еЄ итераторного аргумента, так чтобы функци€ могла выбирать наиболее эффективный алгоритм во врем€ компил€ции. „тобы облегчить это, библиотека вводит классы <emphasis>тегов категорий</emphasis> (<emphasis>category tag</emphasis>), которые используютс€ как теги времени компил€ции дл€ выбора алгоритма. Ёто следущие теги: input_iterator_tag, output_iterator_tag, forward_iterator_tag, bidirectional_iterator_tag и random_access_iterator_tag.  аждый итератор i должен иметь выражение iterator_category(i), определЄнное дл€ него, которое возвращает тег наиболее специфичной категории, который описывает его поведение. Ќапример, мы определ€ем, что все типы указателей наход€тс€ в категории итераторов произвольного доступа:</p>
     <p><code>template Лclass TЫ</code></p>
     <p><code>inline random_access_iterator_tag iterator_category(const T*) {</code></p>
     <p><code>†return random_access_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p>ќпредел€емый пользователем итератор BinaryTreeIterator может быть включен в категорию двунаправленных итераторов следующим образом:</p>
     <p><code>template Лclass TЫ</code></p>
     <p><code>inline bidirectional_iterator_tag iterator_category(const BinaryTreeIteratorЛTЫ&amp;)†{</code></p>
     <p><code>†return bidirectional_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p>≈сли шаблонна€ функци€ evolve хорошо определена дл€ двунаправленных итераторов, но может быть осуществлена более эффективно дл€ итераторов произвольного доступа, тогда реализаци€ выгл€дит так:</p>
     <p><code>template Лclass BidirectionalIteratorЫ</code></p>
     <p><code>inline void evolve(BidirectionalIterator first, BidirectionalIterator last) {</code></p>
     <p><code>†evolve(first, last, iterator_category(first));</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template Лclass BidirectionalIteratorЫ</code></p>
     <p><code>void evolve(BidirectionalIterator first, BidirectionalIterator last, bidirectional_iterator_tag) {</code></p>
     <p><code>†//Е более универсальный, но менее эффективный алгоритм</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIteratorЫ</code></p>
     <p><code>void evolve(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag) {</code></p>
     <p><code>†//Е более эффективный, но менее универсальный алгоритм</code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>ѕримитивы, определЄнные в библиотеке</p>
     </title>
     <p>„тобы упростить задачу определени€ iterator_category, value_type и distance_type дл€ определ€емых пользователем итераторов, библиотека обеспечивает следующие предопределЄнные классы и функции:</p>
     <p><code>// iterator tags (теги итераторов)</code></p>
     <p><code>struct input_iterator_tag {};</code></p>
     <p><code>struct output_iterator_tag {};</code></p>
     <p><code>struct forward_iterator_tag {};</code></p>
     <p><code>struct bidirectional_iterator_tag {};</code></p>
     <p><code>struct random_access_iterator_tag {};</code></p>
     <empty-line/>
     <p><code>// iterator bases (базовые классы итераторов)</code></p>
     <p><code>template Лclass T, class Distance = ptrdiff_tЫ struct input_iterator {};</code></p>
     <p><code>struct output_iterator {};</code></p>
     <p><code>// output_iterator не шаблон, потому что у итераторов вывода</code></p>
     <p><code>// не определены ни значимый тип, ни тип рассто€ни€.</code></p>
     <p><code>template Лclass T, class Distance = ptrdiff_tЫ</code></p>
     <p><code>struct forward_iterator {};</code></p>
     <p><code>template Лclass T, class Distance = ptrdiff_tЫ</code></p>
     <p><code>struct bidirectional_iterator {};</code></p>
     <p><code>template Лclass T, class Distance = ptrdiff_tЫ</code></p>
     <p><code>struct random_access_iterator {};</code></p>
     <empty-line/>
     <p><code>// iterator_category (функции категорий итераторов)</code></p>
     <p><code>template Лclass T, class DistanceЫ</code></p>
     <p><code>inline input_iterator_tag iterator_category(const input_iteratorЛT, DistanceЫ&amp;) {</code></p>
     <p><code>†return input_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p><code>inline output_iterator_tag iterator_category(const output_iterator&amp;) {</code></p>
     <p><code>†return output_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p><code>template Лclass T, class DistanceЫ</code></p>
     <p><code>inline forward_iterator_tag iterator_category(const forward_iteratorЛT, DistanceЫ&amp;) {</code></p>
     <p><code>†return forward_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p><code>template Лclass T, class DistanceЫ </code></p>
     <p><code>inline bidirectional_iterator_tag iterator_category(const bidirectional_iteratorЛT, DistanceЫ&amp;) {</code></p>
     <p><code>†return bidirectional_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p><code>template Лclass T, class DistanceЫ</code></p>
     <p><code>inline random_access_iterator_tag iterator_category(const random_access_iteratorЛT, DistanceЫ&amp;) {</code></p>
     <p><code>†return random_access_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p><code>template Лclass TЫ</code></p>
     <p><code>inline random_access_iterator_tag iterator_category(const T*) {</code></p>
     <p><code>†return random_access_iterator_tag();</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>// value_type of iterator (функции значимого типа итераторов)</code></p>
     <p><code>template Лclass T, class DistanceЫ</code></p>
     <p><code>inline T* value_type(const input_iteratorЛT, DistanceЫ&amp;) {</code></p>
     <p><code>†return (T*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template Лclass T, class DistanceЫ</code></p>
     <p><code>inline T* value_type(const forward_iteratorЛT, DistanceЫ&amp;) {</code></p>
     <p><code>†return (T*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template Лclass T, class DistanceЫ</code></p>
     <p><code>inline T* value_type(const bidirectional_iteratorЛT, DistanceЫ&amp;) {</code></p>
     <p><code>†return (T*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template Лclass T, class DistanceЫ</code></p>
     <p><code>inline T* value_type(const random_access_iteratorЛT, DistanceЫ&amp;) {</code></p>
     <p><code>†return (T*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template Лclass TЫ</code></p>
     <p><code>inline T* value_type(const T*) {return (T*) (0);}</code></p>
     <empty-line/>
     <p><code>// distance_type of iterator (функции типа рассто€ни€ итераторов)</code></p>
     <p><code>template Лclass T, class DistanceЫ</code></p>
     <p><code>inline Distance* distance_type(const input_iteratorЛT, DistanceЫ&amp;) {</code></p>
     <p><code>†return (Distance*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template Лclass T, class DistanceЫ</code></p>
     <p><code>inline Distance* distance_type(const forward_iteratorЛT, DistanceЫ&amp;) {</code></p>
     <p><code>†return (Distance*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template Лclass T, class DistanceЫ</code></p>
     <p><code>inline Distance* distance_type(const bidirectional_iteratorЛT, DistanceЫ&amp;) {</code></p>
     <p><code>†return (Distance*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template Лclass T, class DistanceЫ</code></p>
     <p><code>inline Distance* distance_type(const random_access_iteratorЛT, DistanceЫ&amp;) {</code></p>
     <p><code>†return (Distance*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template Лclass TЫ</code></p>
     <p><code>inline ptrdiff_t* distance_type(const T*) {return (ptrdiff_t*) (0);}</code></p>
     <p>≈сли пользователь хочет определить двунаправленный итератор дл€ некоторой структуры данных, содержащей double, и такой, чтобы работал с большой (large) моделью пам€ти компьютера, то это может быть сделано таким определением:</p>
     <p><code>class MyIterator: public bidirectional_iterator Лdouble, longЫ {</code></p>
     <p><code>†// код, осуществл€ющий ++, и т.д.</code></p>
     <p><code>};</code></p>
     <p>“огда нет необходимости определ€ть iterator_category, value_type, и distance_type в MyIterator.</p>
    </section>
   </section>
   <section>
    <title>
     <p>ќперации с итераторами (Iterator operations)</p>
    </title>
    <p>“ак как только итераторы произвольного доступа обеспечивают + и - операторы, библиотека предоставл€ет две шаблонные функции advance и distance. Ёти функции используют + и - дл€ итераторов произвольного доступа (и имеют, поэтому, сложность посто€нного времени дл€ них); дл€ итераторов ввода, последовательных и двунаправленных итераторов функции используют ++, чтобы обеспечить реализацию со сложностью линейного времени. advance берет отрицательный параметр n только дл€ итераторов произвольного доступа и двунаправленных итераторов. advance увеличивает (или уменьшает дл€ отрицательного n) итераторную ссылку i на n. distance увеличивает n на число единиц, сколько требуетс€, чтобы дойти от first до last.</p>
    <p><code>template Лclass InputIterator, class DistanceЫ</code></p>
    <p><code>inline void advance(InputIterator&amp; i, Distance n);</code></p>
    <empty-line/>
    <p><code>template Лclass InputIterator, class DistanceЫ</code></p>
    <p><code>inline void distance(InputIterator first, InputIterator last, Distance&amp; n);</code></p>
    <p>distance должна быть функцией 3-х параметров, сохран€ющей результат в ссылке вместо возвращени€ результата, потому что тип рассто€ни€ не может быть выведен из встроенных итераторных типов, таких как int*.</p>
   </section>
  </section>
  <section>
   <title>
    <p>‘ункциональные объекты</p>
   </title>
   <section>
    <p>‘ункциональные объекты - это объекты, дл€ которых определЄн operator(). ќни важны дл€ эффективного использовани€ библиотеки. ¬ местах, где ожидаетс€ передача указател€ на функцию алгоритмическому шаблону, интерфейс установлен на приЄм объекта с определЄнным operator(). Ёто не только заставл€ет алгоритмические шаблоны работать с указател€ми на функции, но также позвол€ет им работать с произвольными функциональными объектами. »спользование функциональных объектов вместе с функциональными шаблонами увеличивает выразительную мощность библиотеки также, как делает результирующий код более эффективным. Ќапример, если мы хотим поэлементно сложить два вектора a и b, содержащие double, и поместить результат в a, мы можем сделать зто так:</p>
    <p><code>transform(a.begin(), a.end(), b.begin(), a.begin(), plusЛdoubleЫ());</code></p>
    <p>≈сли мы хотим отрицать каждый элемент a, мы можем сделать это так:</p>
    <p><code>transform(a.begin(), a.end(), a.begin(), negateЛdoubleЫ());</code></p>
    <p>—оответствующие функции встав€т сложение и отрицание.</p>
    <p>„тобы позволить адаптерам и другим компонентам манипулировать функциональными объектами, которые используют один или два параметра, требуетс€, чтобы они соответственно обеспечили определение типов (typedefs) argument_type и result_type дл€ функциональных объектов, которые используют один параметр, и first_argument_type, second_argument_type и result_type дл€ функциональных объектов, которые используют два параметра.</p>
   </section>
   <section>
    <title>
     <p>Ѕазовые классы (Base)</p>
    </title>
    <p>—ледующие классы предоставл€ютс€, чтобы упростить определение типов (typedefs) параметров и результата:</p>
    <p><code>template Лclass Arg, class ResultЫ</code></p>
    <p><code>struct unary_function {</code></p>
    <p><code>†typedef Arg argument_type;</code></p>
    <p><code>†typedef Result result_type;</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>template Лclass Arg1, class Arg2, class ResultЫ</code></p>
    <p><code>struct binary_function {</code></p>
    <p><code>†typedef Arg1 first_argument_type;</code></p>
    <p><code>†typedef Arg2 second_argument_type;</code></p>
    <p><code>†typedef Result result_type;</code></p>
    <p><code>};</code></p>
   </section>
   <section>
    <title>
     <p>јрифметические операции (Arithmetic operations)</p>
    </title>
    <p>Ѕиблиотека обеспечивает базовые классы функциональных объектов дл€ всех арифметических операторов €зыка.</p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct plus: binary_functionЛT, T, TЫ {</code></p>
    <p><code>†“ operator()(const T&amp; x, const T&amp; y) const {return x + y;}</code></p>
    <p><code>};</code></p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct minus: binary_functionЛT, T, TЫ {</code></p>
    <p><code>†“ operator()(const T&amp; x, const T&amp; y) const {return x - y;}</code></p>
    <p><code>};</code></p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct times: binary_functionЛT, T, TЫ {</code></p>
    <p><code>†“ operator()(const T&amp; x, const T&amp; y) const (return x * y;}</code></p>
    <p><code>};</code></p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct divides: binary_functionЛT, T, TЫ {</code></p>
    <p><code>†“ operator()(const T&amp; x, const T&amp; y) const {return x / y;}</code></p>
    <p><code>};</code></p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct modulus: binary_functionЛT, T, TЫ {</code></p>
    <p><code>†“ operator()(const T&amp; x, const T&amp; y) const {return x % y;}</code></p>
    <p><code>};</code></p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct negate: unary_functionЛT, TЫ {</code></p>
    <p><code>†“ operator()(const T&amp; x) const {return -x;}</code></p>
    <p><code>};</code></p>
   </section>
   <section>
    <title>
     <p>—равнени€ (Comparisons)</p>
    </title>
    <p>Ѕиблиотека обеспечивает базовые классы функциональных объектов дл€ всех операторов сравнени€ €зыка</p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct equal_to: binary_functionЛT, T, boolЫ {</code></p>
    <p><code>†bool operator()(const T&amp; x, const T&amp; y) const {return x†== y;}</code></p>
    <p><code>};</code></p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct not_equal_to: binary_functionЛT, T, boolЫ {</code></p>
    <p><code>†bool operator()(const T&amp; x, const T&amp; y) const {return x!= y;}</code></p>
    <p><code>};</code></p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct greater: binary_functionЛT, T, boolЫ {</code></p>
    <p><code>†bool operator()(const T&amp; x, const T&amp; y) const {return x Ы y;}</code></p>
    <p><code>};</code></p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct less: binary_functionЛT, T, boolЫ {</code></p>
    <p><code>†bool operator()(const T&amp; x, const T&amp; y) const {return x Л y;}</code></p>
    <p><code>};</code></p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct greater_equal: binary_functionЛT, T, boolЫ {</code></p>
    <p><code>†bool operator()(const T&amp; x, const T&amp; y) const {return x Ы= y;}</code></p>
    <p><code>};</code></p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct less_equal: binary_functionЛT, T, boolЫ {</code></p>
    <p><code>†bool operator()(const T&amp; x, const T&amp; y) const {return x Л= y;}</code></p>
    <p><code>};</code></p>
   </section>
   <section>
    <title>
     <p>Ћогические операции (Logical operations)</p>
    </title>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct logical_and: binary_functionЛT, T, boolЫ {</code></p>
    <p><code>†bool operator()(const T&amp; x, const T&amp; y) const {return x&amp;&amp; y;}</code></p>
    <p><code>};</code></p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct logical_or: binary_functionЛT, T, boolЫ {</code></p>
    <p><code>†bool operator()(const T&amp; x, const T&amp; y) const {return x || y;}</code></p>
    <p><code>};</code></p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>struct logical_not: unary_functionЛT, boolЫ {</code></p>
    <p><code>†bool operator()(const T&amp; x) const {return!x;}</code></p>
    <p><code>};</code></p>
   </section>
  </section>
  <section>
   <title>
    <p>–аспределители</p>
   </title>
   <section>
    <p>ќдна из общих проблем в мобильности - это способность инкапсулировать информацию относительно модели пам€ти. Ёта информаци€ включает типы указателей, тип их разности, тип размера объектов в этой модели пам€ти, также как еЄ примитивы выделени€ и освобождени€ пам€ти.</p>
    <p>STL принимаетс€ за эту проблему, обеспечива€ стандартный набор требований дл€ <emphasis>распределителей</emphasis> (<emphasis>allocators</emphasis>), €вл€ющихс€ объектами, которые инкапсулируют эту информацию. ¬се контейнеры в STL параметризованы в терминах распределителей. Ёто значительно упрощает задачу взаимодействи€ с многочисленными модел€ми пам€ти.</p>
   </section>
   <section>
    <title>
     <p>“ребовани€ распределителей (Allocator requirements)</p>
    </title>
    <p>¬ следующей таблице мы предполагаем, что X - класс распределителей дл€ объектов типа T, a - значение X, n имеет тип X::size_type, p имеет тип X::pointer, r имеет тип X::reference и s имеет тип X::const_reference.</p>
    <p>¬се операции c распределител€ми, как ожидаетс€, свод€тс€ к посто€нному времени.</p>
    <p><strong>“аблица 7. “ребовани€ распределителей</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">утверждение/примечание состо€ние до/после </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::value_type </td>
      <td align="left" valign="top">“</td>
      <td align="left" valign="top">-†</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::reference </td>
      <td align="left" valign="top">леводопустимое значение T (lvalue of T)</td>
      <td align="left" valign="top">-†</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::const_reference </td>
      <td align="left" valign="top">const lvalue of T</td>
      <td align="left" valign="top">-†</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::pointer </td>
      <td align="left" valign="top">указатель на тип T </td>
      <td align="left" valign="top">результатом operator* дл€ значений X::pointer €вл€етс€ reference. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::const_pointer </td>
      <td align="left" valign="top">указатель на тип const T </td>
      <td align="left" valign="top">результат operator* дл€ значений X::const_pointer &#8213; const_reference; это - тот же самый тип указател€, как X::pointer, в частности, sizeof(X::const_pointer)==sizeof(X::pointer). </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X:: size_type </td>
      <td align="left" valign="top">беззнаковый целочисленный тип </td>
      <td align="left" valign="top">тип, который может представл€ть размер самого большого объекта в модели пам€ти. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::difference_type </td>
      <td align="left" valign="top">знаковый целочисленный тип </td>
      <td align="left" valign="top">тип, который может представл€ть разность между двум€ любыми указател€ми в модели пам€ти. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X a;</td>
      <td align="left" valign="top">-†</td>
      <td align="left" valign="top">примечание: предполагаетс€ деструктор. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.address(r) </td>
      <td align="left" valign="top">указатель </td>
      <td align="left" valign="top">*(a.address(r))==r. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.const_address(s) </td>
      <td align="left" valign="top">const_pointer </td>
      <td align="left" valign="top">*(a.address(s))==s. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.allocate(n) </td>
      <td align="left" valign="top">X::pointer </td>
      <td align="left" valign="top">пам€ть распредел€етс€ дл€ n объектов типа T, но объекты не создаютс€. allocate может вызывать соответствующее исключение. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.deallocate(p) </td>
      <td align="left" valign="top">результат не используетс€ </td>
      <td align="left" valign="top">все объекты в области, указываемой p, должны быть уничтожены до этого запроса.</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">construct(p, a) </td>
      <td align="left" valign="top">void </td>
      <td align="left" valign="top">после: *p==a. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">destroy(p) </td>
      <td align="left" valign="top">void </td>
      <td align="left" valign="top">значение, указываемое p, уничтожаетс€. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.init_page_size() </td>
      <td align="left" valign="top">X::size_type </td>
      <td align="left" valign="top">возвращЄнное значение - оптимальное значение дл€ начального размера буфера данного типа. ѕредполагаетс€, что если k возвращено функцией init_page_size, t - врем€ конструировани€ дл€ T, и u - врем€, которое требуетс€ дл€ выполнени€ allocate(k), тогда k*t будет намного больше, чем u. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.max_size() </td>
      <td align="left" valign="top">X::size_type </td>
      <td align="left" valign="top">наибольшее положительное значение X::difference_type </td>
     </tr>
    </table>
    <p>pointer относитс€ к категории модифицируемых итераторов произвольного доступа, ссылающихс€ на T. const_pointer относитс€ к категории посто€нных итераторов произвольного доступа, ссылающихс€ на T. »меетс€ определЄнное преобразование из pointer в const_pointer.</p>
    <p>ƒл€ любого шаблона распределител€ Alloc имеетс€ определение дл€ типа void. ” AllocЛvoidЫ определены только конструктор, деструктор и AllocЛvoidЫ::pointer. ѕреобразовани€ определены из любого AllocЛTЫ::pointer в AllocЛvoidЫ::pointer и обратно, так что дл€ любого p будет p†== AllocЛTЫ::pointer(AllocЛvoidЫ::pointer(p)).</p>
   </section>
   <section>
    <title>
     <p>–аспределитель по умолчанию (The default allocator)</p>
    </title>
    <p><code>template Лclass TЫ</code></p>
    <p><code>class allocator {</code></p>
    <p><code>public:</code></p>
    <p><code>†typedef T* pointer;</code></p>
    <p><code>†typedef const T* const_pointer;</code></p>
    <p><code>†typedef T&amp; reference;</code></p>
    <p><code>†typedef const T&amp; const_reference;</code></p>
    <p><code>†typedef T value_type;</code></p>
    <p><code>†typedef size_t size_type;</code></p>
    <p><code>†typedef ptrdiff_t difference_type;</code></p>
    <p><code>†allocator();</code></p>
    <p><code>†~allocator();</code></p>
    <p><code>†pointer address(reference x);</code></p>
    <p><code>†const_pointer const_address(const_reference x);</code></p>
    <p><code>†pointer allocate(size_type n);</code></p>
    <p><code>†void deallocate(pointer p);</code></p>
    <p><code>†size_type init_page_size();</code></p>
    <p><code>†size_type max_size();</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>class allocatorЛvoidЫ {</code></p>
    <p><code>public:</code></p>
    <p><code>†typedef void* pointer;</code></p>
    <p><code>†allocator();</code></p>
    <p><code>†~allocator();</code></p>
    <p><code>};</code></p>
    <p>ѕредполагаетс€, что в дополнение к allocator поставщики библиотеки обеспечивают распределители дл€ всех моделей пам€ти.</p>
   </section>
  </section>
  <section>
   <title>
    <p> онтейнеры</p>
   </title>
   <section>
    <p> онтейнеры - это объекты, которые содержат другие объекты. ќни управл€ют размещением в пам€ти и свобождением этих объектов через конструкторы, деструкторы, операции вставки и удалени€.</p>
    <p>¬ следующей таблице мы полагаем, что X - контейнерный класс, содержащий объекты типа T, a и b - значени€ X, u - идентификатор, r - значение X&amp;.</p>
    <p><strong>“аблица 8. “ребовани€ контейнеров</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнени€ </th>
      <th align="left" valign="top">утверждение/примечание состо€ние до/после </th>
      <th align="left" valign="top">сложность </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::value_type </td>
      <td align="left" valign="top">“</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-†</td>
      <td align="left" valign="top">врем€ компил€ции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::reference</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">врем€ компил€ции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::const_reference</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">врем€ компил€ции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::pointer </td>
      <td align="left" valign="top">тип указател€, указывающий на X::reference</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">указатель на T в модели пам€ти, используемой контейнером </td>
      <td align="left" valign="top">врем€ компил€ции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::iterator </td>
      <td align="left" valign="top">тип итератора, указывающий на X::reference</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">итератор любой категории, кроме итератора вывода. </td>
      <td align="left" valign="top">врем€ компил€ции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::const_iterator </td>
      <td align="left" valign="top">тип итератора, указывающий на X::<emphasis>const_reference </emphasis></td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">посто€нный итератор любой категории, кроме итератора вывода. </td>
      <td align="left" valign="top">врем€ компил€ции</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::difference<emphasis>_</emphasis>type</td>
      <td align="left" valign="top">знаковый целочисленный тип</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">идентичен типу рассто€ни€ X::iterator и X::const_iterator </td>
      <td align="left" valign="top">врем€ компил€ции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::size_type </td>
      <td align="left" valign="top">беззнаковый целочисленный тип</td>
      <td align="left" valign="top">-†</td>
      <td align="left" valign="top">size_type может представл€ть любое неотрицательное значение difference_type </td>
      <td align="left" valign="top">врем€ компил€ции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X u;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-†</td>
      <td align="left" valign="top">после: u.size()==0. </td>
      <td align="left" valign="top">посто€нна€</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X()</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">X().size()==0. </td>
      <td align="left" valign="top">посто€нна€</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X(a)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">a==X(a). </td>
      <td align="left" valign="top">линейна€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X u(a); X u==a;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">X u; u = a; </td>
      <td align="left" valign="top">после: u==a. </td>
      <td align="left" valign="top">линейна€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">(&amp;a)-Ы~X() </td>
      <td align="left" valign="top">результат не используетс€</td>
      <td align="left" valign="top">-†</td>
      <td align="left" valign="top">после: a.size()==0. примечание: деструктор примен€етс€ к каждому элементу a, и вс€ пам€ть возвращаетс€. </td>
      <td align="left" valign="top">линейна€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.begin() </td>
      <td align="left" valign="top">iterator; const_iterator дл€ посто€нного a</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">посто€нна€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.end() </td>
      <td align="left" valign="top">iterator; const_iterator дл€ посто€нного a</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">посто€нна€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a==b </td>
      <td align="left" valign="top">обратимый в bool </td>
      <td align="left" valign="top">a.size()==b.size() &amp;&amp; equal(a.begin(), a.end(), b.begin())</td>
      <td align="left" valign="top"><emphasis>==</emphasis>†- это отношение эквивалентности. примечание: equal определ€етс€ в разделе алгоритмов. </td>
      <td align="left" valign="top">линейна€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a!= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a==b)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">линейна€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r = a </td>
      <td align="left" valign="top">X&amp; </td>
      <td align="left" valign="top">if(&amp;r!=&amp;a){ (&amp;r)-ЫX::~X(); new(&amp;r)X(a); return r;}</td>
      <td align="left" valign="top">после: r==a.</td>
      <td align="left" valign="top">линейнa€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.size() </td>
      <td align="left" valign="top">size_type </td>
      <td align="left" valign="top">size_type n = 0; distance(a.begin(), a.end(), n); return n;</td>
      <td align="left" valign="top"><emphasis>-</emphasis></td>
      <td align="left" valign="top">посто€нна€</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.max_size() </td>
      <td align="left" valign="top">size_type</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">size() самого большого возможного контейнера. </td>
      <td align="left" valign="top">посто€нна€</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.empty() </td>
      <td align="left" valign="top">обратимый в bool </td>
      <td align="left" valign="top">a.size()==0</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">посто€нна€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a Л b </td>
      <td align="left" valign="top">обратимый в bool </td>
      <td align="left" valign="top">lexicographical_compare(a.begin(), a.end(), b.begin(), b.end())</td>
      <td align="left" valign="top">до: Л определЄн дл€ значений T. Л - отношение полного упор€дочени€. lexicographical_compare определ€етс€ в разделе алгоритмов. </td>
      <td align="left" valign="top">линейна€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a Ы b </td>
      <td align="left" valign="top">обратимый в bool </td>
      <td align="left" valign="top">b Л a</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">линейнa€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a Л= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a Ы b)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">линейна€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a Ы= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a Л b)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">линейна€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.swap(b) </td>
      <td align="left" valign="top">void </td>
      <td align="left" valign="top">swap(a, b)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">посто€нна€ </td>
     </tr>
    </table>
    <p>‘ункци€-член size() возвращает число элементов в контейнере. ≈Є семантика определ€етс€ правилами конструкторов, вставок и удалений.</p>
    <p>begin() возвращает итератор, ссылающийс€ на первый элемент в контейнере. end() возвращает итератор, который €вл€етс€ законечным.</p>
    <p>≈сли тип итератора контейнера принадлежит к категории двунаправленных итераторов или итераторов произвольного доступа, то контейнер называетс€ reversible (обратимым) и удовлетвор€ет следующим дополнительным требовани€м:</p>
    <p><strong>“аблица 9. “ребовани€ обратимых контейнеров (в дополнение к контейнерам)</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнени€ </th>
      <th align="left" valign="top">сложность </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::reverse_iterator </td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">reverse_iteratorЛiterator, value_type, reference, difference_typeЫ дл€ итератора произвольного доступа. reverse_bidirectional_iteratorЛiterator, value_type, reference, difference_typeЫ дл€ двунаправленного итератора </td>
      <td align="left" valign="top">врем€ компил€ции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::const_reverse_iterator </td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">reverse_iteratorЛconst_iterator, value_type, const_reference, difference_typeЫ дл€ итератора произвольного доступа. reverse_bidirectional_iteratorЛconst_iterator, value_type, const_reference, difference_typeЫ дл€ двунаправленного итератора. </td>
      <td align="left" valign="top">врем€ компил€ции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.rbegin() </td>
      <td align="left" valign="top">reverse_iterator; const_reverse_iterator дл€ посто€нного a </td>
      <td align="left" valign="top">reverse_iterator(end()) </td>
      <td align="left" valign="top">посто€нна€ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.rend() </td>
      <td align="left" valign="top">reverse_iterator; const_reverse_iterator дл€ посто€нного a </td>
      <td align="left" valign="top">reverse_iterator(begin()) </td>
      <td align="left" valign="top">посто€нна€ </td>
     </tr>
    </table>
   </section>
   <section>
    <title>
     <p>ѕоследовательности (Sequences)</p>
    </title>
    <section>
     <p>ѕоследовательность - это вид контейнера, который организует конечное множество объектов одного и того же типа в строгом линейном пор€дке. Ѕиблиотека обеспечивает три основных вида последовательных контейнеров: vector (вектор), list (список) и deque (двусторонн€€ очередь). ќна также предоставл€ет контейнерные адаптеры, которые облегчают создание абстрактных типов данных, таких как стеки или очереди, из основных видов последовательностей (или из других видов последовательностей, которые пользователь может сам определить).</p>
     <p>¬ следующих двух таблицах X - последовательный класс, a - значение X, i и j удовлетвор€ют требовани€м итераторов ввода, [i, j) - допустимый диапазон, n - значение X::size_type, p - допустимый итератор дл€ a, q - разыменовываемый итератор дл€ a, [q1, q2) - допустимый диапазон в a, t - значение X::value_type.</p>
     <p>—ложности выражений завис€т от последовательностей.</p>
     <p><strong>“аблица 10. “ребовани€ последовательностей (в дополнение к контейнерам)</strong> </p>
     <empty-line/>
     <table>
      <tr align="left">
       <th align="left" valign="top">выражение </th>
       <th align="left" valign="top">возвращаемый тип </th>
       <th align="left" valign="top">утверждение/примечание состо€ние до/после </th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X(n, t) X a(n, t); </td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">после: size()==n. создаЄт последовательность с n копи€ми t. </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X(i, j) X a(i, j); </td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">после: size()==рассто€нию между i и j. создаЄт последовательность, равную диапазону [i, j). </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.insert(p, t) </td>
       <td align="left" valign="top">iterator </td>
       <td align="left" valign="top">вставл€ет копию t перед p. возвращаемое значение указывает на вставленную копию.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.insert(p, n, t) </td>
       <td align="left" valign="top">результат не используетс€ </td>
       <td align="left" valign="top">вставл€ет n копий t перед p. </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.insert(p, i, j) </td>
       <td align="left" valign="top">результат не используетс€ </td>
       <td align="left" valign="top">вставл€ет копии элементов из диапазона [i, j) перед p. </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.erase(q) </td>
       <td align="left" valign="top">результат не используетс€ </td>
       <td align="left" valign="top">удал€ет элемент, указываемый q. </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.erase(ql, q2) </td>
       <td align="left" valign="top">результат не используетс€ </td>
       <td align="left" valign="top">удал€ет элементы в диапазоне [ql, q2).†</td>
      </tr>
     </table>
     <p>vector (вектор), list (список) и deque (двусторонн€€ очередь) выдвигают программисту различные предложени€ сложности и должны использоватьс€ соответственно. vectоr - тип последовательности, котора€ используетс€ по умолчанию. list нужно использовать, когда имеютс€ частые вставки и удалени€ из середины последовательности, deque - структура данных дл€ выбора, когда большинство вставок и удалений происходит в начале или в конце последовательности.</p>
     <p>“ипы iterator и const_iterator дл€ последовательностей должны быть, по крайней мере, из категории последовательных итераторов.</p>
     <p><strong>“аблица 11. Ќеоб€зательные операции последовательностей</strong> </p>
     <table>
      <tr align="left">
       <th align="left" valign="top">выражение </th>
       <th align="left" valign="top">возвращаемый тип </th>
       <th align="left" valign="top">семантика исполнени€ </th>
       <th align="left" valign="top">контейнер </th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.front() </td>
       <td align="left" valign="top">reference; const_reference дл€ посто€нного a </td>
       <td align="left" valign="top">*a.begin() </td>
       <td align="left" valign="top">vector, list, deque </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.back() </td>
       <td align="left" valign="top">reference; const_reference дл€ посто€нного a </td>
       <td align="left" valign="top">*a.(--end()) </td>
       <td align="left" valign="top">vector, list, deque </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.push_front(t) </td>
       <td align="left" valign="top">void </td>
       <td align="left" valign="top">a.insert(a.begin(), t) </td>
       <td align="left" valign="top">list, deque </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.push_back(t) </td>
       <td align="left" valign="top">void </td>
       <td align="left" valign="top">a.insert(a.end(), t) </td>
       <td align="left" valign="top">vector, list, deque</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.pop_front() </td>
       <td align="left" valign="top">void </td>
       <td align="left" valign="top">a.erase(a.begin()) </td>
       <td align="left" valign="top">list, deque </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.pop_back() </td>
       <td align="left" valign="top">void</td>
       <td align="left" valign="top">a.erase(--a.end()) </td>
       <td align="left" valign="top">vector, list, deque </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a[n] </td>
       <td align="left" valign="top">reference; const_reference дл€ посто€нного a </td>
       <td align="left" valign="top">*(a.begin() + n) </td>
       <td align="left" valign="top">vector, deque </td>
      </tr>
     </table>
     <p>¬се операции в расположенной выше таблице обеспечиваютс€ только дл€ контейнеров, дл€ которых они занимают посто€нное врем€.</p>
    </section>
    <section>
     <title>
      <p>¬ектор (Vector)</p>
     </title>
     <p>vector - вид последовательности, котора€ поддерживает итераторы произвольного доступа.  роме того, он поддерживает операции вставки и удалени€ в конце с посто€нным (амортизированным) временем; вставка и удаление в середине занимают линейное врем€. ”правление пам€тью обрабатываетс€ автоматически, хот€ дл€ улучшени€ эффективности можно давать подсказки.</p>
     <p><code>template Лclass T, template Лclass UЫ class Allocator = allocatorЫ</code></p>
     <p><code>class vector {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code>†// определени€ типов (typedefs):</code></p>
     <p><code>†typedef iterator;</code></p>
     <p><code>†typedef const_iterator;</code></p>
     <p><code>†typedef AllocatorЛTЫ::pointer pointer;</code></p>
     <p><code>†typedef AllocatorЛTЫ::reference reference;</code></p>
     <p><code>†typedef AllocatorЛTЫ::const_reference const_reference;</code></p>
     <p><code>†typedef size_type;</code></p>
     <p><code>†typedef difference_type;</code></p>
     <p><code>†typedef T value_type;</code></p>
     <p><code>†typedef reverse_iterator;</code></p>
     <p><code>†typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code>†// размещение/освобождение (allocation/deallocation):</code></p>
     <p><code>†vector();</code></p>
     <p><code>†vector(size_type n, const T&amp; value = T());</code></p>
     <p><code>†vector(const vectorЛT, AllocatorЫ&amp; x);</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†vector(InputIterator first, InputIterator last);</code></p>
     <p><code>†~vector();</code></p>
     <p><code>†vectorЛT, AllocatorЫ&amp; operator=(const vectorЛT, AllocatorЫ&amp; x);</code></p>
     <p><code>†void reserve(size_type n);</code></p>
     <p><code>†void swap(vectorЛT, AllocatorЫ&amp; x);</code></p>
     <empty-line/>
     <p><code>†// средства доступа (accessors):</code></p>
     <p><code>†iterator begin();</code></p>
     <p><code>†const_iterator begin() const;</code></p>
     <p><code>†iterator end();</code></p>
     <p><code>†const_iterator end() const;</code></p>
     <p><code>†reverse_iterator rbegin();</code></p>
     <p><code>†const_reverse_iterator rbegin();</code></p>
     <p><code>†reverse_iterator rend();</code></p>
     <p><code>†const_reverse_iterator rend();</code></p>
     <p><code>†size_type size() const;</code></p>
     <p><code>†size_type max_size() const;</code></p>
     <p><code>†size_type capacity() const;</code></p>
     <p><code>†bool empty() const;</code></p>
     <p><code>†reference operator[](size_type n);</code></p>
     <p><code>†const_reference operator[](size_type n) const;</code></p>
     <p><code>†reference front();</code></p>
     <p><code>†const_reference front() const;</code></p>
     <p><code>†reference back();</code></p>
     <p><code>†const_reference back() const;</code></p>
     <empty-line/>
     <p><code>†// вставка/стирание (insert/irase):</code></p>
     <p><code>†void push_back(const T&amp; x);</code></p>
     <p><code>†iterator insert(iterator position, const T&amp; x = T());</code></p>
     <p><code>†void insert(iterator position, size_type n, const T&amp; x);</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†void insert(iterator position, InputIterator first, InputIterator last);</code></p>
     <p><code>†void pop_back();</code></p>
     <p><code>†void erase(iterator position);</code></p>
     <p><code>†void erase(iterator first, iterator last);</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass T, class AllocatorЫ</code></p>
     <p><code>bool operator==(const vectorЛT, AllocatorЫ&amp; x, const vectorЛT, AllocatorЫ&amp; y);</code></p>
     <empty-line/>
     <p><code>template Лclass T, class AllocatorЫ</code></p>
     <p><code>bool operatorЛ(const vectorЛT, AllocatorЫ&amp; x, const vectorЛT, AllocatorЫ&amp; y);</code></p>
     <p>iterator - это итератор произвольного доступа, ссылающийс€ на T. “очный тип зависит от исполнени€ и определ€етс€ в Allocator.</p>
     <p>const_iterator - это посто€нный итератор произвольного доступа, ссылающийс€ на const T. “очный тип зависит от исполнени€ и определ€етс€ в Allocator. √арантируетс€, что имеетс€ конструктор дл€ const_iterator из iterator.</p>
     <p>size_type - беззнаковый целочисленный тип. “очный тип зависит от исполнени€ и определ€етс€ в Allocator.</p>
     <p>difference_type - знаковый целочисленный тип. “очный тип зависит от исполнени€ и определ€етс€ в Allocator.</p>
     <p> онструктор template Лclass InputIteratorЫ vector(InputIterator first, InputIterator last) делает только N вызовов конструктора копировани€ T (где N - рассто€ние между first и last) и никаких перераспределений, если итераторы first и last относ€тс€ к последовательной, двунаправленной или произвольного доступа категори€м. ќн делает, самое большее, 2N вызовов конструктора копировани€ T и logN перераспределений, если они - только итераторы ввода, так как невозможно определить рассто€ние между first и last и затем сделать копирование.</p>
     <p>‘ункци€-член capasity (Ємкость) возвращает размер распределЄнной пам€ти в векторе. ‘ункци€-член reserve - директива, котора€ сообщает vector (вектору) запланированноe изменение размера, так чтобы он мог соответственно управл€ть распределением пам€ти. Ёто не измен€ет размер последовательности и занимает, самое большее, линейное врем€ от размера последовательности. ѕерераспределение в этом случае происходит тогда и только тогда, когда текуща€ Ємкость меньше, чем параметр reserve. ѕосле reserve Ємкость (capasity) больше или равна параметру reserve, если происходит перераспределение; а иначе равна предыдущему значению capasity. ѕерераспределение делает недействительными все ссылки, указатели и итераторы, ссылающиес€ на элементы в последовательности. √арантируетс€, что нет никакого перераспределени€ во врем€ вставок, которые происход€т после того, как reserve выполн€етс€, до времени, когда размер вектора достигает размера, указанного reserve.</p>
     <p>insert (вставка) вызывает перераспределение, если новый размер больше, чем стара€ Ємкость. ≈сли никакого перераспределени€ не происходит, все итераторы и ссылки перед точкой вставки остаютс€ справедливыми. ¬ставка единственного элемента в вектор линейна относительно рассто€ни€ от точки вставки до конца вектора. јмортизированна€ сложность во врем€ жизни вектора, вставл€ющего единственный элемент в свой конец, посто€нна. ¬ставка множественных элементов в вектор с единственным вызовом вставл€ющей функции-члена линейна относительно суммы числа элементов плюс рассто€ние до конца вектора. ƒругими словами, намного быстрее вставить много элементов в середину вектора сразу, чем делать вставку по одному элементу. Ўаблонна€ вставл€юща€ функци€-член предраспредел€ет достаточно пам€ти дл€ вставки, если итераторы first и last относ€тс€ к последовательной, двунаправленной или произвольного доступа категори€м. »наче функци€ вставл€ет элементы один за другим и не должна использоватьс€ дл€ вставки в середину векторов.</p>
     <p>erase (стирание) делает недействительными все итераторы и ссылки после пункта стирани€. ƒеструктор T вызываетс€ столько раз, каково число стЄртых элементов, а оператор присваивани€ T вызываетс€ столько раз, каково число элементов в векторе после стЄртых элементов.</p>
     <p>„тобы оптимизировать распределение места, даЄтс€ определение дл€ bool.</p>
     <p><code>class vectorЛbool, allocatorЫ {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code>†// битова€ ссылка (bit reference):</code></p>
     <p><code>†class reference {</code></p>
     <p><code>†public:</code></p>
     <p><code>† ~reference();</code></p>
     <p><code>† operator bool() const;</code></p>
     <p><code>† reference&amp; operator=(const bool x);</code></p>
     <p><code>† void flip(); // инвертирует бит (flips the bit)</code></p>
     <p><code>†};</code></p>
     <empty-line/>
     <p><code>†// определени€ типов (typedefs):</code></p>
     <p><code>†typedef bool const_reference;</code></p>
     <p><code>†typedef iterator;</code></p>
     <p><code>†typedef const_iterator;</code></p>
     <p><code>†typedef size_t size_type;</code></p>
     <p><code>†typedef ptrdiff_t difference_type;</code></p>
     <p><code>†typedef bool value_type;</code></p>
     <p><code>†typedef reverse_iterator;</code></p>
     <p><code>†typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code>†// размещение/освобождение (allocation/deallocation):</code></p>
     <p><code>†vector();</code></p>
     <p><code>†vector(size_type n, const bool&amp; value = bool());</code></p>
     <p><code>†vector(const vectorЛbool, allocatorЫ&amp; x);</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†vector(InputIterator first, InputIterator last);</code></p>
     <p><code>†~vector();</code></p>
     <p><code>†vectorЛbool, allocatorЫ&amp; operator=(const vectorЛbool, allocatorЫ&amp; x);</code></p>
     <p><code>†void reserve(size_type n);</code></p>
     <p><code>†void swap(vectorЛbool, allocatorЫ&amp; x);</code></p>
     <empty-line/>
     <p><code>†// средства доступа (accessors):</code></p>
     <p><code>†iterator begin();</code></p>
     <p><code>†const_iterator begin() const;</code></p>
     <p><code>†iterator end();</code></p>
     <p><code>†const_iterator end() const;</code></p>
     <p><code>†reverse_iterator rbegin();</code></p>
     <p><code>†const_reverse_iterator rbegin();</code></p>
     <p><code>†reverse_iterator rend();</code></p>
     <p><code>†const_reverse_iterator rend();</code></p>
     <p><code>†size_type size() const;</code></p>
     <p><code>†size_type max_size() const;</code></p>
     <p><code>†size_type capacity() const;</code></p>
     <p><code>†bool empty() const;</code></p>
     <p><code>†reference operator[](size_type n);</code></p>
     <p><code>†const_reference operator[](size_type n) const;</code></p>
     <p><code>†reference front();</code></p>
     <p><code>†const_reference front() const;</code></p>
     <p><code>†reference back();</code></p>
     <p><code>†const_reference back() const;</code></p>
     <empty-line/>
     <p><code>†// вставка/стирание (insert/irase):</code></p>
     <p><code>†void push_back(const bool&amp; x);</code></p>
     <p><code>†iterator insert(iterator position, const bool&amp; x = bool());</code></p>
     <p><code>†void insert(iterator position, size_type n, const bool&amp; x);</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†void insert(iterator position, InputIterator first, InputIterator last);</code></p>
     <p><code>†void pop_back();</code></p>
     <p><code>†void erase(iterator position);</code></p>
     <p><code>†void erase(iterator first, iterator last);</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>void swap(vectorЛbool, allocatorЫ::reference x, vectorЛbool, allocatorЫ::reference y);</code></p>
     <p><code>bool operator==(const vectorЛbool, allocatorЫ&amp; x, const vectorЛbool, allocatorЫ&amp; y);</code></p>
     <p><code>bool operatorЛ(const vectorЛbool, allocatorЫ&amp; x, const vectorЛbool, allocatorЫ&amp; y);</code></p>
     <p>reference - класс, который имитирует поведение ссылок отдельного бита в vectorЛboolЫ.</p>
     <p>ќжидаетс€, что каждое исполнение обеспечит определение vectorЛboolЫ дл€ всех поддерживаемых моделей пам€ти.</p>
     <cite>
      <p>—ейчас невозможно шаблонизировать определение. “о есть мы не можем написать: </p>
      <p><code>template Лtemplate Лclass UЫ class Allocator†= allocatorЫ </code></p>
      <p><code>class vectorЛbool, AllocatorЫ {/*Е */}; </code></p>
      <p>ѕоэтому обеспечиваетс€ только vectorЛbool, AllocatorЫ. </p>
     </cite>
    </section>
    <section>
     <title>
      <p>—писок (List)</p>
     </title>
     <p>list - вид последовательности, котора€ поддерживает двунаправленные итераторы и позвол€ет операции вставки и стирани€ с посто€нным временем в любом месте последовательности, с управлением пам€тью, обрабатываемым автоматически. ¬ отличие от векторов и двусторонних очередей, быстрый произвольный доступ к элементам списка не поддерживаетс€, но многим алгоритмам, во вс€ком случае, только и нужен последовательный доступ.</p>
     <p><code>template Лclass T, template Лclass UЫ class Allocator = allocatorЫ</code></p>
     <p><code>class list {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code>†// определени€ типов:</code></p>
     <p><code>†typedef iterator;</code></p>
     <p><code>†typedef const_iterator;</code></p>
     <p><code>†typedef AllocatorЛTЫ::pointer pointer;</code></p>
     <p><code>†typedef AllocatorЛTЫ::reference reference;</code></p>
     <p><code>†typedef AllocatorЛTЫ::const_reference const_reference;</code></p>
     <p><code>†typedef size_type;</code></p>
     <p><code>†typedef difference_type;</code></p>
     <p><code>†typedef “ value_type;</code></p>
     <p><code>†typedef reverse_iterator;</code></p>
     <p><code>†typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code>†// размещение/удаление:</code></p>
     <p><code>†list()</code></p>
     <p><code>†list(size_type n, const T&amp; value = T());</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†list(InputIterator first, InputIterator last);</code></p>
     <p><code>†list(const listЛT, AllocatorЫ&amp; x);</code></p>
     <p><code>†~list();</code></p>
     <p><code>†listЛT, AllocatorЫ&amp; operator=(const listЛT,AllocatorЫ&amp; x);</code></p>
     <p><code>†void swap(listЛT, Allocator&amp; x);</code></p>
     <empty-line/>
     <p><code>†// средства доступа:</code></p>
     <p><code>†iterator begin();</code></p>
     <p><code>†const_iterator begin() const;</code></p>
     <p><code>†iterator end();</code></p>
     <p><code>†const_iterator end() const;</code></p>
     <p><code>†reverse_iterator rbegin();</code></p>
     <p><code>†const_reverse_iterator rbegin();</code></p>
     <p><code>†reverse_iterator rend();</code></p>
     <p><code>†const_reverse_iterator rend();</code></p>
     <p><code>†bool empty() const;</code></p>
     <p><code>†size_type size() const;</code></p>
     <p><code>†size_type max_size() const;</code></p>
     <p><code>†reference front();</code></p>
     <p><code>†const_reference front() const;</code></p>
     <p><code>†reference back();</code></p>
     <p><code>†const_reference back() const;</code></p>
     <empty-line/>
     <p><code>†// вставка/стирание:</code></p>
     <p><code>†void push_front(const T&amp; x);</code></p>
     <p><code>†void push_back(const T&amp; x);</code></p>
     <p><code>†iterator insert(iterator position, const T&amp; x = T());</code></p>
     <p><code>†void insert(iterator position, size_type n, const T&amp; x);</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†void insert(iterator position, InputIterator first, InputIterator last);</code></p>
     <p><code>†void pop_front();</code></p>
     <p><code>†void pop_back();</code></p>
     <p><code>†void erase(iterator position);</code></p>
     <p><code>†void erase(iterator first, iterator last);</code></p>
     <empty-line/>
     <p><code>†// специальные модифицирующие операции cо списком:</code></p>
     <p><code>†void splice(iterator position, listЛT, AllocatorЫ&amp; x);</code></p>
     <p><code>†void splice(iterator position, listЛT, AllocatorЫ&amp; x, iterator i);</code></p>
     <p><code>†void splice(iterator position, listЛT, AllocatorЫ&amp; x, iterator first, iterator last);</code></p>
     <p><code>†void remove(const T&amp; value);</code></p>
     <p><code>†template Лclass PredicateЫ </code></p>
     <p><code>†void remove_if(Predicate pred);</code></p>
     <p><code>†void unique();</code></p>
     <p><code>†template Лclass BinaryPredicateЫ </code></p>
     <p><code>†void unique(BinaryPredicate binary_pred);</code></p>
     <p><code>†void merge(listЛT, AllocatorЫ&amp; x);</code></p>
     <p><code>†template Лclass CompareЫ</code></p>
     <p><code>†void merge(listЛT,AllocatorЫ&amp; x, Compare comp);</code></p>
     <p><code>†void reverse();</code></p>
     <p><code>†void sort();</code></p>
     <p><code>†template Лclass CompareЫ void sort(Compare comp);</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass T, class AllocatorЫ</code></p>
     <p><code>bool operator==(const listЛT, AllocatorЫ&amp; x, const listЛT, AllocatorЫ&amp; y);</code></p>
     <empty-line/>
     <p><code>template Лclass T, class AllocatorЫ</code></p>
     <p><code>bool operatorЛ(const listЛT, AllocatorЫ&amp; x, const listЛT, AllocatorЫ&amp; y);</code></p>
     <p>iterator - двунаправленный итератор, ссылающийс€ на T. “очный тип зависит от исполнени€ и определ€етс€ в Allocator.</p>
     <p>const_iterator - посто€нный двунаправленный итератор, ссылающийс€ на const T. “очный тип зависит от исполнени€ и определ€етс€ в Allocator. √арантируетс€, что имеетс€ конструктор дл€ const_iterator из iterator.</p>
     <p>size_type - беззнаковый целочисленный тип. “очный тип зависит от исполнени€ и определ€етс€ в Allocator.</p>
     <p>difference_type - знаковый целочисленный тип. “очный тип зависит от исполнени€ и определ€етс€ в Allocator.</p>
     <p>insert не вли€ет на действительность итераторов и ссылок. ¬ставка единственного элемента в список занимает посто€нное врем€, и ровно один раз вызываетс€ конструктор копировани€ T. ¬ставка множественных элементов в список зависит линейно от числа вставленных элементов, а число вызовов конструктора копировани€ T точно равно числу вставленных элементов.</p>
     <p>erase делает недействительными только итераторы и ссылки дл€ стЄртых элементов. —тирание единственного элемента - операци€ посто€нного времени с единственным вызовом деструктора T. —тирание диапазона в списке занимает линейное врем€ от размера диапазона, а число вызовов деструктора типа T точно равно размеру диапазона.</p>
     <p>“ак как списки позвол€ют быструю вставку и стирание в середине списка, то некоторые операции определ€ютс€ специально дл€ них:</p>
     <p>list обеспечивает три операции стыковки, которые разрушительно перемещают элементы из одного списка в другой:</p>
     <p>void splice(iterator position, listЛT, AllocatorЫ&amp; x) вставл€ет содержимое x перед position, и x становитс€ пустым. “ребуетс€ посто€нное врем€. –езультат не определЄн, если &amp;x==this.</p>
     <p>void splice(iterator position, listЛT, AllocatorЫ&amp; x, iterator i) вставл€ет элемент, указываемый i, из списка x перед position и удал€ет элемент из x. “ребуетс€ посто€нное врем€. i - допустимый разыменовываемый итератор списка x. –езультат не измен€етс€, если position==i или position==++i.</p>
     <p>void splice(iterator position, listЛT, AllocatorЫ&amp; x, iterator first, iterator last) вставл€ет элементы из диапазона [first, last) перед position и удал€ет элементы из x. “ребуетс€ посто€нное врем€, если &amp;x==this; иначе требуетс€ линейное врем€. [first, last) - допустимый диапазон в x. –езультат не определЄн, если position - итератор в диапазоне [first, last).</p>
     <p>remove стирает все элементы в списке, указанном итератором списка i, дл€ которого выполн€ютс€ следующие услови€: *i==value, pred(*i)==true. remove устойчиво, то есть относительный пор€док элементов, которые не удалены, тот же самый, как их относительный пор€док в первоначальном списке. —оответствующий предикат примен€етс€ точно size() раз.</p>
     <p>unique стирает все, кроме первого элемента, из каждой последовательной группы равных элементов в списке. —оответствующий бинарный предикат примен€етс€ точно size() - 1 раз.</p>
     <p>merge сливает список аргумента со списком (предполагаетс€, что оба сортированы). —ли€ние устойчиво, то есть дл€ равных элементов в двух списках элементы списка всегда предшествуют элементам из списка аргумента. x пуст после сли€ни€. ¬ыполн€етс€, самое большее, size() + x.size() - 1 сравнений.</p>
     <p>reverse переставл€ет элементы в списке в обратном пор€дке. ќпераци€ линейного времени.</p>
     <p>sort сортирует список согласно operatorЛ или сравнивающему функциональному объекту. ќна устойчива, то есть относительный пор€док равных элементов сохран€етс€. ¬ыполн€етс€ приблизительно NlogN сравнений, где N равно size().</p>
    </section>
    <section>
     <title>
      <p>ƒвусторонн€€ очередь (Deque)</p>
     </title>
     <p>deque - вид последовательности, котора€, подобно вектору, поддерживает итераторы произвольного доступа.  роме того она поддерживает операции вставки и стирани€ в начале или в конце за посто€нное врем€; вставка и стирание в середине занимают линейное врем€.  ак с векторами, управление пам€тью обрабатываетс€ автоматически.</p>
     <p><code>template Лclass T, template Лclass UЫ class Allocator = allocatorЫ</code></p>
     <p><code>class deque {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code>†// typedefs:</code></p>
     <p><code>†typedef iterator;</code></p>
     <p><code>†typedef const_iterator;</code></p>
     <p><code>†typedef AllocatorЛTЫ::pointer pointer;</code></p>
     <p><code>†typedef AllocatorЛTЫ::reference reference;</code></p>
     <p><code>†typedef AllocatorЛTЫ::const_reference const_reference;</code></p>
     <p><code>†typedef size_type;</code></p>
     <p><code>†typedef difference_type;</code></p>
     <p><code>†typedef “ value_type;</code></p>
     <p><code>†typedef reverse_iterator;</code></p>
     <p><code>†typedef const_revcrse_iterator;</code></p>
     <empty-line/>
     <p><code>†// размещение/удаление:</code></p>
     <p><code>†deque();</code></p>
     <p><code>†deque(size_type n, const T&amp; value = T());</code></p>
     <p><code>†deque(const dequeЛT, AllocatorЫ&amp; x);</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†deque(InputIterator first, InputIterator last);</code></p>
     <p><code>†~deque();</code></p>
     <p><code>†dequeЛT, AllocatorЫ&amp; operator=(const dequeЛT,AllocatorЫ&amp; x);</code></p>
     <p><code>†void swap(dequeЛT, AllocatorЫ&amp; x);</code></p>
     <empty-line/>
     <p><code>†// средства доступа:</code></p>
     <p><code>†iterator begin();</code></p>
     <p><code>†const_iterator begin() const;</code></p>
     <p><code>†iterator end();</code></p>
     <p><code>†const_iterator end() const;</code></p>
     <p><code>†reverse_iterator rbegin();</code></p>
     <p><code>†const_reverse_iterator rbegin();</code></p>
     <p><code>†reverse_iterator rend();</code></p>
     <p><code>†const_reverse_iterator rend();</code></p>
     <p><code>†size_type size() const;</code></p>
     <p><code>†size_type max_size() const;</code></p>
     <p><code>†bool empty() const;</code></p>
     <p><code>†reference operator[](size_type n);</code></p>
     <p><code>†const_reference operator[](size_type n) const;</code></p>
     <p><code>†reference front();</code></p>
     <p><code>†const_reference front() const;</code></p>
     <p><code>†reference back();</code></p>
     <p><code>†const_reference back() const;</code></p>
     <empty-line/>
     <p><code>†// вставка/стирание:</code></p>
     <p><code>†void push_front(const T&amp; x);</code></p>
     <p><code>†void push_back(const T&amp; x);</code></p>
     <p><code>†iterator insert(iterator position, const T&amp; x = T());</code></p>
     <p><code>†void insert(iterator position, size_type n, const T&amp; x);</code></p>
     <p><code>†template</code></p>
     <p><code>†void insert(iterator position, InputIterator first, InputIterator last);</code></p>
     <p><code>†void pop_front();</code></p>
     <p><code>†void pop_back();</code></p>
     <p><code>†void erase(iterator position);</code></p>
     <p><code>†void erase(iterator first, iterator last);</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass T, class AllocatorЫ</code></p>
     <p><code>bool operator==(const dequeЛT, AllocatorЫ&amp; x, const dequeЛT, AllocatorЫ&amp; y);</code></p>
     <empty-line/>
     <p><code>template Лclass T, class AllocatorЫ</code></p>
     <p><code>bool operatorЛ(const dequeЛT, AllocatorЫ&amp; x, const dequeЛT, AllocatorЫ&amp; y);</code></p>
     <p>iterator - итератор произвольного доступа, ссылающийс€ на T. “очный тип зависит от исполнени€ и определ€етс€ в Allocator.</p>
     <p>const_iterator - посто€нный итератор произвольного доступа, ссылающийс€ на const T. “очный тип зависит от исполнени€ и определ€етс€ в Allocator. √арантируетс€, что имеетс€ конструктор дл€ const_iterator из iterator.</p>
     <p>size_type - беззнаковый целочисленный тип. “очный тип зависит от исполнени€ и определ€етс€ в Allocator.</p>
     <p>difference_type - знаковый целочисленный тип. “очный зависит от исполнени€ и определ€етс€ в Allocator.</p>
     <p>insert (вставка) в середину двусторонней очереди делает недействительными все итераторы и ссылки двусторонней очереди. insert и push (помещение) с обоих концов двусторонней очереди делают недействительными все итераторы двусторонней очереди, но не вли€ют на действительность всех ссылок на двустороннюю очередь. ¬ худшем случае вставка единственного элемента в двустороннюю очередь занимает линейное врем€ от минимума двух рассто€ний: от точки вставки - до начала и до конца двусторонней очереди. ¬ставка единственного элемента либо в начало, либо в конец двусторонней очереди всегда занимает посто€нное врем€ и вызывает единственный запрос конструктора копии T. “о есть двусторонн€€ очередь особенно оптимизирована дл€ помещени€ и извлечени€ элементов в начале и в конце.</p>
     <p>erase (стирание) в середине двусторонней очереди делает недействительными все итераторы и ссылки двусторонней очереди. erase и pop (извлечение) с обоих концов двусторонней очереди делают недействительными только итераторы и ссылки на стЄртый элемент. „исло вызовов деструктора равно числу стЄртых элементов, а число вызовов оператора присваивани€ равно минимуму из числа элементов перед стЄртыми элементами и числа элементов после стЄртых элементов.</p>
    </section>
   </section>
   <section>
    <title>
     <p>јссоциативные контейнеры (Associative containers)</p>
    </title>
    <section>
     <p>јссоциативные контейнеры обеспечивают быстрый поиск данных, основанных на ключах. Ѕиблиотека предоставл€ет четыре основных вида ассоциативных контейнеров: set (множество), multiset (множество с дубликатами), map (словарь) и multimap (словарь с дубликатами).</p>
     <p>¬се они берут в качестве параметров Key (ключ) и упор€дочивающее отношение Compare, которое вызывает полное упор€дочение по элементам Key.  роме того, map и multimap ассоциируют произвольный тип T с Key. ќбъект типа Compare называетс€ <emphasis>сравнивающим объектом</emphasis> (<emphasis>comparison object</emphasis>) контейнера.</p>
     <p>¬ этом разделе, когда мы говорим о равенстве ключей, мы подразумеваем отношение эквивалентности, обусловленное сравнением и <emphasis>не</emphasis> (<emphasis>not</emphasis>) operator== дл€ ключей. “о есть считаетс€, что два ключа k1 и k2 €вл€ютс€ равными, если дл€ сравнивающего объекта comp истинно comp(k1, k2)==false &amp;&amp; comp(k2, k1)==false.</p>
     <p>јссоциативный контейнер поддерживает <emphasis>уникальные ключи</emphasis> (<emphasis>unique keys</emphasis>), если он может содержать, самое большее, один элемент дл€ каждого значени€ ключа. »наче он поддерживает <emphasis>равные ключи</emphasis> (<emphasis>equal keys</emphasis>). set и map поддерживают уникальные ключи. multiset и multimap поддерживают равные ключи.</p>
     <p>ƒл€ set и multiset значимый тип - тот же самый, что и тип ключа. ƒл€ map и multimap он равен pairЛconst Key, TЫ.</p>
     <p>iterator ассоциативного контейнера относитс€ к категории двунаправленного итератора. insert не вли€ет на действительность итераторов и ссылок контейнера, а erase делает недействительными только итераторы и ссылки на стЄртые элементы.</p>
     <p>¬ следующей таблице обозначаетс€: X - класс ассоциативного контейнера, a - значение X, a_uniq - значение X, когда X поддерживает уникальные ключи, a a_eq - значение X, когда X поддерживает многократные ключи, i и j удовлетвор€ют требовани€м итераторов ввода и указывают на элементы value_type, [i, j) - допустимый диапазон, p - допустимый итератор дл€ a, q - разыменовываемый итератор дл€ a, [q1, q2) - допустимый диапазон в a, t - значение X::value_type и k - значение X::key_type.</p>
     <p><strong>“аблица 12. “ребовани€ ассоциативных контейнеров (в дополнение к контейнерам)</strong> </p>
     <table>
      <tr align="left">
       <th align="left" valign="top">выражение </th>
       <th align="left" valign="top">возвращаемый тип </th>
       <th align="left" valign="top">утверждение/примечание состо€ние до/после </th>
       <th align="left" valign="top">сложность </th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X::key_type </td>
       <td align="left" valign="top">Key</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">врем€ компил€ции</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X::key_compare </td>
       <td align="left" valign="top">Compare </td>
       <td align="left" valign="top">по умолчанию lessЛkey_typeЫ. </td>
       <td align="left" valign="top">врем€ компил€ции </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X::value_compare </td>
       <td align="left" valign="top">тип бинарного предиката </td>
       <td align="left" valign="top">то же, что key_compare дл€ set и multiset; отношение упор€дочени€ пар, вызванное первым компонентом (т.е. Key), дл€ map и multimap. </td>
       <td align="left" valign="top">врем€ компил€ции </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X(c); <emphasis>X a(c); </emphasis></td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">создает пустой контейнер; использует с как объект сравнени€. </td>
       <td align="left" valign="top">посто€нна€ </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X(); <emphasis>X a;</emphasis></td>
       <td align="left" valign="top"><emphasis>-</emphasis></td>
       <td align="left" valign="top">создает пустой контейнер; использует Compare() как объект сравнени€. </td>
       <td align="left" valign="top">посто€нна€ </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X(i,j,c); X a(i,j,c);</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">cоздает пустой контейнер и вставл€ет в него элементы из диапазона [i, j); использует с как объект сравнени€. </td>
       <td align="left" valign="top">вообще NlogN (N - рассто€ние от i до j); линейна€, если [i, j) отсортирован value_comp() </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X(i,j); X a(i,j); </td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">то же, что выше, но использует Compare() как объект сравнени€. </td>
       <td align="left" valign="top">то же, что выше </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.key_comp() </td>
       <td align="left" valign="top">X::key_compare </td>
       <td align="left" valign="top">возвращает объект сравнени€, из которого а был создан. </td>
       <td align="left" valign="top">посто€нна€ </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.value_comp() </td>
       <td align="left" valign="top">X::value_compare </td>
       <td align="left" valign="top">возвращает объект value_compare, созданный из объекта сравнени€. </td>
       <td align="left" valign="top">посто€нна€</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a_uniq.insert(t) </td>
       <td align="left" valign="top">pairЛiterator, boolЫ </td>
       <td align="left" valign="top">вставл€ет t, если и только если в контейнере нет элемента с ключом, равным ключу t.  омпонент bool возвращенной пары показывает, происходит ли вставка, а компонент пары iterator указывает на элемент с ключом, равным ключу t. </td>
       <td align="left" valign="top">логарифмическа€ </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a_eq.insert(t) </td>
       <td align="left" valign="top">iterator </td>
       <td align="left" valign="top">вставл€ет t и возвращает итератор, указывающий на вновь вставленный элемент. </td>
       <td align="left" valign="top">логарифмическа€</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.insert(p, t) </td>
       <td align="left" valign="top">iterator </td>
       <td align="left" valign="top">вставл€ет t, если и только если в контейнерах с уникальными ключами нет элемента с ключом, равным ключу t; всегда вставл€ет t в контейнеры с дубликатами. всегда возвращает итератор, указывающий на элемент с ключом, равным ключу t. итератор p - подсказка, указывающа€, где вставка должна начать поиск. </td>
       <td align="left" valign="top">вообще логарифмическа€, но сводитс€ к посто€нной, если t вставлен пр€мо перед p. </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.insert(i, j) </td>
       <td align="left" valign="top">результат не используетс€ </td>
       <td align="left" valign="top">вставл€ет в контейнер элементы из диапазона [i, j); </td>
       <td align="left" valign="top">вообще Nlog(size()+N) (N - рассто€ние от i до j); линейна€, если [i, j) отсортирован согласно value_comp() </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.erase(k) </td>
       <td align="left" valign="top">size_type </td>
       <td align="left" valign="top">стирает все элементы в контейнере с ключом, равным k. возвращает число уничтоженных элементов. </td>
       <td align="left" valign="top">log(size()) + count(k) </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.erase(q) </td>
       <td align="left" valign="top">результат не используетс€ </td>
       <td align="left" valign="top">стирает элемент, указанный q. </td>
       <td align="left" valign="top">сводитс€ к посто€нной </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.erase(ql, q2) </td>
       <td align="left" valign="top">результат не используетс€ </td>
       <td align="left" valign="top">стирает все элементы в диапазоне [ql, q2). </td>
       <td align="left" valign="top">log(size())+ N, где N - рассто€ние от ql до q2. </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.find(k) </td>
       <td align="left" valign="top">iterator; const_iterator дл€ константы a </td>
       <td align="left" valign="top">возвращает итератор, указывающий на элемент с ключом, равным k, или a.end(), если такой элемент не найден. </td>
       <td align="left" valign="top">логарифмическа€</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.count(k) </td>
       <td align="left" valign="top">size_type </td>
       <td align="left" valign="top">возвращает число элементов с ключом, равным k. </td>
       <td align="left" valign="top">log(size()) + count(k) </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.lower_bound(k) </td>
       <td align="left" valign="top">iterator; const_iterator дл€ константы a </td>
       <td align="left" valign="top">возвращает итератор, указывающий на первый элемент с ключом не меньше, чем k. </td>
       <td align="left" valign="top">логарифмическа€ </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.upper_bound(k) </td>
       <td align="left" valign="top">iterator; const_iterator дл€ константы a </td>
       <td align="left" valign="top">возвращает итератор, указывающий на первый элемент с ключом больше, чем k. </td>
       <td align="left" valign="top">логарифмическа€ </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.equal_range(k) </td>
       <td align="left" valign="top">pairЛiterator, itеratorЫ; pairЛconst_iterator, const_iteratorЫ дл€ константы a </td>
       <td align="left" valign="top">эквивалент make_pair(lower_bound(k), upper_bound(k)). </td>
       <td align="left" valign="top">логарифмическа€ </td>
      </tr>
     </table>
     <p>ќсновным свойством итераторов ассоциативных контейнеров €вл€етс€ то, что они выполн€ют итерации через контейнеры в пор€дке неубывани€ ключей, где неубывание определено сравнением, которое использовалось дл€ их создани€. ƒл€ любых двух разыменованных итераторов i и j таких, что рассто€ние от i до j €вл€етс€ положительным, value_comp (*j, *i)==false. ƒл€ ассоциативных контейнеров с уникальными ключами выдерживаетс€ более сильное условие value_comp(*i, *j)==true.</p>
    </section>
    <section>
     <title>
      <p>ћножество (Set)</p>
     </title>
     <p>set - это ассоциативный контейнер, который поддерживает уникальные ключи (не содержит ключи с одинаковыми значени€ми) и обеспечивает быстрый поиск ключей.</p>
     <p><code>template Лclass Key, class Compare = lessЛKeyЫ, template Лclass UЫ class Allocator = allocatorЫ</code></p>
     <p><code>class set {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code>†// typedefs:</code></p>
     <p><code>†typedef Key key_type;</code></p>
     <p><code>†typedef Key value_type;</code></p>
     <p><code>†typedef AllocatorЛKeyЫ::pointer pointer;</code></p>
     <p><code>†typedef AllocatorЛKeyЫ::reference reference;</code></p>
     <p><code>†typedef AllocatorЛKeyЫ::const_reference const_reference;</code></p>
     <p><code>†typedef Compare key_compare;</code></p>
     <p><code>†typedef Compare value_compare;</code></p>
     <p><code>†typedef iterator;</code></p>
     <p><code>†typedef iterator const_iterator;</code></p>
     <p><code>†typedef size_type;</code></p>
     <p><code>†typedef difference_type;</code></p>
     <p><code>†typedef reverse_iterator;</code></p>
     <p><code>†typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code>†// allocation/deallocation:</code></p>
     <p><code>†set(const Compare&amp; comp = Compare());</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†set(InputIterator first, InputIterator last, const Compare&amp; comp = Compare());</code></p>
     <p><code>†set(const setЛKey, Compare, AllocatorЫ&amp; x);</code></p>
     <p><code>†~set();</code></p>
     <p><code>†setЛKey, Compare, AllocatorЫ&amp; operator=(const setЛKey, Compare, AllocatorЫ&amp; x);</code></p>
     <p><code>†void swap(setЛKey, Compare, AllocatorЫ&amp; x);</code></p>
     <empty-line/>
     <p><code>†// accessors:</code></p>
     <p><code>†key_compare key_comp() const;</code></p>
     <p><code>†value_compare value_comp() const;</code></p>
     <p><code>†iterator begin() const;</code></p>
     <p><code>†iterator end() const;</code></p>
     <p><code>†reverse_iterator rbegin() const;</code></p>
     <p><code>†reverse_iterator rend() const;</code></p>
     <p><code>†bool empty() const;</code></p>
     <p><code>†size_type size() const;</code></p>
     <p><code>†size_type max_size() const;</code></p>
     <empty-line/>
     <p><code>†// insert/erase</code></p>
     <p><code>†pairЛiterator, boolЫ insert(const value_type&amp; x);</code></p>
     <p><code>†iterator insert(iterator position, const value_type&amp; x);</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†void insert(InputIterator first, InputIterator last);</code></p>
     <p><code>†void erase(iterator position);</code></p>
     <p><code>†size_type erase(const key_type&amp; x);</code></p>
     <p><code>†void erase(iterator first, iterator last);</code></p>
     <empty-line/>
     <p><code>†// set operations:</code></p>
     <p><code>†iterator find(const key_type&amp; x) const;</code></p>
     <p><code>†size_type count(const key_type&amp; x) const;</code></p>
     <p><code>†iterator lower_bound(const key_type&amp; x) const;</code></p>
     <p><code>†iterator upper_bound(const key_type&amp; x) const;</code></p>
     <p><code>†pairЛiterator, iteratorЫ equal_range(const key_type&amp; x) const;</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass Key, class Compare, class AllocatorЫ</code></p>
     <p><code>bool operator==(const setЛKey, Compare, AllocatorЫ&amp; x, const setЛKey, Compare, AllocatorЫ&amp; y);</code></p>
     <empty-line/>
     <p><code>template Лclass Key, class Compare, class AllocatorЫ</code></p>
     <p><code>bool operatorЛ(const setЛKey, Compare, AllocatorЫ&amp; x, const setЛKey, Compare, AllocatorЫ&amp; y);</code></p>
     <p>iterator - посто€нный двунаправленный итератор, указывающий на const value_type. “очный тип зависит от реализации и определ€етс€ в Allocator.</p>
     <p>сonst_iterator - тот же самый тип, что и iterator.</p>
     <p>size_type - целочисленный тип без знака. “очный тип зависит от реализации и определ€етс€ в Allocator.</p>
     <p>difference_type - целочисленный тип со знаком. “очный тип зависит от реализации и определ€етс€ в Allocator.</p>
    </section>
    <section>
     <title>
      <p>ћножество с дубликатами (Multiset)</p>
     </title>
     <p>multiset - это ассоциативный контейнер, который поддерживает равные ключи (возможно, содержит множественные копии того же самого значени€ ключа) и обеспечивает быстрый поиск ключей.</p>
     <p><code>template Лclass Key, class Compare = lessЛKeyЫ, template Лclass UЫ class Allocator = allocatorЫ</code></p>
     <p><code>class multiset {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code>†// typedefs:</code></p>
     <p><code>†typedef Key key_type;</code></p>
     <p><code>†typedef Key value_type;</code></p>
     <p><code>†typedef AllocatorЛKeyЫ::pointer pointer;</code></p>
     <p><code>†typedef AliocatorЛKeyЫ::reference reference;</code></p>
     <p><code>†typedef AllocatorЛKeyЫ::const_reference const_reference;</code></p>
     <p><code>†typedef Compare key_compare;</code></p>
     <p><code>†typedef Compare value_compare;</code></p>
     <p><code>†typedef iterator;</code></p>
     <p><code>†typedef iterator const_iterator;</code></p>
     <p><code>†typedef size_type;</code></p>
     <p><code>†typedef difference_type;</code></p>
     <p><code>†typedef reverse_iterator;</code></p>
     <p><code>†typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code>†// allocation/deallocation:</code></p>
     <p><code>†multiset(const Compare&amp; comp = Compare());</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†multiset(InputIterator first, InputIterator last, const Compare&amp; comp†= Compare());</code></p>
     <p><code>†multiset(const multisetЛKey, Compare, AllocatorЫ&amp; x);</code></p>
     <p><code>†~multiset();</code></p>
     <p><code>†multisetЛKey, Compare, AllocatorЫ&amp; operator=(const multisetЛKey, Compare, AllocatorЫ&amp; x);</code></p>
     <p><code>†void swap(multisetЛKey, Compare, AllocatorЫ&amp; x);</code></p>
     <empty-line/>
     <p><code>†// accessors:</code></p>
     <p><code>†key_compare key_comp() const;</code></p>
     <p><code>†value_compare value_comp() const;</code></p>
     <p><code>†iterator begin() const;</code></p>
     <p><code>†iterator end() const;</code></p>
     <p><code>†reverse_iterator rbegin();</code></p>
     <p><code>†reverse_iterator rend();</code></p>
     <p><code>†bool empty() const;</code></p>
     <p><code>†size_type size() const;</code></p>
     <p><code>†size_type max_size() const;</code></p>
     <empty-line/>
     <p><code>†// insert/erase:</code></p>
     <p><code>†iterator insert(const value_type&amp; x);</code></p>
     <p><code>†iterator insert(iterator position, const value_type&amp; x);</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†void insert(InputIterator first, InputIterator last);</code></p>
     <p><code>†void erase(iterator position);</code></p>
     <p><code>†size_type erase(const key_type&amp; x);</code></p>
     <p><code>†void erase(iterator first, iterator last);</code></p>
     <empty-line/>
     <p><code>†// multiset operations:</code></p>
     <p><code>†iterator find(const key_type&amp; x) const;</code></p>
     <p><code>†size_type count(const key_type&amp; x) const;</code></p>
     <p><code>†iterator lower_bound(const key_type&amp; x) const;</code></p>
     <p><code>†iterator upper_bound(const key_type&amp; x) const;</code></p>
     <p><code>†pairЛiterator, iteratorЫ equal_range(const key_type&amp; x) const;</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass Key, class Compare, class AllocatorЫ</code></p>
     <p><code>bool operator==(const multisetЛKey, Compare, AllocatorЫ&amp; x, const multisetЛKey, Compare, AllocatorЫ&amp; y);</code></p>
     <empty-line/>
     <p><code>template Лclass Key, class Compare, class AllocatorЫ</code></p>
     <p><code>bool operatorЛ(const multisetЛKey, Compare, AllocatorЫ&amp; x, const multisetЛKey, Compare, AllocatorЫ&amp; y);</code></p>
     <p>iterator - посто€нный двунаправленный итератор, указывающий на const value_type. “очный тип зависит от реализации и определ€етс€ в Allocator.</p>
     <p>сonst_iterator - тот же самый тип, что и iterator.</p>
     <p>size_type - целочисленный тип без знака. “очный тип зависит от реализации и определ€етс€ в Allocator.</p>
     <p>difference_type - целочисленный тип со знаком. “очный тип зависит от реализации и определ€етс€ в Allocator.</p>
    </section>
    <section>
     <title>
      <p>—ловарь (Map)</p>
     </title>
     <p>map - ассоциативный контейнер, который поддерживает уникальные ключи (не содержит ключи с одинаковыми значени€ми) и обеспечивает быстрый поиск значений другого типа T, св€занных с ключами.</p>
     <p><code>template Лclass Key, class T, class Compare = lessЛKeyЫ, template Лclass UЫ class Allocator = allocatorЫ</code></p>
     <p><code>class map {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code>†// typedefs:</code></p>
     <p><code>†typedef Key key_type;</code></p>
     <p><code>†typedef pairЛconst Key, TЫ value_type;</code></p>
     <p><code>†typedef Compare key_compare;</code></p>
     <p><code>†class value_compare : public binary_functionЛvalue_type, value_type, boolЫ {</code></p>
     <p><code>† friend class map;</code></p>
     <p><code>†protected:</code></p>
     <p><code>† Compare comp;</code></p>
     <p><code>† value_compare(Compare c): comp(c) {}</code></p>
     <p><code>†public:</code></p>
     <p><code>† bool operator()(const value_type&amp; x, const value_type&amp; y) {</code></p>
     <p><code>†† return comp(x.first, y.first);</code></p>
     <p><code>† }</code></p>
     <p><code>†};</code></p>
     <p><code>†typedef iterator;</code></p>
     <p><code>†typedef const_iterator;</code></p>
     <p><code>†typedef AllocatorЛvalue_typeЫ::pointer pointer;</code></p>
     <p><code>†typedef AllocatorЛvalue_typeЫ::reference reference;</code></p>
     <p><code>†typedef AllocatorЛvalue_typeЫ::const_reference const_reference;</code></p>
     <p><code>†typedef size_type;</code></p>
     <p><code>†typedef difference_type;</code></p>
     <p><code>†typedef reverse_iterator;</code></p>
     <p><code>†typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code>†// allocation/deallocation:</code></p>
     <p><code>†map(const Compare&amp; comp = Compare());</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†map(InputIterator first, InputIterator last, const Compare&amp; comp = Compare());</code></p>
     <p><code>†map(const mapЛKey, T, Compare, AllocatorЫ&amp; x);</code></p>
     <p><code>†~map();</code></p>
     <p><code>†mapЛKey, T, Compare, AllocatorЫ&amp; operator=(const mapЛKey, T, Compare, AllocatorЫ&amp; x);</code></p>
     <p><code>†void swap(mapЛKey, T, Compare, AllocatorЫ&amp; x);</code></p>
     <empty-line/>
     <p><code>†// accessors:</code></p>
     <p><code>†key_compare key_comp() const;</code></p>
     <p><code>†value_compare value_comp() const;</code></p>
     <p><code>†iterator begin();</code></p>
     <p><code>†const_iterator begin() const;</code></p>
     <p><code>†iterator end();</code></p>
     <p><code>†const_iterator end() const;</code></p>
     <p><code>†reverse_iterator rbegin();</code></p>
     <p><code>†const_reverse_iterator rbegin();</code></p>
     <p><code>†reverse_iterator rend();</code></p>
     <p><code>†const_reverse_iterator rend();</code></p>
     <p><code>†bool empty() const;</code></p>
     <p><code>†size_type size() const;</code></p>
     <p><code>†size_type max_size() const;</code></p>
     <p><code>†AllocatorЛTЫ::reference operator[](const key_type&amp; x);</code></p>
     <empty-line/>
     <p><code>†// insert/erase:</code></p>
     <p><code>†pairЛiterator, boolЫ insert(const value_type&amp; x);</code></p>
     <p><code>†iterator insert(iterator position, const value_type&amp; x);</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†void insert(InputIterator first, InputIterator last);</code></p>
     <p><code>†void erase(iterator position);</code></p>
     <p><code>†size_type erase(const key_type&amp; x);</code></p>
     <p><code>†void erase(iterator first, iterator last);</code></p>
     <empty-line/>
     <p><code>†// map operations:</code></p>
     <p><code>†iterator find(const key_type&amp; x);</code></p>
     <p><code>†const_iterator find(const key_type&amp; x) const;</code></p>
     <p><code>†size_type count(const key_type&amp; x) const;</code></p>
     <p><code>†iterator lower_bound(const key_type&amp; x);</code></p>
     <p><code>†const_iterator lower_bound(const key_type&amp; x) const;</code></p>
     <p><code>†iterator upper_bound(const key_type&amp; x);</code></p>
     <p><code>†const_iterator upper_bound(const key_type&amp; x) const;</code></p>
     <p><code>†pairЛiterator, iteratorЫ equal_range(const key_type&amp; x);</code></p>
     <p><code>†pairЛconst_iterator, const_iteratorЫ equal_range(const key_type&amp; x)const;</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass Key, class T, class Compare, class AllocatorЫ</code></p>
     <p><code>bool operator==(const mapЛKey, T, Compare, AllocatorЫ&amp; x, const mapЛKey, T, Compare, AllocatorЫ&amp; y);</code></p>
     <empty-line/>
     <p><code>template Лclass Key, class T, class Compare, class AllocatorЫ</code></p>
     <p><code>bool operatorЛ(const mapЛKey, T, Compare, AllocatorЫ&amp; x, const mapЛKey, T, Compare, AllocatorЫ&amp; y);</code></p>
     <p>iterator - двунаправленный итератор, указывающий на value_type. “очный тип зависит от реализации и определ€етс€ в Allocator.</p>
     <p>const_iterator - посто€нный двунаправленный итератор, указывающий на const value_type. “очный тип зависит от реализации и определ€етс€ в Allocator. √арантируетс€, что имеетс€ конструктор дл€ const_iterator из iterator.</p>
     <p>size_type - целочисленный тип без знака. “очный тип зависит от реализации и определ€етс€ в Allocator.</p>
     <p>difference_type - целочисленный тип со знаком. “очный тип зависит от реализации и определ€етс€ в Allocator.</p>
     <p>¬ дополнение к стандартному набору методов ассоциативных контейнеров, map обеспечивает операцию Allocator::reference operator[](const key_type&amp;). ƒл€ словар€ m и ключа k запись m[k] семантически эквивалентна (*((m.insert(make_pair(k, T()))).first)).second.</p>
    </section>
    <section>
     <title>
      <p>—ловарь с дубликатами (Multimар)</p>
     </title>
     <p>multimар - ассоциативный контейнер, который поддерживает равные ключи (возможно, содержит множественные копии того же самого значени€ ключа) и обеспечивает быстрый поиск значений другого типа T, св€занных с ключами.</p>
     <p><code>template Лclass Key, class T, class Compare = lessЛKeyЫ, template Лclass UЫ class Allocator = allocatorЫ</code></p>
     <p><code>class multimap {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code>†// typedefs:</code></p>
     <p><code>†typedef Key key_type;</code></p>
     <p><code>†typedef pairЛconst Key, TЫ value_type;</code></p>
     <p><code>†typedef Compare key_compare;</code></p>
     <p><code>†class value_compare : public binary_functionЛvalue_type, value_type, boolЫ {</code></p>
     <p><code>† friend class multimap;</code></p>
     <p><code>†protected:</code></p>
     <p><code>† Compare comp;</code></p>
     <p><code>† value_compare(Compare c): comp(c) {}</code></p>
     <p><code>†public:</code></p>
     <p><code>† bool operator()(const value_type&amp; x, const value_type&amp; y) {</code></p>
     <p><code>†† return comp(x.first, y.first);</code></p>
     <p><code>† }</code></p>
     <p><code>†};</code></p>
     <p><code>†typedef iterator;</code></p>
     <p><code>†typedef const_iterator;</code></p>
     <p><code>†typedef AllocatorЛvalue_typeЫ::pointer pointer;</code></p>
     <p><code>†typedef AllocatorЛvalue_typeЫ::reference reference;</code></p>
     <p><code>†typedef AllocatorЛvalue_typeЫ::const_reference const_reference;</code></p>
     <p><code>†typedef size_type;</code></p>
     <p><code>†typedef difference_type;</code></p>
     <p><code>†typedef reverse_iterator;</code></p>
     <p><code>†typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code>†// allocation/deallocation:</code></p>
     <p><code>†multimap(const Compare&amp; comp = Compare());</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†multimap(InputIterator first, InputIterator last, const Compare&amp; comp = Compare());</code></p>
     <p><code>†multimap(const multimapЛKey, T, Compare, AllocatorЫ&amp; x);</code></p>
     <p><code>†~multimap();</code></p>
     <p><code>†multimapЛKey, T, Compare, AllocatorЫ&amp; operator=(const multimapЛKey, T, Compare, AllocatorЫ&amp; x);</code></p>
     <p><code>†void swap(multimapЛKey, T, Compare, AllocatorЫ&amp; x);</code></p>
     <empty-line/>
     <p><code>†// accessors:</code></p>
     <p><code>†key_compare key_comp() const;</code></p>
     <p><code>†value_compare value_comp() const;</code></p>
     <p><code>†iterator begin();</code></p>
     <p><code>†const_iterator begin() const;</code></p>
     <p><code>†iterator end();</code></p>
     <p><code>†const_iterator end() const;</code></p>
     <p><code>†reverse_iterator rbegin();</code></p>
     <p><code>†const_reverse_iterator rbegin();</code></p>
     <p><code>†reverse_iterator rend()</code></p>
     <p><code>†const_reverse_iterator rend();</code></p>
     <p><code>†bool empty() const;</code></p>
     <p><code>†size_type size() const;</code></p>
     <p><code>†size_type max_size() const;</code></p>
     <empty-line/>
     <p><code>†// insert/erase:</code></p>
     <p><code>†iterator insert(const value_type&amp; x);</code></p>
     <p><code>†iterator insert(iterator position, const value_type&amp; x);</code></p>
     <p><code>†template Лclass InputIteratorЫ </code></p>
     <p><code>†void insert(InputIterator first, InputIterator last);</code></p>
     <p><code>†void erase(iterator position);</code></p>
     <p><code>†size_type erase(const key_type&amp; x);</code></p>
     <p><code>†void erase(iterator first, iterator last);</code></p>
     <empty-line/>
     <p><code>†// multimap operations:</code></p>
     <p><code>†iterator find(const key_type&amp; x);</code></p>
     <p><code>†const_iterator find(const key_type&amp; x) const;</code></p>
     <p><code>†size_type count(const key_type&amp; x) const;</code></p>
     <p><code>†iterator lower_bound(const key_type&amp; x);</code></p>
     <p><code>†const_iterator lower_bound(const key_type&amp; x) const;</code></p>
     <p><code>†iterator upper_bound(const key_type&amp; x);</code></p>
     <p><code>†const_iterator upper_bound(const key_type&amp; x) const;</code></p>
     <p><code>†pairЛiterator, iteratorЫ equal_range(const key_type&amp; x);</code></p>
     <p><code>†pairЛconst_iterator, const_iteratorЫ equal_range(const key_type&amp; x) const;</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass Key, class T, class Compare, class AllocatorЫ</code></p>
     <p><code>bool operator==(const multimapЛKey, T, Compare, AllocatorЫ&amp; x, const multimapЛKey, T, Compare, AllocatorЫ&amp; y);</code></p>
     <empty-line/>
     <p><code>template Лclass Key, class T, class Compare, class AllocatorЫ</code></p>
     <p><code>bool operatorЛ(const multimapЛKey, T, Compare, AllocatorЫ&amp; x, const multimapЛKey, T, Compare, AllocatorЫ&amp; y);</code></p>
     <p>iterator - двунаправленный итератор, указывающий на value_type. “очный тип зависит от реализации и определ€етс€ в Allocator.</p>
     <p>const_iterator - посто€нный двунаправленный итератор, указывающий на value_type. “очный тип зависит от реализации и определ€етс€ в Allocator. √арантируетс€, что имеетс€ конструктор дл€ const_iterator из iterator.</p>
     <p>size_type - целочисленный тип без знака. “очный тип зависит от реализации и определ€етс€ в Allocator.</p>
     <p>difference_type - целочисленный тип со знаком. “очный тип зависит от реализации и определ€етс€ в Allocator.</p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>»“≈–ј“ќ–џ ѕќ“ќ ќ¬</p>
   </title>
   <section>
    <p>„тобы шаблоны алгоритмов могли работать непосредственно с потоками ввода-вывода, предусмотрены соответствующие шаблонные классы, подобные итераторам. Ќапример,</p>
    <p><code>partial_sum_copy(istream_iteratorЛdoubleЫ(cin), istream_iteratorЛdoubleЫ(), ostream_iteratorЛdoubleЫ(cout, "\n"));</code></p>
    <p>читает файл, содержащий числа с плавающей зап€той, из cin и печатает частичные суммы в cout.</p>
   </section>
   <section>
    <title>
     <p>»тератор входного потока (Istream Iterator)</p>
    </title>
    <p>istream_iteratorЛTЫ читает (использу€ operatorЫЫ) последовательные элементы из входного потока, дл€ которого он был создан. ѕосле своего создани€ итератор каждый раз при использовании ++ читает и сохран€ет значение T. ≈сли достигнут конец потока (operator void* () в потоке возвращает false), итератор становитс€ равным значению <emphasis>end-of-stream</emphasis> (<emphasis>конец-потока</emphasis>).  онструктор без параметров istream_iterator() всегда создаЄт итераторный объект конца потокового ввода, €вл€ющийс€ единственым законным итератором, который следует использовать дл€ конечного услови€. –езультат operator* дл€ конца потока не определЄн, а дл€ любого другого значени€ итератора возвращаетс€ const T&amp;.</p>
    <p>Ќевозможно записывать что-либо с использованием входных итераторов. ќсновна€ особенность входных итераторов - тот факт, что операторы ++ не сохран€ют равенства, то есть i==j не гарантирует вообще, что ++i==++j.  аждый раз, когда ++ используетс€, читаетс€ новое значение. ѕрактическое следствие этого факта - то, что входные итераторы могут использоватьс€ только дл€ однопроходных алгоритмов, что действительно имеет здравый смысл, так как многопроходным алгоритмам всегда более соответствует использование структур данных в оперативной пам€ти.</p>
    <p>ƒва итератора <emphasis>конец-потока</emphasis> всегда равны. »тератор <emphasis>конец-потока</emphasis> не равен <emphasis>не-конец-потока</emphasis> итератору. ƒва <emphasis>не-конец-потока</emphasis> итератора равны, когда они созданы из того же самого потока.</p>
    <p><code>template Лclass T, class Distance = ptrdiff_tЫ</code></p>
    <p><code>class istream_iterator: public input_iteratorЛT, DistanceЫ {</code></p>
    <p><code>†friend bool operator==(const istream_iteratorЛT, DistanceЫ&amp; x, const istream_iteratorЛT, DistanceЫ&amp; y);</code></p>
    <p><code>public:</code></p>
    <p><code>†istream_iterator();</code></p>
    <p><code>†istream_iterator(istream&amp; s);</code></p>
    <p><code>†istream_iterator(const istream_iteratorЛT, DistanceЫ&amp; x);</code></p>
    <p><code>†~istream_iterator();</code></p>
    <p><code>†const T&amp; operator*() const;</code></p>
    <p><code>†istream_iteratorЛT, DistanceЫ&amp; operator++();</code></p>
    <p><code>†istream_iteratorЛT, DistanceЫ operator++(int);</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>template Лclass T, class DistanceЫ</code></p>
    <p><code>bool operator==(const istream_iteratorЛT, DistanceЫ&amp; x, const istream_iteratorЛT, DistanceЫ&amp; y);</code></p>
   </section>
   <section>
    <title>
     <p>»тератор выходного потока (Ostream Iterator)</p>
    </title>
    <p>istream_iteratorЛTЫ записывает (использу€ operatorЛЛ) последовательные элементы в выходной поток, из которого он был создан. ≈сли он был создан с параметром конструктора char*, эта строка, называема€ <emphasis>строкой разделител€</emphasis> (<emphasis>delimiter string</emphasis>), записываетс€ в поток после того, как записываетс€ каждое T. Ќевозможно с помощью выходного итератора получить значение. ≈го единственное использование - выходной итератор в ситуаци€х, подобных нижеследующему:</p>
    <p><code>while (first != last) *result++ = *first++;</code></p>
    <p>ostream_iterator определЄн как:</p>
    <p><code>template Лclass TЫ</code></p>
    <p><code>class ostream_iterator: public output_iterator {</code></p>
    <p><code>public:</code></p>
    <p><code>†ostream_iterator(ostream&amp; s);</code></p>
    <p><code>†ostream_iterator(ostream&amp; s, const char* delimiter);</code></p>
    <p><code>†ostream_iterator(const ostream_iteratorЛTЫ&amp; x);</code></p>
    <p><code>†~ostream_iterator();</code></p>
    <p><code>†ostream_iteratorЛTЫ&amp; operator=(const T&amp; value);</code></p>
    <p><code>†ostream_iteratorЛTЫ&amp; operator*();</code></p>
    <p><code>†ostream_iteratorЛTЫ&amp; operator++();</code></p>
    <p><code>†ostream_iteratorЛTЫ&amp; operator++(int);</code></p>
    <p><code>};</code></p>
   </section>
  </section>
  <section>
   <title>
    <p>јЋ√ќ–»“ћџ</p>
   </title>
   <section>
    <p>¬се алгоритмы отделены от деталей реализации структур данных и используют в качестве параметров типы итераторов. ѕоэтому они могут работать с определ€емыми пользователем структурами данных, когда эти структуры данных имеют типы итераторов, удовлетвор€ющие предположени€м в алгоритмах.</p>
    <p>ƒл€ некоторых алгоритмов предусмотрены и оперативные и копирующие версии. –ешение, включать ли копирующую версию, было обычно основано на рассмотрении сложности.  огда стоимость выполнени€ операции доминирует над стоимостью копии, копирующа€ верси€ не включена. Ќапример, sort_copy не включена, так как стоимость сортировки намного значительнее, и пользователи могли бы также делать copy перед sort.  огда така€ верси€ предусмотрена дл€ какого-то алгоритма <emphasis>algorithm</emphasis>, он называетс€ <emphasis>algorithm _copy </emphasis>. јлгоритмы, которые берут предикаты, оканчиваютс€ суффиксом _if (который следует за суффиксом _copy).</p>
    <p> ласс Predicate используетс€ вс€кий раз, когда алгоритм ожидает функциональный объект, при применении которого к результату разыменовани€ соответствующего итератора возвращаетс€ значение, обратимое в bool. ƒругими словами, если алгоритм берЄт Predicate pred как свой параметр и first как свой параметр итератора, он должен работать правильно в конструкции if (pred(*first)) {Е}. ѕредполагаетс€, что функциональный объект pred не примен€ет какую-либо непосто€нную функцию дл€ разыменованного итератора.</p>
    <p> ласс BinaryPredicate используетс€ вс€кий раз, когда алгоритм ожидает функциональный объект, который при его применении к результату разыменовани€ двух соответствующих итераторов или к разыменованию итератора и типа T, когда T - часть сигнатуры, возвращает значение, обратимое в bool. ƒругими словами, если алгоритм берЄт BinaryPredicate binary_pred как свой параметр и first1 и first2 как свои параметры итераторов, он должен работать правильно в конструкции if (binary_pred(*first, *first2)) {Е}. BinaryPredicate всегда берЄт тип первого итератора как свой первый параметр, то есть в тех случа€х, когда T value - часть сигнатуры, он должен работать правильно в контексте if (binary_pred (*first, value)) {Е}. ќжидаетс€, что binary_pred не будет примен€ть какую-либо непосто€нную функцию дл€ разыменованных итераторов.</p>
    <p>¬ описании алгоритмов операторы + и - используютс€ дл€ некоторых категорий итераторов, дл€ которых они не должны быть определены. ¬ этих случа€х семантика a+n така€ же, как семантика {X tmp = a; advance(tmp, n); return tmp;}, а семантика a-b така€ же, как семантика {Distance n; distance(a, b, n); return n;}.</p>
   </section>
   <section>
    <title>
     <p>Ќе мен€ющие последовательность операции (Non-mutating sequence operations)</p>
    </title>
    <section>
     <title>
      <p>ќперации с каждым элементом (For each)</p>
     </title>
     <p><code>template &lt;class InputIterator, class Function&gt; </code></p>
     <p><code>Function for_each(InputIterator first, InputIterator last, Function f);</code></p>
     <p>for_each примен€ет f к результату разыменовани€ каждого итератора в диапазоне [first, last) и возвращает f. ѕрин€то, что f не примен€ет какую-то непосто€нную функцию к разыменованному итератору. f примен€етс€ точно last-first раз. ≈сли f возвращает результат, результат игнорируетс€.</p>
    </section>
    <section>
     <title>
      <p>Ќайти (Find)</p>
     </title>
     <p><code>template Лclass InputIterator, class TЫ</code></p>
     <p><code>InputIterator find(InputIterator first, InputIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator, class PredicateЫ</code></p>
     <p><code>InputIterator find_if(InputIterator first, InputIterator last, Predicate pred);</code></p>
     <p>find возвращает первый итератор i в диапазоне [first, last), дл€ которого соблюдаютс€ следующие соответствующие услови€: *i==value, pred(*i)==true. ≈сли такой итератор не найден, возвращаетс€ last. —оответствующий предикат примен€етс€ точно find(first, last, value) - first раз.</p>
    </section>
    <section>
     <title>
      <p>Ќайти р€дом (јdjacent find)</p>
     </title>
     <p><code>template Лclass ForwardIteratorЫ</code></p>
     <p><code>ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass ForwardIterator, class BinaryPredicateЫ</code></p>
     <p><code>ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred);</code></p>
     <p>adjacent_find возвращает первый итератор i такой, что i и i+1 наход€тс€ в диапазоне [first, last) и дл€ которого соблюдаютс€ следующие соответствующие услови€: *i==*(i+1), binary_pred(*i, *(i+1))==true. ≈сли такой итератор i не найден, возвращаетс€ last. —оответствующий предикат примен€етс€, самое большее, max((last - first) - 1, 0) раз.</p>
    </section>
    <section>
     <title>
      <p>ѕодсчет (Count)</p>
     </title>
     <p><code>template Лclass InputIterator, class T, class SizeЫ</code></p>
     <p><code>void count(InputIterator first, InputIterator last, const T&amp; value, Size&amp; n);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator, class Predicate, class SizeЫ</code></p>
     <p><code>void count_if(InputIterator first, InputIterator last, Predicate pred, Size&amp; n);</code></p>
     <p>count добавл€ет к n число итераторов i в диапазоне [first, last), дл€ которых соблюдаютс€ следующие соответствующие услови€: *i==value, pred(*i)==true. —оответствующий предикат примен€етс€ точно last-first раз.</p>
     <p>count должен сохран€ть результат в параметре ссылки вместо того, чтобы возвращать его, потому что тип размера не может быть выведен из встроенных типов итераторов, как, например, int*.</p>
    </section>
    <section>
     <title>
      <p>ќтличие (Mismatch)</p>
     </title>
     <p><code>template Лclass InputIterator1, class InputIterator2Ы</code></p>
     <p><code>pairЛInputIterator1, InputIterator2Ы mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator1, class InputIterator2, class BinaryPredicateЫ</code></p>
     <p><code>pairЛInputIterator1, InputIterator2Ы mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred);</code></p>
     <p>mismatch возвращает пару итераторов i и j таких, что j==first2 + (i - first1) и i €вл€етс€ первым итератором в диапазоне [first1, last1), дл€ которого следующие соответствующие услови€ выполнены: !(*i==*(first2 + (i - first1))), binary_pred (*i, *(first2 + (i - first1)))==false. ≈сли такой итератор i не найден, пара last1 и first2 + (last1 - first1) возвращаетс€. —оответствующий предикат примен€етс€, самое большее, last1 - first1 раз.</p>
    </section>
    <section>
     <title>
      <p>—равнение на равенство (Equal)</p>
     </title>
     <p><code>template Лclass InputIterator1, class InputIterator2Ы</code></p>
     <p><code>bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator1, class InputIterator2, class BinaryPredicateЫ</code></p>
     <p><code>bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred);</code></p>
     <p>equal возвращает true, если дл€ каждого итератора i в диапазоне [first1, last1) выполнены следующие соответствующие услови€: *i==*(first2 + (i-first1)), binary_pred(*i, *(first2 + (i - first1)))==true. »наче equal возвращает false. —оответствующий предикат примен€етс€, самое большее, last1 - first1 раз.</p>
    </section>
    <section>
     <title>
      <p>ѕоиск подпоследовательности (Search)</p>
     </title>
     <p><code>template Лclass ForwardIterator1, class ForwardIterator2Ы</code></p>
     <p><code>ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);</code></p>
     <empty-line/>
     <p><code>template Лclass ForwardIterator1, class ForwardIterator2, class BinaryPredicateЫ</code></p>
     <p><code>ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate binary_pred);</code></p>
     <p>search находит подпоследовательность равных значений в последовательности. search возвращает первый итератор i в диапазоне [first1, last1 - (last2 - first2)) такой, что дл€ любого неотрицательного целого числа n, меньшего чем last2 - first2, выполнены следующие соответствующие услови€: *(i+n)==*(first2+n), binary_pred(*(i+n), *(first2+n))==true. ≈сли такой итератор не найден, возвращаетс€ last1. —оответствующий предикат примен€етс€, самое большее, (last1 - first1) * (last2 - first2) раз.  вадратичное поведение, однако, €вл€етс€ крайне маловеро€тным.</p>
    </section>
   </section>
   <section>
    <title>
     <p>ћен€ющие последовательность операции (Mutating sequence operations)</p>
    </title>
    <section>
     <title>
      <p> опировать (Copy)</p>
     </title>
     <p><code>template Лclass InputIterator, class OutputIteratorЫ</code></p>
     <p><code>OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result);</code></p>
     <p>copy копирует элементы. ƒл€ каждого неотрицательного целого числа n Л (last - first) выполн€етс€ присваивание *(result + n) = *(first + n). “очно делаетс€ last - first присваиваний. –езультат copy не определЄн, если result находитс€ в диапазоне [first, last).</p>
     <p><code>template Лclass BidirectionalIterator1, class BidirectionalIterator2Ы</code></p>
     <p><code>BidirectionalIterator2 copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 result);</code></p>
     <p>copy_backward копирует элементы в диапазоне [first, last) в диапазон [result - (last - first), result), начина€ от last-1 и продолжа€ до first. ≈го нужно использовать вместо copy, когда last находитс€ в диапазоне [result - (last-first), result). ƒл€ каждого положительного целого числа n Л= (last - first) выполн€етс€ присваивание *(result-n) = *(last-n). copy_backward возвращает result - (last-first). “очно делаетс€ last - first присваиваний. –езультат copy_backward не определЄн, если result находитс€ в диапазоне [first, last).</p>
    </section>
    <section>
     <title>
      <p>ќбмен€ть (Swap)</p>
     </title>
     <p><code>template Лclass TЫ</code></p>
     <p><code>void swap(T&amp; a, T&amp; b);</code></p>
     <p>swap обменивает значени€, хранимые в двух местах.</p>
     <p><code>template Лclass ForwardIterator1, class ForwardIterator2Ы</code></p>
     <p><code>void iter_swap(ForwardIterator1 a, ForwardIterator2 b);</code></p>
     <p>iter_swap обменивает значени€, указанные двум€ итераторами a и b.</p>
     <p><code>tempate Лclass ForwardIterator1, class ForwardIterator2Ы</code></p>
     <p><code>ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);</code></p>
     <p>ƒл€ каждого неотрицательного целого числа n Л (last1 - first1) выполн€етс€ перестановка: swap(*(first1 + n), *(first2 + n)). swap_ranges возвращает first2 + (last1 - first1). ¬ыполн€етс€ точно last1 - first1 перестановок. –езультат swap_ranges не определЄн, если два диапазона [first1, last1) и [first2, first2 + (last1 - first1)) перекрываютс€.</p>
    </section>
    <section>
     <title>
      <p>ѕреобразовать (Transform)</p>
     </title>
     <p><code>template Лclass InputIterator, class OutputIterator, class UnaryOperationЫ</code></p>
     <p><code>OutputIterator transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator1, class InputIterator2, class OutputIterator, class Binary0perationЫ</code></p>
     <p><code>OutputIterator transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation binary_op);</code></p>
     <p>transform присваивает посредством каждого итератора i в диапазоне [result, result+(last1-first1)) новое соответствующее значение, равное op(*(first1+(i-result)) или binary_op(*(first1+(i-result), *(first2+(i-result))). transform возвращает result+(last1-first1). ѕримен€ютс€ op или binary_op точно last1 - first1 раз. ќжидаетс€, что op и binary_op не имеют каких-либо побочных эффектов. result может быть равен first в случае унарного преобразовани€ или first1 либо first2 в случае бинарного.</p>
    </section>
    <section>
     <title>
      <p>«аменить (Replace)</p>
     </title>
     <p><code>template Лclass ForwardIterator, class TЫ</code></p>
     <p><code>void replace(ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value);</code></p>
     <empty-line/>
     <p><code>template Лclass ForwardIterator, class Predicate, class TЫ</code></p>
     <p><code>void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T&amp; new_value);</code></p>
     <p>replace замен€ет элементы, указанные итератором i в диапазоне [first, last), значением new_value, когда выполн€ютс€ следующие соответствующие услови€: *i==old_value, pred(*i)==true. —оответствующий предикат примен€етс€ точно last - first раз.</p>
     <p><code>template Лclass InputIterator, class OutputIterator, class TЫ</code></p>
     <p><code>OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T&amp; old_value, const T&amp; new_value);</code></p>
     <empty-line/>
     <p><code>template Лclass Iterator, class OutputIterator, class Predicate, class TЫ</code></p>
     <p><code>OutputIterator replace_copy_if(Iterator first, Iterator last, OutputIterator result, Predicate pred, const T&amp; new_value);</code></p>
     <p>replace_copy присваивает каждому итератору i в диапазоне [result, result+(last-first)) значение new_value или *(first+(i-result)) в зависимости от выполнени€ следующих соответствующих условий: *(first+(i-result))==old_value, pred(*(first+(i-result)))==true. replace_copy возвращает result+(last-first). —оответствующий предикат примен€етс€ точно last - first раз.</p>
    </section>
    <section>
     <title>
      <p>«аполнить (Fill)</p>
     </title>
     <p><code>template Лclass ForwardIterator, class TЫ</code></p>
     <p><code>void fill(ForwardIterator first, ForwardIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template Лclass OutputIterator, class Size, class TЫ</code></p>
     <p><code>OutputIterator fill_n(Output Iterator first, Size n, const T&amp; value);</code></p>
     <p>fill присваивает значени€ через все итераторы в диапазоне [first, last) или [first, first+n). fill_n возвращает first+n. “очно делаетс€ last - first (или n) присваиваний.</p>
    </section>
    <section>
     <title>
      <p>ѕородить (Generate)</p>
     </title>
     <p><code>template Лclass ForwardIterator, class GeneratorЫ</code></p>
     <p><code>void generate(ForwardIterator first, ForwardIterator last, Generator gen);</code></p>
     <empty-line/>
     <p><code>template Лclass OutputIterator, class Size, class GeneratorЫ</code></p>
     <p><code>OutputIterator generate_n(OutputIterator first, Size n, Generator gen);</code></p>
     <p>generate вызывает функциональный объект gen и присваивает возвращаемое gen значение через все итераторы в диапазоне [first, last) или [first, first + n). gen не берЄт никакие параметры. generate_n возвращает first + n. “очно выполн€етс€ last - first (или n) вызовов gen и присваиваний.</p>
    </section>
    <section>
     <title>
      <p>”далить (Remove)</p>
     </title>
     <p><code>template Лclass ForwardIterator, class TЫ</code></p>
     <p><code>ForwardIterator remove(ForwardIterator first, ForwardIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template Лclass ForwardIterator, class PredicateЫ</code></p>
     <p><code>ForwardIterator remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);</code></p>
     <p>remove устран€ет все элементы, указываемые итератором i в диапазоне [first, last), дл€ которых выполнены следующие соответствующие услови€: *i==value, pred(*i)==true. remove возвращает конец возникающего в результате своей работы диапазона. remove устойчив, то есть относительный пор€док элементов, которые не удалены, такой же, как их относительный пор€док в первоначальном диапазоне. —оответствующий предикат примен€етс€ точно last -first раз.</p>
     <p><code>template Лclass InputIterator, class OutputIterator, class TЫ</code></p>
     <p><code>OutputIterator remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator, class OutputIterator, class PredicateЫ</code></p>
     <p><code>OutputIterator remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);</code></p>
     <p>remove_copy копирует все элементы, указываемые итератором i в диапазоне [first, last), дл€ которых не выполнены следующие соответствующие услови€: *i==value, pred(*i)==true. remove_copy возвращает конец возникающего в результате своей работы диапазона. remove_copy устойчив, то есть относительный пор€док элементов в результирующем диапазоне такой же, как их относительный пор€док в первоначальном диапазоне. —оответствующий предикат примен€етс€ точно last-first раз.</p>
    </section>
    <section>
     <title>
      <p>”брать повторы (Unique)</p>
     </title>
     <p><code>template Лclass ForwardIteratorЫ</code></p>
     <p><code>ForwardIterator unique(ForwardIterator first, ForwardIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass ForwardIterator, class BinaryPredicateЫ</code></p>
     <p><code>ForwardIterator unique(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred);</code></p>
     <p>unique устран€ет все, кроме первого, элементы из каждой последовательной группы равных элементов, указываемые итератором i в диапазоне [first, last), дл€ которых выполнены следующие соответствующие услови€: *i==*(i-1) или binary_pred(*i, *(i-1))==true. unique возвращает конец возникающего в результате диапазона. —оответствующий предикат примен€етс€ точно (last-first)-1 раз.</p>
     <p><code>template Лclass InputIterator, class OutputIteratorЫ</code></p>
     <p><code>OutputIterator unique_copy(InputIterator first, InputIterator last, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator, class OutputIterator, class BinaryPredicateЫ</code></p>
     <p><code>OutputIterator unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate binary_pred);</code></p>
     <p>unique_copy копирует только первый элемент из каждой последовательной группы равных элементов, указываемых итератором i в диапазоне [first, last), дл€ которых выполнены следующие соответствующие услови€: *i==*(i-1) или binary_pied(*i, *(i-1))==true. unique_copy возвращает конец возникающего в результате диапазона. —оответствующий предикат примен€етс€ точно (last-first)-1 раз.</p>
    </section>
    <section>
     <title>
      <p>–асположить в обратном пор€дке (Reverse)</p>
     </title>
     <p><code>template Лclass BidirectionalIteratorЫ</code></p>
     <p><code>void reverse(BidirectionalIterator first, BidirectionalIterator last);</code></p>
     <p>ƒл€ каждого неотрицательного целого числа iЛ=(last-first)/2 функци€ reverse примен€ет перестановку ко всем парам итераторов first+i, (last-i)-1. ¬ыполн€етс€ точно (last-first)/2 перестановок.</p>
     <p><code>template Лclass BidirectionalIterator, class OutputIteratorЫ</code></p>
     <p><code>OutputIterator reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);</code></p>
     <p>reverse_copy копирует диапазон [first, last) в диапазон [result, result+(last-first)) такой, что дл€ любого неотрицательного целого числа i Л (last-first) происходит следующее присваивание: *(result+(last-first)-i) = *(first+i). reverse_copy возвращает result+(last-first). ƒелаетс€ точно last-first присваиваний. –езультат reverse_copy не определЄн, если [first, last) и [result, result +(last-first)) перекрываютс€.</p>
    </section>
    <section>
     <title>
      <p>ѕереместить по кругу (Rotate)</p>
     </title>
     <p><code>template Лclass ForwardIteratorЫ</code></p>
     <p><code>void rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);</code></p>
     <p>ƒл€ каждого неотрицательного целого числа i Л (last-first) функци€ rotate помещает элемент из позиции first+i в позицию first+(i+(last-middle))%(last-first). [first, middle) и [middle, last) - допустимые диапазоны. ћаксимально выполн€етс€ last-first перестановок.</p>
     <p><code>template Лclass ForwardIterator, class OutputIteratorЫ</code></p>
     <p><code>OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);</code></p>
     <p>rotate_copy копирует диапазон [first, last) в диапазон [result, result+(last-first)) такой, что дл€ каждого неотрицательного целого числа i Л (last-first) происходит следующее присваивание: *(result+(i+(last-middle))%(last-first)) = *(first+i). rotate_copy возвращает result+(last-first). ƒелаетс€ точно last-first присваиваний. –езультат rotate_copy не определЄн, если [first, last) и [result, result+(last-first)) перекрываютс€.</p>
    </section>
    <section>
     <title>
      <p>ѕеретасовать (Random shuffle)</p>
     </title>
     <p><code>template Лclass RandomAccessIteratorЫ</code></p>
     <p><code>void random_shuffle(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class RandomNumberGeneratorЫ</code></p>
     <p><code>void random_shuffie(RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator&amp; rand);</code></p>
     <p>random_shuffle переставл€ет элементы в диапазоне [first, last) с равномерным распределением. ¬ыполн€етс€ точно last-first перестановок. random_shuffle может брать в качестве параметра особый генерирующий случайное число функциональный объект rand такой, что rand берЄт положительный параметр n типа рассто€ни€ RandomAccessIterator и возвращает случайно выбранное значение между 0 и n-1.</p>
    </section>
    <section>
     <title>
      <p>–азделить (Partitions)</p>
     </title>
     <p><code>template Лclass BidirectionalIterator, class PredicateЫ</code></p>
     <p><code>BidirectionalIterator partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred);</code></p>
     <p>partition помещает все элементы в диапазоне [first, last), которые удовлетвор€ют pred, перед всеми элементами, которые не удовлетвор€ют. ¬озвращаетс€ итератор i такой, что дл€ любого итератора j в диапазоне [first, i) будет pred(*j)==true, а дл€ любого итератора k в диапазоне [i, last) будет pred(*k)==false. ƒелаетс€ максимально (last-first)/2 перестановок. ѕредикат примен€етс€ точно last-first раз.</p>
     <p><code>template Лclass BidirectionalIterator, class PredicateЫ</code></p>
     <p><code>BidirectionalIterator stable_partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred);</code></p>
     <p>stable_partition помещает все элементы в диапазоне [first, last), которые удовлетвор€ют pred, перед всеми элементами, которые не удовлетвор€ют. ¬озвращаетс€ итератор i такой, что дл€ любого итератора j в диапазоне [first, i) будет pred(*j)==true, а дл€ любого итератора k в диапазоне [i, last) будет pred(*k)==false. ќтносительный пор€док элементов в обеих группах сохран€етс€. ƒелаетс€ максимально (last-first)*log(last-first) перестановок, но только линейное число перестановок, если имеетс€ достаточна€ дополнительна€ пам€ть. ѕредикат примен€етс€ точно last-first раз.</p>
    </section>
   </section>
   <section>
    <title>
     <p>ќперации сортировки и отношени€ (Sorting and related operations)</p>
    </title>
    <section>
     <p>¬се операции в этом разделе имеют две версии: одна берЄт в качестве параметра функциональный объект типа Compare, а друга€ использует operatorЛ.</p>
     <p>Compare - функциональный объект, который возвращает значение, обратимое в bool. Compare comp используетс€ полностью дл€ алгоритмов, принимающих отношение упор€дочени€. comp удовлетвор€ет стандартным аксиомам дл€ полного упор€дочени€ и не примен€ет никакую непосто€нную функцию к разыменованному итератору. ƒл€ всех алгоритмов, которые берут Compare, имеетс€ верси€, котора€ использует operatorЛ взамен. “о есть comp(*i, *j)==true по умолчанию дл€ *iЛ*j==true.</p>
     <p>ѕоследовательность сортируетс€ относительно компаратора comp, если дл€ любого итератора i, указывающего на элемент в последовательности, и любого неотрицательного целого числе n такого, что i + n €вл€етс€ допустимым итератором, указывающим на элемент той же самой последовательности, comp(*(i+n), *i)==false.</p>
     <p>¬ описани€х функций, которые имеют дело с упор€дочивающими отношени€ми, мы часто используем представление равенства, чтобы описать такие пон€ти€, как устойчивость. –авенство, к которому мы обращаемс€, не об€зательно operator==, а отношение равенства стимулируетс€ полным упор€дочением. “о есть два элементa a и b считаютс€ равными, если и только если !(a Л b)&amp;&amp;!(b Л a).</p>
    </section>
    <section>
     <title>
      <p>—ортировка (Sort)</p>
     </title>
     <p><code>template Лclass RandomAccessIteratorЫ</code></p>
     <p><code>void sort(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class CompareЫ</code></p>
     <p><code>void sort(RandomAccessIterator first, RandomAccessIterator last, Compare соmр);</code></p>
     <p>sort сортирует элементы в диапазоне [first, last). ƒелаетс€ приблизительно NIogN (где N равн€етс€ last-first) сравнений в среднем. ≈сли режим наихудшего случа€ важен, должны использоватьс€ stable_sort или partial_sort.</p>
     <p><code>template Лclass RandomAccessIteratorЫ</code></p>
     <p><code>void stable_sort(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class CompareЫ</code></p>
     <p><code>void stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
     <p>stable_sort сортирует элементы в диапазоне [first, last). ќн устойчив, то есть относительный пор€док равных элементов сохран€етс€. ƒелаетс€ максимум N(logN)<sup>2</sup> (где N равн€етс€ last-first) сравнений; если доступна достаточна€ дополнительна€ пам€ть, тогда это - NlogN.</p>
     <p><code>template Лclass RandomAccessIteratorЫ</code></p>
     <p><code>void partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class CompareЫ</code></p>
     <p><code>void partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);</code></p>
     <p>partial_sort помещает первые middle - first сортированных элементов из диапазона [first, last) в диапазон [first, middle). ќстальна€ часть элементов в диапазоне [middle, last) помещена в неопределЄнном пор€дке. ЅерЄтс€ приблизительно (last-first)*log(middle-first) сравнений.</p>
     <p><code>template Лclass InputIterator, class RandomAccessIteratorЫ</code></p>
     <p><code>RandomAccessIterator partial_sort_copy(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator, class RandomAccessIterator, class CompareЫ</code></p>
     <p><code>RandomAccessIterator partial_sort_copy(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);</code></p>
     <p>partial_sort_copy помещает первые min(last-first, result_last-result_first) сортированных элементов в диапазон [result_first, result_first+min(last-first, result_last-result_first)). ¬озвращаетс€ или result_last, или result_first+(last-first), какой меньше. ЅерЄтс€ приблизительно (last-first)*log(min(last-first, result_last-result_first)) сравнений.</p>
    </section>
    <section>
     <title>
      <p>N-й элемент (Nth element)</p>
     </title>
     <p><code>template Лclass RandomAccessIteratorЫ</code></p>
     <p><code>void nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class CompareЫ</code></p>
     <p><code>void nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);</code></p>
     <p>ѕосле операции nth_element элемент в позиции, указанной nth, €вл€етс€ элементом, который был бы в той позиции, если бы сортировалс€ целый диапазон. “акже дл€ любого итератора i в диапазоне [first, nth) и любого итератора j в диапазоне [nth, last) считаетс€, что !(*i Ы *j) или comp(*i, *j)==false. ќпераци€ линейна в среднем.</p>
    </section>
    <section>
     <title>
      <p>ƒвоичный поиск (Binary search)</p>
     </title>
     <p>¬се алгоритмы в этом разделе - версии двоичного поиска. ќни работают с итераторами не произвольного доступа, уменьша€ число сравнений, которое будет логарифмическим дл€ всех типов итераторов. ќни особенно подход€т дл€ итераторов произвольного доступа, так как эти алгоритмы делают логарифмическое число шагов в структуре данных. ƒл€ итераторов не произвольного доступа они выполн€ют линейное число шагов.</p>
     <p><code>template Лclass ForwardIterator, class TЫ</code></p>
     <p><code>ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template Лclass ForwardIterator, class T, class CompareЫ</code></p>
     <p><code>ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);</code></p>
     <p>lower_bound находит первую позицию, в которую value может быть вставлено без нарушени€ упор€дочени€. lower_bound возвращает самый дальний итератор i в диапазоне [first, last) такой, что дл€ любого итератора j в диапазоне [first, i) выполн€ютс€ следующие соответствующие услови€: *jЛvalue или comp(*j, value)==true. ƒелаетс€ максимум log(last-first)+1 сравнений.</p>
     <p><code>template Лclass ForwardIterator, class TЫ</code></p>
     <p><code>ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template Лclass ForwardIterator, class T, class CompareЫ</code></p>
     <p><code>ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);</code></p>
     <p>upper_bound находит самую дальнюю позицию, в которую value может быть вставлено без нарушени€ упор€дочени€. upper_bound возвращает самый дальний итератор i в диапазоне [first, last) такой, что дл€ любого итератора j в диапазоне [first, i) выполн€ютс€ следующие соответствующие услови€: !(valueЛ*j) или comp(value, *j)==false. ƒелаетс€ максимум log(last-first)+1 сравнений.</p>
     <p><code>template Лclass ForwardIterator, class TЫ</code></p>
     <p><code>ForwardIterator equal_range(ForwardIterator first, ForwardIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template Лclass ForwardIterator, class T, class CompareЫ</code></p>
     <p><code>ForwardIterator equal_range(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);</code></p>
     <p>equal_range находит самый большой поддиапазон [i, j) такой, что значение может быть вставлено по любому итератору k в нЄм. k удовлетвор€ет соответствующим услови€м: !(*k Л value)&amp;&amp;!(value Л *k) или comp(*k, value)==false&amp;&amp; comp(value, *k)==false. ƒелаетс€ максимум 2*log(last-first)+1 сравнений.</p>
     <p><code>template Лclass ForwardIterator, class TЫ</code></p>
     <p><code>ForwardIterator binary_search(ForwardIterator first, ForwardIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template Лclass ForwardIterator, class T, class CompareЫ</code></p>
     <p><code>ForwardIterator binary_search(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);</code></p>
     <p>binary_search возвращает истину, если в диапазоне [first, last) имеетс€ итератор i, который удовлетвор€ет соответствующим услови€м: !(*i Л value)&amp;&amp;!(value Л *i) или comp(*i, value)==false&amp;&amp;comp(value, *i)==false. ƒелаетс€ максимум log(last-first)+2 сравнений.</p>
    </section>
    <section>
     <title>
      <p>ќбъединение (Merge)</p>
     </title>
     <p><code>template Лclass InputIterator1, class Input Iterator2, class OutputIteratorЫ</code></p>
     <p><code>OutputIterator merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator1, class InputIterator2, class OutputIterator, class CompareЫ</code></p>
     <p><code>OutputIterator merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);</code></p>
     <p>merge объедин€ет два сортированных диапазона [first1, last1) и [first2, last2) в диапазон [result, result+(last1-first1)+(last2-first2)). ќбъединение устойчиво, то есть дл€ равных элементов в двух диапазонах элементы из первого диапазона всегда предшествуют элементам из второго. merge возвращает result+(last1-first1)+(last2-first2). ¬ыполн€етс€ максимально (last1-first1)+(last2-first2)-1 сравнений. –езультат merge не определЄн, если возникающий в результате диапазон перекрываетс€ с любым из первоначальных диапазонов.</p>
     <p><code>template Лclass BidirectionalIteratorЫ</code></p>
     <p><code>void inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass BidirectionalIterator, class CompareЫ</code></p>
     <p><code>void inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);</code></p>
     <p>inplace_merge объедин€ет два сортированных последовательных диапазона [first, middle) и [middle, last), помеща€ результат объединени€ в диапазон [first, last). ќбъединение устойчиво, то есть дл€ равных элементов в двух диапазонах элементы из первого диапазона всегда предшествуют элементам из второго.  огда доступно достаточно дополнительной пам€ти, выполн€етс€ максимально (last-first)-1 сравнений. ≈сли никака€ дополнительна€ пам€ть не доступна, может использоватьс€ алгоритм со сложностью O(NlogN).</p>
    </section>
    <section>
     <title>
      <p>ќперации над множеством дл€ сортированных структур (Set operations on sorted structures)</p>
     </title>
     <p>Ётот раздел определ€ет все основные операции над множеством дл€ сортированных структур. ќни даже работают с множествами с дубликатами, содержащими множественные копии равных элементов. —емантика операций над множеством обобщена на множества с дубликатами стандартным способом, определ€€ объединение, содержащее максимальное число местонахождений каждого элемента, пересечение, содержащее минимум, и так далее.</p>
     <p><code>template Лclass InputIterator1, class InputIterator2Ы</code></p>
     <p><code>bool includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator1, class InputIterator2, class CompareЫ</code></p>
     <p><code>bool includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);</code></p>
     <p>includes возвращает true, если каждый элемент в диапазоне [first2, last2) содержитс€ в диапазоне [first1, last1). »наче возвращаетс€ false. ¬ыполн€етс€ максимально ((last1-first1)+(last2-first2))*2-1 сравнений.</p>
     <p><code>template Лclass InputIterator1, class InputIterator2, class OutputIteratorЫ</code></p>
     <p><code>OutputIterator set_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator1, class InputIterator2, class OutputIterator, class CompareЫ</code></p>
     <p><code>OutputIterator set_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);</code></p>
     <p>set_union создаЄт сортированное объединение элементов из двух диапазонов. ќн возвращает конец созданного диапазона. set_union устойчив, то есть, если элемент присутствует в обоих диапазонах, он копируетс€ из первого диапазона. ¬ыполн€етс€ максимально ((last1-first1)+(last2-first2))*2-1 сравнений. –езультат set_union не определЄн, если возникающий в результате диапазон перекрываетс€ с любым из первоначальных диапазонов.</p>
     <p><code>template Лclass InputIterator1, class InputIterator2, class OutputIteratorЫ</code></p>
     <p><code>OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator1, class InputIterator2, class OutputIterator, class CompareЫ</code></p>
     <p><code>OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);</code></p>
     <p>set_intersection создаЄт сортированное пересечение элементов из двух диапазонов. ќн возвращает конец созданного диапазона. √арантируетс€, что set_intersection устойчив, то есть, если элемент присутствует в обоих диапазонах, он копируетс€ из первого диапазона. ¬ыполн€етс€ максимально ((last1-first1)+(last2-first2))*2-1 сравнений. –езультат set_union не определЄн, если возникающий в результате диапазон перекрываетс€ с любым из первоначальных диапазонов.</p>
     <p><code>template Лclass InputIterator1, class InputIterator2, class OutputIteratorЫ</code></p>
     <p><code>OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator1, class InputIterator2, class OutputIterator, class CompareЫ</code></p>
     <p><code>OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);</code></p>
     <p>set_difference создаЄт сортированную разность элементов из двух диапазонов. ќн возвращает конец созданного диапазона. ¬ыполн€етс€ максимально ((last1-first1)+(last2-first2))*2-† сравнений. –езультат set_difference не определЄн, если возникающий в результате диапазон перекрываетс€ с любым из первоначальных диапазонов.</p>
     <p><code>template Лclass InputIterator1, class InputIterator2, class OutputIteratorЫ</code></p>
     <p><code>OutputIterator set_symmetric_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator1, class InputIterator2, class OutputIterator, class CompareЫ</code></p>
     <p><code>OutputIterator set_symmetric_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);</code></p>
     <p>set_symmetric_difference создаЄт сортированную симметричную разность элементов из двух диапазонов. ќн возвращает конец созданного диапазона. ¬ыполн€етс€ максимально ((last1-first1)+(last2-first2))*2-1 сравнений. –езультат set_symmetric_difference не определЄн, если возникающий в результате диапазон перекрываетс€ с любым из первоначальных диапазонов.</p>
    </section>
    <section>
     <title>
      <p>ќперации над пирамидами (Heap operations)</p>
     </title>
     <p>ѕирамида - специфическа€ организаци€ элементов в диапазоне между двум€ итераторами произвольного доступа [a, b). ƒва еЄ ключевые свойства: (1) *a - самый большой элемент в диапазоне, (2) *a может быть удалЄн с помощью pop_heap или новый элемент добавлен с помощью push_heap за O(logN) врем€. Ёти свойства делают пирамиды полезными дл€ приоритетных очередей. make_heap преобразовывает диапазон в пирамиду, a sort_heap превращает пирамиду в сортированную последовательность.</p>
     <p><code>template Лclass RandomAccessIteratorЫ</code></p>
     <p><code>void push_heap(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class CompareЫ</code></p>
     <p><code>void push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
     <p>push_heap полагает, что диапазон [first, last-1) €вл€етс€ соответствующей пирамидой, и надлежащим образом помещает значение с позиции last-1 в результирующую пирамиду [first, last). ¬ыполн€етс€ максимально log(last-first) сравнений.</p>
     <p><code>template Лclass RandomAccessIteratorЫ</code></p>
     <p><code>void pop_heap(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class CompareЫ</code></p>
     <p><code>void pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
     <p>pop_heap полагает, что диапазон [first, last) €вл€етс€ соответствующей пирамидой, затем обменивает значени€ в позици€х first и last-1 и превращает [first, last-1) в пирамиду. ¬ыполн€етс€ максимально 2*log(last-first) сравнений.</p>
     <p><code>template Лclass RandomAccessIteratorЫ</code></p>
     <p><code>void make_heap(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class CompareЫ</code></p>
     <p><code>void make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
     <p>make_heap создает пирамиду из диапазона [first, last). ¬ыполн€етс€ максимально 3*(last-first) сравнений.</p>
     <p><code>template Лclass RandomAccessIteratorЫ</code></p>
     <p><code>void sort_heap(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class CompareЫ</code></p>
     <p><code>void sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
     <p>sort_heap сортирует элементы в пирамиде [first, last). ¬ыполн€етс€ максимально NlogN сравнений, где N равно last-first. sort_heap не устойчив.</p>
    </section>
    <section>
     <title>
      <p>ћинимум и максимум (Minimum and maximum)</p>
     </title>
     <p><code>template Лclass TЫ</code></p>
     <p><code>const T&amp; min(const T&amp; a, const T&amp; b);</code></p>
     <empty-line/>
     <p><code>template Лclass T, class CompareЫ</code></p>
     <p><code>const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);</code></p>
     <empty-line/>
     <p><code>template Лclass TЫ</code></p>
     <p><code>const T&amp; max(const T&amp; a, const T&amp; b);</code></p>
     <empty-line/>
     <p><code>template Лclass T, class CompareЫ</code></p>
     <p><code>const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);</code></p>
     <p>min возвращает меньшее, а max большее. min и max возвращают первый параметр, когда их параметры равны.</p>
     <p><code>template Лclass ForwardIteratorЫ</code></p>
     <p><code>ForwardIterator max_element(ForwardIterator first, ForwardIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass ForwardIterator, class CompareЫ</code></p>
     <p><code>ForwardIterator max_element(ForwardIterator first, ForwardIterator last, Compare comp);</code></p>
     <p>max_element возвращает первый такой итератор i в диапазоне [first, last), что дл€ любого итератора j в диапазоне [first, last) выполн€ютс€ следующие соответствующие услови€: !(*iЛ*j) или comp(*i, *j)==false. ¬ыполн€етс€ точно max((last-first)-1, 0) соответствующих сравнений.</p>
     <p><code>template Лclass ForwardIteratorЫ</code></p>
     <p><code>ForwardIterator min_element(ForwardIterator first, ForwardIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass ForwardIterator, class CompareЫ</code></p>
     <p><code>ForwardIterator min_element(ForwardIterator first, ForwardIterator last, Compare comp);</code></p>
     <p>min_element возвращает первый такой итератор i в диапазоне [first, last), что дл€ любого итератора j в диапазоне [first, last) выполн€ютс€ следующие соответствующие услови€: !(*jЛ*i) или comp(*j, *i)==false. ¬ыполн€етс€ точно max((last-first)-1, 0) соответствующих сравнений.</p>
    </section>
    <section>
     <title>
      <p>Ћексикографическое сравнение (Lexicographical comparison)</p>
     </title>
     <p><code>template Лclass InputIterator1, class InputIterator2Ы</code></p>
     <p><code>bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator1, class InputIterator2, class CompareЫ</code></p>
     <p><code>bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);</code></p>
     <p>lexicographical_compare возвращает true, если последовательность элементов, определЄнных диапазоном [first1, last1), лексикографически меньше, чем последовательность элементов, определЄнных диапазоном [first2, last2). »наче он возвращает ложь. ¬ыполн€етс€ максимально 2*min((last1-first1), (last2-first2)) сравнений.</p>
    </section>
    <section>
     <title>
      <p>√енераторы перестановок (Permutation generators)</p>
     </title>
     <p><code>template Лclass BidirectionalIteratorЫ</code></p>
     <p><code>bool next_permutation(BidirectionalIterator first, BidirectionalIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass BidirectionalIterator, class CompareЫ</code></p>
     <p><code>bool next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);</code></p>
     <p>next_permutation берЄт последовательность, определЄнную диапазоном [first, last), и трансформирует еЄ в следующую перестановку. —ледующа€ перестановка находитс€, полага€, что множество всех перестановок лексикографически сортировано относительно operatorЛ или comp. ≈сли така€ перестановка существует, возвращаетс€ true. »наче он трансформирует последовательность в самую маленькую перестановку, то есть сортированную по возрастанию, и возвращает false. ћаксимально выполн€етс€ (last-first)/2 перестановок.</p>
     <p><code>template Лclass BidirectionalIteratorЫ</code></p>
     <p><code>bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last);</code></p>
     <empty-line/>
     <p><code>template Лclass BidirectionalIterator, class CompareЫ</code></p>
     <p><code>bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);</code></p>
     <p>prev_permutation берЄт последовательность, определЄнную диапазоном [first, last), и трансформирует еЄ в предыдущую перестановку. ѕредыдуща€ перестановка находитс€, полага€, что множество всех перестановок лексикографически сортировано относительно operatorЛ или comp. ≈сли така€ перестановка существует, возвращаетс€ true. »наче он трансформирует последовательность в самую большую перестановку, то есть сортированную по убыванию, и возвращает false. ћаксимально выполн€етс€ (last - first)/2 перестановок.</p>
    </section>
   </section>
   <section>
    <title>
     <p>ќбобщЄнные численные операции (Generalized numeric operations)</p>
    </title>
    <section>
     <title>
      <p>Ќакопление (Accumulate)</p>
     </title>
     <p><code>template Лclass InputIterator, class TЫ</code></p>
     <p><code>T accumulate(InputIterator first, InputIterator last, T init);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator, class T, class BinaryOperationЫ</code></p>
     <p><code>T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);</code></p>
     <p>accumulate подобен оператору APL <emphasis>reduction</emphasis> и функции Common Lisp <emphasis>reduce</emphasis>, но он избегает трудности определени€ результата уменьшени€ дл€ пустой последовательности, всегда требу€ начальное значение. Ќакопление выполн€етс€ инициализацией сумматора acc начальным значением init и последующим изменением его acc = acc+*i или acc = binary_op(acc, *i) дл€ каждого итератора i в диапазоне [first, last) по пор€дку. ѕредполагаетс€, что binary_op не вызывает побочных эффектов.</p>
    </section>
    <section>
     <title>
      <p>—кал€рное произведение (Inner product)</p>
     </title>
     <p><code>template Лclass InputIterator1, class InputIterator2, class TЫ</code></p>
     <p><code>T inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator1, class InputIterator2, class T, class BinaryOperation1, class BinaryOperation2Ы</code></p>
     <p><code>T inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);</code></p>
     <p>inner_product вычисл€ет свой результат, инициализиру€ сумматор acc начальным значением init и затем измен€€ его acc = acc+(*i1)*(*i2) или acc = binary_op1(acc, binary_op2(*i1, *i2)) дл€ каждого итератора i1 в диапазоне [first, last) и итератора i2 в диапазоне [first2, first2+(last-first)) по пор€дку. ѕредполагаетс€, что binary_op1 и binary_op2 не вызывают побочных эффектов.</p>
    </section>
    <section>
     <title>
      <p>„астична€ сумма (Partial sum)</p>
     </title>
     <p><code>template Лclass InputIterator, class OutputIteratorЫ</code></p>
     <p><code>OutputIterator partial_sum(InputIterator first, InputIterator last, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator, class OutputIterator, class BinaryOperationЫ</code></p>
     <p><code>OutputIterator partial_sum(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op);</code></p>
     <p>partial_sum присваивает каждому итератору i в диапазоне [result, result+(last-first)) значение, соответственно равное ((Е(*first+*(first+1))+Е)+*(first+(i-result))) или binary_op(binary_op(Е, binary_op(*first, *(first+1)),Е), *(first+(i-result))). ‘ункци€ partial_sum возвращает result+(last-first). ¬ыполн€етс€ binary_op точно (last-first)-1 раз. ќжидаетс€, что binary_op не имеет каких-либо побочных эффектов. result может быть равен first.</p>
    </section>
    <section>
     <title>
      <p>—межна€ разность (Adjacent difference)</p>
     </title>
     <p><code>template Лclass InputIterator, class OutputIteratorЫ</code></p>
     <p><code>OutputIterator adjacent_difference(InputIterator first, InputIterator last, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template Лclass InputIterator, class OutputIterator, class BinaryOperationЫ</code></p>
     <p><code>OutputIterator adjacent_difference(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op);</code></p>
     <p>adjacent_difference присваивает каждому элементу, указываемому итератором i в диапазоне [result+1, result+(last-first)) значение, соответственно равное *(first+(i-result))-*(first+(i-result)-1) или binary_op(*(first+(i-result)), *(first+(i-result)-1)). Ёлемент, указываемый result, получает значение *first. ‘ункци€ adjacent_difference возвращает result+(last-first). ѕримен€етс€ binary_op точно (last-first)-1 раз. ќжидаетс€, что binary_op не имеет каких-либо побочных эффектов. result может быть равен first.</p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>јƒјѕ“≈–џ</p>
   </title>
   <section>
    <p>јдаптеры - шаблонные классы, которые обеспечивают отображени€ интерфейса. Ќапример, insert_iterator обеспечивает контейнер интерфейсом итератора вывода.</p>
   </section>
   <section>
    <title>
     <p>јдаптеры контейнеров (Container adaptors)</p>
    </title>
    <section>
     <p>„асто бывает полезно обеспечить ограниченные интерфейсы контейнеров. Ѕиблиотека предоставл€ет stack, queue и priority_queue через адаптеры, которые могут работать с различными типами последовательностей.</p>
    </section>
    <section>
     <title>
      <p>—тек (Stack)</p>
     </title>
     <p>Ћюба€ последовательность, поддерживающа€ операции back, push_back и pop_back, может использоватьс€ дл€ модификации stack. ¬ частности, могут использоватьс€ vector, list и deque.</p>
     <p><code>template Лclass ContainerЫ</code></p>
     <p><code>class stack {</code></p>
     <p><code>†friend bool operator==(const stackЛContainerЫ&amp; х, const stackЛContainerЫ&amp; y);</code></p>
     <p><code>†friend bool operatorЛ(const stackЛContainerЫ&amp; х, const stackЛContainerЫ&amp; y);</code></p>
     <p><code>public:</code></p>
     <p><code>†typedef Container::value_type value_type;</code></p>
     <p><code>†typedef Container::size_type size_type;</code></p>
     <p><code>protected:</code></p>
     <p><code>†Container c;</code></p>
     <p><code>public:</code></p>
     <p><code>†bool empty() const {return c.empty();}</code></p>
     <p><code>†size_type size() const {return c.size();}</code></p>
     <p><code>†value_type&amp; top() {return c.back();}</code></p>
     <p><code>†const value_type&amp; top() const {return c.back();}</code></p>
     <p><code>†void push(const value_type&amp; х) {с.push_back(х);}</code></p>
     <p><code>†void pop() {c.pop_back();}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass ContainerЫ</code></p>
     <p><code>bool operator==(const stack ЛContainerЫ&amp; х, const stackЛContainerЫ&amp; y) {return х.с†== у.с;}</code></p>
     <empty-line/>
     <p><code>template Лclass ContainerЫ</code></p>
     <p><code>bool operatorЛ(const stackЛContainerЫ&amp; х, const stackЛContainerЫ&amp; y) {return х.с Л у.с;}</code></p>
     <p>Ќапример, stackЛvectorЛintЫ Ы - целочисленный стек, сделанный из vector, а stackЛdequeЛcharЫ Ы - символьный стек, сделанный из deque.</p>
    </section>
    <section>
     <title>
      <p>ќчередь (Queue)</p>
     </title>
     <p>Ћюба€ последовательность, поддерживающа€ операции front, push_back и pop_front, может использоватьс€ дл€ модификации queue. ¬ частности, могут использоватьс€ list и deque.</p>
     <p><code>template Лclass ContainerЫ</code></p>
     <p><code>class queue {</code></p>
     <p><code>†friend bool operator==(const queueЛContainerЫ&amp; х, const queueЛContainerЫ&amp; y);</code></p>
     <p><code>†friend bool operatorЛ(const queueЛContainerЫ&amp; х, const queueЛContainerЫ&amp; y);</code></p>
     <p><code>public:</code></p>
     <p><code>†typedef Container::value_type value_type;</code></p>
     <p><code>†typedef Container::size_type size_type;</code></p>
     <p><code>protected:</code></p>
     <p><code>†Container c;</code></p>
     <p><code>public:</code></p>
     <p><code>†bool empty() const {return c.empty();}</code></p>
     <p><code>†size_type size() const {return c.size();}</code></p>
     <p><code>†value_type&amp; front() {return c.front();}</code></p>
     <p><code>†const value_type&amp; front() const {return c.front();}</code></p>
     <p><code>†value_type&amp; back() {return c.back();}</code></p>
     <p><code>†const value_type&amp; back() const {return c.back();}</code></p>
     <p><code>†void push(const value_type&amp; х) {с.push_back(х);}</code></p>
     <p><code>†void pop() {с.pop_front();}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass ContainerЫ</code></p>
     <p><code>bool operator==(const queueЛContainerЫ&amp; х, const queueЛContainerЫ&amp; y) {return х.с†== у.с;}</code></p>
     <empty-line/>
     <p><code>template Лclass ContainerЫ</code></p>
     <p><code>bool operatorЛ(const queueЛContainerЫ&amp; х, const queueЛContainerЫ&amp; y) {return х.с Л у.с;}</code></p>
    </section>
    <section>
     <title>
      <p>ќчередь с приоритетами (Priority queue)</p>
     </title>
     <p>Ћюба€ последовательность, с итератором произвольного доступа и поддерживающа€ операции front, push_back и pop_front, может использоватьс€ дл€ модификации priority_queue. ¬ частности, могут использоватьс€ vector и deque.</p>
     <p><code>template Лclass Container, class Compare = lessЛContainer::value_typeЫ Ы</code></p>
     <p><code>class priority_queue {</code></p>
     <p><code>public:</code></p>
     <p><code>†typedef Container::value_type value_type;</code></p>
     <p><code>†typedef Container::size_type size_type;</code></p>
     <p><code>protected:</code></p>
     <p><code>†Container c;</code></p>
     <p><code>†Compare comp;</code></p>
     <p><code>public:</code></p>
     <p><code>†priority_queue(const Compare&amp; х = Compare()): c(), comp(х) {}</code></p>
     <p><code>†template Лclass InputIteratorЫ</code></p>
     <p><code>†priority_queue(InputIterator first, InputIterator last,</code></p>
     <p><code>†const Compare&amp; х = Compare()): c(first, last), comp(x) {make_heap(c.begin(), с.end(), comp);}</code></p>
     <p><code>†bool empty() const {return c.empty();}</code></p>
     <p><code>†size_type size() const {return c.size();}</code></p>
     <p><code>†const value_type&amp; top() const {return c.front();}</code></p>
     <p><code>†void push(const value_type&amp; х) {</code></p>
     <p><code>† c.push_back(х);</code></p>
     <p><code>† push_heap(c.begin(), c.end(), comp);</code></p>
     <p><code>†}</code></p>
     <p><code>†void pop() {</code></p>
     <p><code>† pop_heap(c.begin(), c.end(), comp);</code></p>
     <p><code>† с.рор_bасk();</code></p>
     <p><code>†}</code></p>
     <p><code>}; // Ќикакое равенство не обеспечиваетс€</code></p>
    </section>
   </section>
   <section>
    <title>
     <p>јдаптеры итераторов (Iterator adaptors)</p>
    </title>
    <section>
     <title>
      <p>ќбратные итераторы (Reverse iterators)</p>
     </title>
     <p>ƒвунаправленные итераторы и итераторы произвольного доступа имеют соответствующие адаптеры обратных итераторов, которые выполн€ют итерации через структуру данных в противоположном направлении.ќни имеют те же самые сигнатуры, как и соответствующие итераторы. ‘ундаментальное соотношение между обратным итератором и его соответствующим итератором i установлено тождеством &amp;*(reverse_iterator(i))==&amp;*(i - 1). Ёто отображение продиктовано тем, что, в то врем€ как после конца массива всегда есть указатель, может не быть допустимого указател€ перед началом массива.</p>
     <p><code>template Лclass BidirectionalIterator, class T, class Reference = T&amp;, class Distance = ptrdiff_tЫ</code></p>
     <p><code>class reverse_bidirectionaiIterator : public bidirectional_iteratorЛT, DistanceЫ {</code></p>
     <p><code>†typedef reverse_bidirectional_iteratorЛBidirectionalIterator, T, Reference, DistanceЫ self;</code></p>
     <p><code>†friend bool operator==(const self&amp; х, const self&amp; y);</code></p>
     <p><code>protected:</code></p>
     <p><code>†BidirectionalIterator current;</code></p>
     <p><code>public:</code></p>
     <p><code>†reverse_bidirectional_iterator() {}</code></p>
     <p><code>†reverse_bidirectional_iterator(BidirectionalIterator х) : current(х) {}</code></p>
     <p><code>†BidirectionalIterator base() {return current;}</code></p>
     <p><code>†Reference operator*() const {</code></p>
     <p><code>† BidirectionalIterator tmp = current;</code></p>
     <p><code>† return *--tmp;</code></p>
     <p><code>†}</code></p>
     <p><code>†self&amp; operator++() {</code></p>
     <p><code>† --current;</code></p>
     <p><code>† return *this;</code></p>
     <p><code>†}</code></p>
     <p><code>†self operator++(int) {</code></p>
     <p><code>† self tmp = *this;</code></p>
     <p><code>† --current;</code></p>
     <p><code>† return tmp;</code></p>
     <p><code>†}</code></p>
     <p><code>†self&amp; operator--() {</code></p>
     <p><code>† ++current;</code></p>
     <p><code>† return *this;</code></p>
     <p><code>†}</code></p>
     <p><code>†self operator--(int) {</code></p>
     <p><code>† self tmp = *this;</code></p>
     <p><code>† ++current;</code></p>
     <p><code>† return tmp;</code></p>
     <p><code>†}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass BidirectionalIterator, class T, class Reference, class DistanceЫ</code></p>
     <p><code>inline bool operator==(const reverse_bidirectional_iteratorЛBidirectionalIterator, T, Reference, DistanceЫ&amp; x, const reverse_bidirectional_iteratorЛBidirectionalIterator,</code></p>
     <p><code>T, Reference, DistanceЫ&amp; y) {</code></p>
     <p><code>†return x.current==y.current;</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class T, class Reference = T&amp;, class Distance = ptrdiff_tЫ</code></p>
     <p><code>class reverse_iterator: public random_access_iteratorЛT, DistanceЫ {</code></p>
     <p><code>†typedef reverse_iteratorЛRandomAccessIterator, T, Reference, DistanceЫ self;</code></p>
     <p><code>†friend bool operator==(const self&amp; x, const self&amp; y);</code></p>
     <p><code>†friend bool operatorЛ(const self&amp; x, const self&amp; y);</code></p>
     <p><code>†friend Distance operator-(const self&amp; x, const self&amp; y);</code></p>
     <p><code>†friend self operator+(Distance n, const self&amp; x);</code></p>
     <p><code>protected:</code></p>
     <p><code>†RandomAccessIterator current;</code></p>
     <p><code>public:</code></p>
     <p><code>†reverse_iterator() {}</code></p>
     <p><code>†reverse_iterator(RandomAccessIterator x): current (x) {}</code></p>
     <p><code>†RandomAccessIterator base() {return current;}</code></p>
     <p><code>†Reference operator*() const {</code></p>
     <p><code>† RandomAccessIterator tmp = current;</code></p>
     <p><code>† return *--tmp;</code></p>
     <p><code>†}</code></p>
     <p><code>†self&amp; operator++() {</code></p>
     <p><code>† --current;</code></p>
     <p><code>† return *this;</code></p>
     <p><code>†}</code></p>
     <p><code>†self operator++(int) {</code></p>
     <p><code>† self tmp = *this;</code></p>
     <p><code>† --current;</code></p>
     <p><code>† return tmp; </code></p>
     <p><code>†}</code></p>
     <p><code>†self&amp; operator--() {</code></p>
     <p><code>† ++current;</code></p>
     <p><code>† return *this;</code></p>
     <p><code>†}</code></p>
     <p><code>†self operator--(int) {</code></p>
     <p><code>† self tmp = *this;</code></p>
     <p><code>† ++current;</code></p>
     <p><code>† return tmp;</code></p>
     <p><code>†}</code></p>
     <p><code>†self operator+(Distance n) const {</code></p>
     <p><code>† return self(current - n);</code></p>
     <p><code>†}</code></p>
     <p><code>†self&amp; operator+=(Distance n) {</code></p>
     <p><code>† current -= n;</code></p>
     <p><code>† return *this;</code></p>
     <p><code>†}</code></p>
     <p><code>†self operator-(Distance n) const {</code></p>
     <p><code>† return self(current + n);</code></p>
     <p><code>†}</code></p>
     <p><code>†self operator-=(Distance n) {</code></p>
     <p><code>† current += n;</code></p>
     <p><code>† return *this;</code></p>
     <p><code>†}</code></p>
     <p><code>†Reference operator[](Distance n) {return *(*this + n);}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class T, class Reference, class DistanceЫ</code></p>
     <p><code>inline bool operator==(const reverse_iteratorЛRandomAccessIterator, T, Reference, DistanceЫ&amp; x, const reverse_iteratorЛRandomAccessIterator, T, Reference, DistanceЫ&amp; y) {</code></p>
     <p><code>†return x.current†== y.current;</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class T, class Reference, class DistanceЫ</code></p>
     <p><code>inline bool operatorЛ(const reverse_iteratorЛRandomAccessIterator, T, Reference, DistanceЫ&amp; x, const reverse_iteratorЛRandomAccessIterator, T, Reference, DistanceЫ&amp; y) {</code></p>
     <p><code>†return y.current Л x.current;</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class T, class Reference, class DistanceЫ</code></p>
     <p><code>inline Distance operator-(const reverse_iteratorЛRandomAccessIterator, T, Reference, DistanceЫ&amp; х, const reverse_iteratorЛRandomAccessIterator, T, Reference, DistanceЫ&amp; y) {</code></p>
     <p><code>†return y.current - x.current;</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template Лclass RandomAccessIterator, class T, class Reference, class DistanceЫ</code></p>
     <p><code>inline reverse_iteratorЛRandomAccessIterator, T, Reference, DistanceЫ operator+(Distance n, const reverse_iteratorЛRandomAccessIterator, T, Reference, DistanceЫ&amp; x) {</code></p>
     <p><code>†return reverse_iteratorЛRandomAccessIterator, T, Reference, DistanceЫ(x.current - n);</code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>»тераторы вставки (Insert iterators)</p>
     </title>
     <p>„тобы было возможно иметь дело с вставкой таким же образом, как с записью в массив, в библиотеке обеспечиваетс€ специальный вид адаптеров итераторов, называемых <emphasis>итераторами вставки</emphasis> (<emphasis>insert iterators</emphasis>). — обычными классами итераторов</p>
     <p><code>while (first!= last) *result++ = *first++;</code></p>
     <p>вызывает копирование диапазона [first, last) в диапазон, начинающийс€ с result. “от же самый код с result, €вл€ющимс€ итератором вставки, вставит соответствующие элементы в контейнер. “акой механизм позвол€ет всем алгоритмам копировани€ в библиотеке работать в <emphasis>режиме вставки</emphasis> (<emphasis>insert mode</emphasis>) вместо обычного режима наложени€ записей.</p>
     <p>»тератор вставки создаЄтс€ из контейнера и, возможно, одного из его итераторов, указывающих, где вставка происходит, если это ни в начале, ни в конце контейнера. »тераторы вставки удовлетвор€ют требовани€м итераторов вывода. operator* возвращает непосредственно сам итератор вставки. ѕрисваивание operator=(const T&amp; х) определено дл€ итераторов вставки, чтобы разрешить запись в них, оно вставл€ет х пр€мо перед позицией, куда итератор вставки указывает. ƒругими словами, итератор вставки подобен курсору, указывающему в контейнер, где происходит вставка. back_insert_iterator вставл€ет элементы в конце контейнера, front_insert_iterator вставл€ет элементы в начале контейнера, а insert_iterator вставл€ет элементы, куда итератор указывает в контейнере. back_inserter, front_inserter и inserter - три функции, создающие итераторы вставки из контейнера.</p>
     <p><code>template Лclass ContainerЫ</code></p>
     <p><code>class back_insert_iterator: public output_iterator {</code></p>
     <p><code>protected:</code></p>
     <p><code>†Container&amp; container;</code></p>
     <p><code>public:</code></p>
     <p><code>†back_insert_iterator(Container&amp; x): container(x) {}</code></p>
     <p><code>†back_insert_iterator ЛContainerЫ&amp;††operator=(const Container::value_type&amp; value) {</code></p>
     <p><code>† container.push_back(value);</code></p>
     <p><code>† return *this;</code></p>
     <p><code>†}</code></p>
     <p><code>†back_insert_iteratorЛContainerЫ&amp; operator*() {return *this;}</code></p>
     <p><code>†back_insert_iteratorЛContainerЫ&amp; operator++() {return *this;}</code></p>
     <p><code>†back_insert_iteratorЛContainerЫ&amp; operator++(int) {return *this;}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass ContainerЫ</code></p>
     <p><code>back_insert_iteratorЛContainerЫ back_inserter(Container&amp; x) {</code></p>
     <p><code>†return back_insert_iteratorЛContainerЫ(x);</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template Лclass ContainerЫ</code></p>
     <p><code>class front_insert_iterator: public output_iterator {</code></p>
     <p><code>protected:</code></p>
     <p><code>†Container&amp; container;</code></p>
     <p><code>public:</code></p>
     <p><code>†front_insert_iterator(Container&amp; x): container (x) {}</code></p>
     <p><code>†front_insert_iteratorЛContainerЫ&amp; operator=(const Container::value_type&amp; value) {</code></p>
     <p><code>† container.push_front(value);</code></p>
     <p><code>† return *this;</code></p>
     <p><code>†}</code></p>
     <p><code>†front_insert_iteratorЛContainerЫ&amp; operator*() {return *this;}</code></p>
     <p><code>†front_insert_iteratorЛContainerЫ&amp; operator++() {return *this;}</code></p>
     <p><code>†front_insert_iteratorЛContainerЫ&amp; operator++(int) {return *this;}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass ContainerЫ</code></p>
     <p><code>front_insert_iteratorЛContainerЫ front_inserter(Container&amp; x) {</code></p>
     <p><code>†return front_insert_iteratorЛContainerЫ(х);</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template Лclass ContainerЫ</code></p>
     <p><code>class insert_iterator: public output_iterator {</code></p>
     <p><code>protected:</code></p>
     <p><code>†Container&amp; container;</code></p>
     <p><code>†Container::iterator iter;</code></p>
     <p><code>public:</code></p>
     <p><code>†insert_iterator(Container&amp; x, Container::iterator i) : container (x), iter(i) {}</code></p>
     <p><code>†insert_iteratorЛContainerЫ&amp; operator=(const Container::value_type&amp; value) {</code></p>
     <p><code>† iter = container.insert(iter, value);</code></p>
     <p><code>† ++iter;</code></p>
     <p><code>† return *this;</code></p>
     <p><code>†}</code></p>
     <p><code>†insert_iteratorЛContainerЫ&amp; operator*() {return *this;}</code></p>
     <p><code>†insert_iteratorЛContainerЫ&amp; operator++() {return *this;}</code></p>
     <p><code>†insert_iteratorЛContainerЫ&amp; operator++(int) {return *this;}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass Container, class IteratorЫ</code></p>
     <p><code>insert_iterator&lt;ContainerЫ inserter(Container&amp; x, Iterator i) {</code></p>
     <p><code>†return insert_iteratorЛContainerЫ(x, Container::iterator(i));</code></p>
     <p><code>}</code></p>
    </section>
   </section>
   <section>
    <title>
     <p>јдаптеры функций (Function adaptors)</p>
    </title>
    <section>
     <p>‘ункциональные адаптеры работают только с классами функциональных объектов с определЄнными типами параметров и типом результата.</p>
    </section>
    <section>
     <title>
      <p>ќтрицатели (Negators)</p>
     </title>
     <p>ќтрицатели not1 и not2 берут унарный и бинарный предикаты соответственно и возвращают их дополнени€.</p>
     <p><code>template Лclass PredicateЫ</code></p>
     <p><code>class unary_negate: public unary_functionЛPredicate::argument_type, boolЫ {</code></p>
     <p><code>protected:</code></p>
     <p><code>†Predicate pred;</code></p>
     <p><code>public:</code></p>
     <p><code>†unary_negate(const Predicate&amp; x): pred(x) {}</code></p>
     <p><code>†bool operator()(const argument_type&amp; x) const {return !pred(x);}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass PredicateЫ</code></p>
     <p><code>unary_negateЛPredicateЫ not1(const Predicate&amp; pred) {</code></p>
     <p><code>†return unary_negateЛPredicateЫ(pred);</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template Лclass PredicateЫ</code></p>
     <p><code>class binary_negate: public binary_functionЛPredicate::first_argument_type, Predicate::second_argument_type, boolЫ {</code></p>
     <p><code>protected:</code></p>
     <p><code>†Predicate pred;</code></p>
     <p><code>public:</code></p>
     <p><code>†binary_negate(const Predicate&amp; x): pred(x) {}</code></p>
     <p><code>†bool operator()(const first_argument_type&amp; x, const second_argument_type&amp; y) const {</code></p>
     <p><code>† return !pred(x, y);</code></p>
     <p><code>†}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass PredicateЫ</code></p>
     <p><code>binary_negateЛPredicateЫ not2(const Predicate&amp; pred) {</code></p>
     <p><code>†return binary_negateЛPredicateЫ(pred);</code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>ѕрив€зки (Binders)</p>
     </title>
     <p>ѕрив€зки bind1st и bind2nd берут функциональный объект f двух параметров и значение x и возвращают функциональный объект одного параметра, созданный из f с первым или вторым параметром соответственно, св€занным с х.</p>
     <p><code>template Лclass PredicateЫ</code></p>
     <p><code>class binder1st: public unary_function {</code></p>
     <p><code>protected:</code></p>
     <p><code>†Operation op;</code></p>
     <p><code>†Operation::first_argument_type value;</code></p>
     <p><code>public:</code></p>
     <p><code>†binder1st(const Operation&amp; x, const Operation::first_argument_type&amp; y) : op(x), value(y) {}</code></p>
     <p><code>†result_type operator()(const argument_type&amp; x) const {</code></p>
     <p><code>† return op(value, x);</code></p>
     <p><code>†}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass Operation, class TЫ</code></p>
     <p><code>binder1stЛOperationЫ bind1st(const Operation&amp; op, const T&amp; x) {</code></p>
     <p><code>†return binder1stЛOperationЫ(op, Operation::first_argument_type(x));</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template Лclass OperationЫ</code></p>
     <p><code>class binder2nd: public unary_functionЛ0peration::first_argument_type, Operation::result_typeЫ {</code></p>
     <p><code>protected:</code></p>
     <p><code>†Operation op;</code></p>
     <p><code>†Operation::second_argument_type value;</code></p>
     <p><code>public:</code></p>
     <p><code>†binder2nd(const Operation&amp; x, const Operation::second_argument_type&amp; y) : op(x), value(y) {}</code></p>
     <p><code>†result_type operator()(const argument_type&amp; x) const {</code></p>
     <p><code>† return op(x, value);</code></p>
     <p><code>†}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass Operation, class TЫ</code></p>
     <p><code>binder2ndЛOperationЫ bind2nd(const Operation&amp; op, const T&amp; x) {</code></p>
     <p><code>†return binder2ndЛ0perationЫ(op, Operation::second_argument_type(x));</code></p>
     <p><code>}</code></p>
     <p>Ќапример, find_if(v.begin(), v.end(), bind2nd(greaterЛintЫ(), 5)) находит первое целое число в векторе v большее, чем 5; find_if(v.begin(), v.end(), bind1st(greaterЛintЫ(), 5)) находит первое целое число в v меньшее, чем 5.</p>
    </section>
    <section>
     <title>
      <p>јдаптеры указателей на функции (Adaptors for pointers to functions)</p>
     </title>
     <p>„тобы позволить указател€м на (унарные и бинарные) функции работать с функциональными адаптерами, библиотека обеспечивает следующее:</p>
     <p><code>template Лclass Arg, class ResultЫ</code></p>
     <p><code>class pointer_to_unary_function: public unary_functionЛArg, ResultЫ {</code></p>
     <p><code>protected:</code></p>
     <p><code>†Result (*ptr)(Arg);</code></p>
     <p><code>public:</code></p>
     <p><code>†pointer_to_unary_function() {}</code></p>
     <p><code>†pointer_to_unary_function(Result (*x)(Arg)): ptr(x) {}</code></p>
     <p><code>†Result operator()(Arg x) const {return ptr(x);}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass Arg, class ResultЫ</code></p>
     <p><code>pointer_to_unary_functionЛArg, ResultЫ ptr_fun(Result (*x)(Arg)) {</code></p>
     <p><code>†return pointer_to_unary_functionЛArg, ResultЫ(x);</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template</code></p>
     <p><code>class pointer_to_binary_function: public binary_function {</code></p>
     <p><code>protected:</code></p>
     <p><code>†Result (*ptr)(Arg1, Arg2);</code></p>
     <p><code>public:</code></p>
     <p><code>†pointer_to_binary_function() {}</code></p>
     <p><code>†pointer_to_binary_function(Result (*x)(Arg1, Arg2)): ptr(х) {}</code></p>
     <p><code>†Result operator()(Arg1 x, Arg2 y) const {return ptr(x, y);}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template Лclass Arg1, class Arg2, class ResultЫ</code></p>
     <p><code>pointer_to_binary_functionЛArg1, Arg2, ResultЫ ptr_fun(Result (*x)(Arg1, Arg2)) {</code></p>
     <p><code>†return pointer_to_binary_functionЛArgl, Arg2, ResultЫ(x);</code></p>
     <p><code>}</code></p>
     <p>Ќапример, replace_if(v.begin(), v.end(), not1(bind2nd(ptr_fun(strcmp), "C")), "C++") замен€ет все "—" на "C++" в последовательности v.</p>
     <p>—истемы трансл€ции, которые имеют множественный указатель на типы функций, должны обеспечить дополнительные шаблоны функций ptr_fun.</p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>ѕримитивы управлени€ пам€тью (Memory Handling Primitives)</p>
   </title>
   <p>„тобы получать типичный указатель на неинициализированный буфер пам€ти данного размера, определена следующа€ функци€:</p>
   <p><code>template Лclass TЫ</code></p>
   <p><code>inline T* allocate(ptrdiff_t n, “*); // n Ы= 0</code></p>
   <p>–азмер (в байтах) распределЄнного буфера - не меньше n*sizeof(T).</p>
   <p>ƒл€ каждой модели пам€ти имеетс€ соответствующий шаблон функции allocate, определЄнный с типом первого параметра, €вл€ющимс€ типом рассто€ни€ указателей в модели пам€ти.</p>
   <p>Ќапример, если система трансл€ции поддерживает _huge указатели с типом рассто€ни€ long long, обеспечиваетс€ следующа€ шаблонна€ функци€:</p>
   <p><code>template Лclass TЫ</code></p>
   <p><code>inline T _huge* allocate(long long n, T _huge *);</code></p>
   <p>“акже обеспечиваютс€ следующие функции:</p>
   <p><code>template Лclass TЫ</code></p>
   <p><code>inline void deallocate(T* buffer);</code></p>
   <empty-line/>
   <p><code>template Лclass T1, class T2Ы</code></p>
   <p><code>inline void construct(T1* p, const T2&amp; value) {new (p) T1(value);}</code></p>
   <empty-line/>
   <p><code>template Лclass TЫ</code></p>
   <p><code>inline void destroy(T* pointer) {pointer-Ы~T();}</code></p>
   <p>deallocate освобождает буфер, выделенный allocate. ƒл€ каждой модели пам€ти имеютс€ соответствующие шаблоны функций deallocate, construct и destroy, определЄнные с типом первого параметра, €вл€ющимс€ типом указател€ в модели пам€ти.</p>
   <p><code>template Лclass TЫ</code></p>
   <p><code>pairЛT*, ptrdiff_tЫ get_temporary_buffer(ptrdiff_t n, T*);</code></p>
   <empty-line/>
   <p><code>template Лclass TЫ</code></p>
   <p><code>void return_temporary_buffer(T* p);</code></p>
   <p>get_temporary_buffer ищет наибольший буфер, не больше чем n*sizeof(T), и возвращает пару, состо€щую из адреса и размера (в единицах sizeof(T)) буфера. return_temporary_buffer возвращает буфер, выделенный get_temporary_buffer.</p>
  </section>
  <section>
   <title>
    <p>ѕ–»ћ≈–џ ѕ–ќ√–јћћ — ЎјЅЋќЌјћ»</p>
   </title>
   <section>
    <p>Ёти примеры демонстрируют использование нового продукта STL ЛToolKitЫ от компании ObjectSpace. STL ЛToolKitЫ - это самый простой способ использовани€ STL, который работает на большинстве комбинаций платформ/компил€торов, включа€ cfront, Borland, Visual C++, Set C++, ObjectCenter и последние компил€торы от Sun&amp;HP.</p>
   </section>
   <section>
    <title>
     <p>accum1.cpp</p>
    </title>
    <p><code>#include Лospace/stl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(5);</code></p>
    <p><code>†for (int i = 0; i Л v.size(); i++) v[i] = i + 1;</code></p>
    <p><code>†int sum = accumulate(v.begin(), v.end(), 0);</code></p>
    <p><code>†cout ЛЛ "sum = " ЛЛ sum ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>accum2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int mult(int initial_, int element_) {</code></p>
    <p><code>†return initial_ * element_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(5);</code></p>
    <p><code>†for (int i = 0; i Л v.size(); i++) v[i] = i + 1;</code></p>
    <p><code>†int prod = accumulate(v.begin(), v.end(), 1, mult);</code></p>
    <p><code>†cout ЛЛ "prod = " ЛЛ prod ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>search2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool str_equal(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_)†== 0 ? 1:0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* grades[] = {"A", "B", "C", "D", "F"};</code></p>
    <p><code>char* letters[] = {"Q", "E", "D"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned gradeCount = sizeof(grades) / sizeof(grades[0]);</code></p>
    <p><code>†const unsigned letterCount = sizeof(letters) / sizeof(letters[0]);</code></p>
    <p><code>†ostream_iterator Лchar*Ы iter(cout, " ");</code></p>
    <p><code>†cout ЛЛ "grades: ";</code></p>
    <p><code>†copy(grades, grades + gradeCount, iter);</code></p>
    <p><code>†cout ЛЛ "\nletters:";</code></p>
    <p><code>†copy(letters, letters + letterCount, iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <empty-line/>
    <p><code>†char** location = search(grades, grades + gradeCount, letters, letters + letterCount, str_equal);</code></p>
    <empty-line/>
    <p><code>†if (location†== grades + gradeCount) cout ЛЛ "letters not found in grades" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "letters found in grades at offset: " ЛЛ location - grades ЛЛ endl;</code></p>
    <p><code>†copy(grades + 1, grades + 1 + letterCount, letters);</code></p>
    <empty-line/>
    <p><code>†cout ЛЛ "grades: ";</code></p>
    <p><code>†copy(grades, grades + gradeCount, iter);</code></p>
    <p><code>†cout ЛЛ "\nletters:";</code></p>
    <p><code>†copy(letters, letters + letterCount, iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <empty-line/>
    <p><code>†location = search(grades, grades + gradeCount, letters, letters + letterCount, str_equal);</code></p>
    <empty-line/>
    <p><code>†if (location†== grades + gradeCount) cout ЛЛ "letters not found in grades" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "letters found in grades at offset: " ЛЛ location - grades ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>incl2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool compare_strings(const char* s1_, const char* s2_) {</code></p>
    <p><code>†return ::strcmp(s1_, s2_) Л 0 ? 1: 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* names[] = {"Todd", "Mike", "Graham", "Jack", "Brett"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned nameSize = sizeof(names)/sizeof(names[0]);</code></p>
    <p><code>†vectorЛchar*Ы v1(nameSize);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) {</code></p>
    <p><code>† v1[i] = names[i];</code></p>
    <p><code>†}</code></p>
    <p><code>†vectorЛchar*Ы v2(2);</code></p>
    <p><code>†v2[0] = "foo";</code></p>
    <p><code>†v2[1] = "bar";</code></p>
    <p><code>†sort(v1.begin(), v1.end(), compare_strings);</code></p>
    <p><code>†sort(v2.begin(), v2.end(), compare_strings);</code></p>
    <empty-line/>
    <p><code>†bool inc = includes(v1.begin(), v1.end(), v2.begin(), v2.end(), compare_strings);</code></p>
    <p><code>†if (inc) cout ЛЛ "v1 includes v2" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "v1 does not include v2" ЛЛ endl;</code></p>
    <p><code>†v2[0] = "Brett";</code></p>
    <p><code>†v2[1] = "Todd";</code></p>
    <p><code>†inc = includes(v1.begin(), v1.end(), v2.begin(), v2.end(), compare_strings);</code></p>
    <p><code>†if (inc) cout ЛЛ "v1 includes v2" ЛЛ endl;</code></p>
    <p><code>†else†cout ЛЛ "v1 does not include v2" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>search1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†typedef vectorЛintЫ IntVec;</code></p>
    <p><code>†IntVec v1(10);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†IntVec v2(3);</code></p>
    <p><code>†iota(v2.begin(), v2.end(), 50);</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <empty-line/>
    <p><code>†cout ЛЛ "v1: ";</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "v2: ";</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <empty-line/>
    <p><code>†IntVec::iterator location;</code></p>
    <p><code>†location = search(v1.begin(), v1.end(), v2.begin(), v2.end());</code></p>
    <p><code>†if (location†== v1.end()) cout ЛЛ "v2 not contained in v1" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "Found v2 in v1 at offset: " ЛЛ location - v1.begin() ЛЛ endl;</code></p>
    <empty-line/>
    <p><code>†iota(v2.begin(), v2.end(), 4);</code></p>
    <p><code>†cout ЛЛ "v1: ";</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "v2: ";</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <empty-line/>
    <p><code>†location = search(v1.begin(), v1.end(), v2.begin(), v2.end());</code></p>
    <p><code>†if (location†== v1.end()) cout ЛЛ "v2 not contained in v1" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "Found v2 in v1 at offset: " ЛЛ location - v1.begin() ЛЛ endl;</code></p>
    <empty-line/>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>istmit2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лfstream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>typedef vectorЛcharЫ Line;</code></p>
    <p><code>void printLine(const Line* line_)† {</code></p>
    <p><code>†vectorЛcharЫ::const_iterator i;</code></p>
    <p><code>†for (i = line_-Ыbegin(); i!= line_-Ыend(); i++) cout ЛЛ *i;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†Line buffer;</code></p>
    <p><code>†vectorЛLine*Ы lines;</code></p>
    <p><code>†ifstream s("data.txt");</code></p>
    <p><code>†s.unsetf(ios::skipws); // Disable white-space skipping.</code></p>
    <p><code>†istream_iteratorЛchar, ptrdiff_tЫ it1(s); // Position at start of file.</code></p>
    <p><code>†istream_iteratorЛchar, ptrdiff_tЫ it2; // Serves as "past-the-end" marker.</code></p>
    <p><code>†copy(it1, it2, back_inserter(buffer));</code></p>
    <p><code>†Line::iterator i = buffer.begin();</code></p>
    <p><code>†Line::iterator p;</code></p>
    <p><code>†while (i != buffer.end()) {</code></p>
    <p><code>† p = find(i, buffer.end(), '\n');</code></p>
    <p><code>† lines.push_back(new Line(i, p));</code></p>
    <p><code>† i = ++p;</code></p>
    <p><code>†}</code></p>
    <p><code>†sort(lines.begin(), lines.end(), less_pЛLine*Ы());</code></p>
    <p><code>†cout ЛЛ "Read " ЛЛ lines.size() ЛЛ " lines" ЛЛ endl;</code></p>
    <p><code>†vectorЛLine*Ы::iterator j;</code></p>
    <p><code>†for(j = lines.begin(); j!= lines.end(); j++) printLine(*j);</code></p>
    <p><code>†release(lines.begin(), lines.end()); // Release memory.</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>alloc1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лospace/stl/examples/myaloc.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†{</code></p>
    <p><code>† cout ЛЛ "vectors:" ЛЛ endl;</code></p>
    <p><code>† os_my_allocatorЛintЫ alloc;</code></p>
    <p><code>† vectorЛintЫ v3(alloc);</code></p>
    <p><code>† v3.push_back(42);</code></p>
    <p><code>† vectorЛintЫ v4(alloc);</code></p>
    <p><code>† v4.push_back(42);</code></p>
    <p><code>†}</code></p>
    <p><code>†{</code></p>
    <p><code>† cout ЛЛ "bit_vectors:" ЛЛ endl;</code></p>
    <p><code>† os_my_allocatorЛunsigned intЫ alloc;</code></p>
    <p><code>† bit_vector v1(alloc);</code></p>
    <p><code>† v1.push_back(1);</code></p>
    <p><code>†}</code></p>
    <p><code>†{</code></p>
    <p><code>† cout ЛЛ "deques:" ЛЛ endl;</code></p>
    <p><code>† os_my_allocatorЛintЫ alloc;</code></p>
    <p><code>† dequeЛintЫ d(alloc);</code></p>
    <p><code>† d.push_back(42);</code></p>
    <p><code>†}</code></p>
    <p><code>†{</code></p>
    <p><code>† cout ЛЛ "lists:" ЛЛ endl;</code></p>
    <p><code>† os_my_allocatorЛos_list_nodeЛintЫ Ы alloc;</code></p>
    <p><code>† listЛintЫ l(alloc);</code></p>
    <p><code>† l.push_back(42);</code></p>
    <p><code>†}</code></p>
    <p><code>†{</code></p>
    <p><code>† cout ЛЛ "sets:" ЛЛ endl;</code></p>
    <p><code>† os_my_allocatorЛos_value_nodeЛintЫ Ы alloc;</code></p>
    <p><code>† setЛint, lessЛintЫ Ы s(alloc);</code></p>
    <p><code>† s.insert(42);</code></p>
    <p><code>†}</code></p>
    <p><code>†{</code></p>
    <p><code>† cout ЛЛ "maps" ЛЛ endl;</code></p>
    <p><code>† os_my_allocatorЛos_value_nodeЛos_pairЛconst int, floatЫ Ы Ы alloc;</code></p>
    <p><code>† mapЛint, float, lessЛintЫ Ы m(alloc);</code></p>
    <p><code>† m[4] = 2.0;</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>release2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>class X {</code></p>
    <p><code>public:</code></p>
    <p><code>†X(int i_): i (i_) {}</code></p>
    <p><code>†~X() {cout ЛЛ "Delete X(" ЛЛ i ЛЛ ")" ЛЛ endl;}</code></p>
    <p><code>†int i;</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>ostream&amp; operator ЛЛ (ostream&amp; stream_, const X&amp; x_) {</code></p>
    <p><code>†return stream_ ЛЛ "X(" ЛЛ x_.i ЛЛ ")";</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛX*Ы v;</code></p>
    <p><code>†v.push_back(new X(2));</code></p>
    <p><code>†v.push_back(new X(1));</code></p>
    <p><code>†v.push_back(new X(4));</code></p>
    <p><code>†vectorЛX*Ы::iterator i;</code></p>
    <p><code>†cout ЛЛ "Initial contents:" ЛЛ endl;</code></p>
    <p><code>†for (i = v.begin(); i!= v.end(); i++) cout ЛЛ " " ЛЛ *(*i) ЛЛ endl;</code></p>
    <p><code>†release(v.begin()); // Delete the first heap-based object.</code></p>
    <p><code>†v.erase(v.begin()); // Erase the first element.</code></p>
    <p><code>†cout ЛЛ "Remaining contents:" ЛЛ endl;</code></p>
    <p><code>†for (i = v.begin(); i != v.end(); i++) cout ЛЛ " " ЛЛ *(*i) ЛЛ endl;</code></p>
    <p><code>†release(v.begin(), v.end()); // Delete remaining heap-based objects.</code></p>
    <p><code>†v.erase(v.begin(), v.end()); // Erase remaining elements.</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>map1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†typedef mapЛchar, int, lessЛcharЫ Ы maptype;</code></p>
    <p><code>†maptype m;</code></p>
    <p><code>†// Store mappings between roman numerals and decimals.</code></p>
    <p><code>†m['l'] = 50;</code></p>
    <p><code>†m['x'] = 20; // Deliberate mistake.</code></p>
    <p><code>†m['v'] = 5;</code></p>
    <p><code>†m['i'] = 1;</code></p>
    <p><code>†cout ЛЛ "m['x'] = " ЛЛ m['x'] ЛЛ endl;</code></p>
    <p><code>†m['x'] = 10; // Correct mistake.</code></p>
    <p><code>†cout ЛЛ "m['x'] = " ЛЛ m['x'] ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "m['z'] = " ЛЛ m['z'] ЛЛ endl; // Note default value is added.</code></p>
    <p><code>†cout ЛЛ "m.count('z') = " ЛЛ m.count('z') ЛЛ endl;</code></p>
    <p><code>†pairЛmaptype::iterator, boolЫ p;</code></p>
    <p><code>†p = m.insert(pairЛconst char, intЫ('c', 100));</code></p>
    <p><code>†if (p.second) cout ЛЛ "First insertion successful" ЛЛ endl;</code></p>
    <p><code>†p = m.insert(pairЛconst char, intЫ ('c', 100));</code></p>
    <p><code>†if (p.second) cout ЛЛ "Second insertion successful" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "Existing pair " ЛЛ (*(p.first)).first ЛЛ " -Ы " ЛЛ (*(p.first)).second ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mismtch2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool str_equal(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_)†== 0 ? 1: 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>const unsigned size = 5;</code></p>
    <p><code>char* n1[size] = {"Brett", "Graham", "Jack", "Mike", "Todd"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†char* n2[size];</code></p>
    <p><code>†copy(n1, n1 + 5, n2);</code></p>
    <p><code>†pairЛchar**, char**Ы result;</code></p>
    <p><code>†result = mismatch(n1, n1+ size, n2, str_equal);</code></p>
    <p><code>†if (result.first†== n1 + size &amp;&amp; result.second†== n2 + size)</code></p>
    <p><code>††cout ЛЛ "n1 and n2 are the same" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "mismatch at index: " ЛЛ (result.first - n1) ЛЛ endl;</code></p>
    <p><code>†n2[2] = "QED";</code></p>
    <p><code>†result = mismatch(n1, n1 + size, n2, str_equal);</code></p>
    <p><code>†if (result.first†== n2 + size &amp;&amp; result.second†== n2 + size)</code></p>
    <p><code>††cout ЛЛ "n1 and n2 are the same" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "mismatch at index: " ЛЛ (result.first - n1) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mismtch1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†typedef vectorЛintЫ IntVec;</code></p>
    <p><code>†IntVec v1(10);</code></p>
    <p><code>†IntVec v2(v1.size());</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†iota(v2.begin(), v2.end(), 0);</code></p>
    <p><code>†pair ЛIntVec::iterator, IntVec::iteratorЫ result;</code></p>
    <p><code>†result = mismatch(v1.begin(), v1.end(), v2.begin());</code></p>
    <p><code>†if (result.first†= v1.end() &amp;&amp; result.second†== v2.end())</code></p>
    <p><code>† cout ЛЛ "v1 and v2 are the same" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "mismatch at index: " ЛЛ (result.first - v1.begin()) ЛЛ endl;</code></p>
    <p><code>†v2[v2.size()/2] = 42;</code></p>
    <p><code>†result = mismatch(v1.begin(), v1.end(), v2.begin());</code></p>
    <p><code>†if (result.first†== v1.end() &amp;&amp; result.second†== v2.end())</code></p>
    <p><code>† cout ЛЛ "v1 and v2 are the same" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "mismatch at index: " ЛЛ (result.first - v1.begin()) ЛЛ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mmap2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>typedef multimapЛint, char, lessЛintЫ Ы mmap;</code></p>
    <p><code>typedef pairЛconst int, charЫ pair_type;</code></p>
    <empty-line/>
    <p><code>pair_type p1(3, 'c');</code></p>
    <p><code>pair_type p2(6, 'f');</code></p>
    <p><code>pair_type p3(1, 'a');</code></p>
    <p><code>pair_type p4(2, 'b');</code></p>
    <p><code>pair_type p5(3, 'x');</code></p>
    <p><code>pair_type p6(6, 'f');</code></p>
    <empty-line/>
    <p><code>pair_type array[] = { p1, p2, p3, p4, p5, p6 };</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†mmap m(array, array + 7);</code></p>
    <p><code>†mmap::iterator i;</code></p>
    <p><code>†// Return location of first element that is not less than 3</code></p>
    <p><code>†i = m.lower_bound(3);</code></p>
    <p><code>†cout ЛЛ "lower bound:" ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ (*i).first ЛЛ " -Ы " ЛЛ (*i).second ЛЛ endl;</code></p>
    <p><code>†// Return location of first element that is greater than 3</code></p>
    <p><code>†i = m.upper_bound(3);</code></p>
    <p><code>†cout ЛЛ "upper bound:" ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ (*i).first ЛЛ " -Ы " ЛЛ (*i).second ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>adjfind2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>typedef vectorЛchar*Ы CStrVector;</code></p>
    <empty-line/>
    <p><code>int equal_length(const char* v1_, const char* v2_) {</code></p>
    <p><code>†return ::strlen(v1_) == ::strlen(v2_);</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* names[] = {"Brett", "Graham", "Jack", "Mike", "Todd"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const int nameCount = sizeof(names)/sizeof(names[0]);</code></p>
    <p><code>†CStrVector v(nameCount);</code></p>
    <p><code>†for (int i = 0; i Л nameCount; i++) v[i] = names[i];</code></p>
    <p><code>†CStrVector::iterator location;</code></p>
    <p><code>†location = adjacent_find(v.begin(), v.end(), equal_length);</code></p>
    <p><code>†if (location!= v.end())</code></p>
    <p><code>† cout ЛЛ "Found two adjacent strings of equal length: " ЛЛ *location </code></p>
    <p><code>†††††† ЛЛ " -and- " ЛЛ *(location + 1) ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "Didn't find two adjacent strings of equal length.";</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>list3.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>char array[] = {'x', 'l', 'x', 't', 's', 's'};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†listЛcharЫ str(array, array + 6);</code></p>
    <p><code>†listЛcharЫ::iterator i;</code></p>
    <p><code>†cout ЛЛ "original: ";</code></p>
    <p><code>†for (i = str.begin(); i != str.end(); i++) cout ЛЛ *i;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "reversed: ";</code></p>
    <p><code>†str.reverse();</code></p>
    <p><code>†for (i = str.begin(); i != str.end(); i++) cout ЛЛ *i;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "removed: ";</code></p>
    <p><code>†str.remove('x');</code></p>
    <p><code>†for (i = str.begin(); i != str.end(); i++) cout ЛЛ *i;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "uniqued: ";</code></p>
    <p><code>†str.unique();</code></p>
    <p><code>†for (i = str.begin(); i != str.end(); i++)†cout ЛЛ *i;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "sorted: ";</code></p>
    <p><code>†str.sort();</code></p>
    <p><code>†for (i = str.begin(); i != str.end(); i++) cout ЛЛ *i;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>parsrtc2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_) Л 0 ? 1: 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* names[] = {"aa", "ff", "dd", "ee", "cc", "bb"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned nameSize = sizeof(names) / sizeof(names[0]);</code></p>
    <p><code>†vectorЛchar*Ы v1(nameSize);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = names[i];</code></p>
    <p><code>†ostream_iteratorЛchar*Ы iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†vectorЛchar*Ы result(5);</code></p>
    <p><code>†partial_sort_copy(v1.begin(), v1.end(), result.begin(), result.end(), str_compare);</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec6.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 4, 9, 16, 25, 36};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(array, array + 6);</code></p>
    <p><code>†for (int i = 0; i Л v.size(); i++) cout ЛЛ "v[" ЛЛ i ЛЛ "] = " ЛЛ v[i] ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†v.erase(v.begin()); // Erase first element.</code></p>
    <p><code>†for (i = 0; i Л v.size(); i++) cout ЛЛ "v[" ЛЛ i ЛЛ "] = " ЛЛ v[i] ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†v.erase(v.end() - 1); // Erase last element.</code></p>
    <p><code>†for (i = 0; i Л v.size(); i++) cout ЛЛ "v[" ЛЛ i ЛЛ "] = " ЛЛ v[i] ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†v.erase(v.begin() + 1, v.end() - 1); // Erase all but first and last.</code></p>
    <p><code>†for (i = 0; i Л v.size(); i++)</code></p>
    <p><code>†cout ЛЛ "v[" ЛЛ i ЛЛ "] = " ЛЛ v[i] ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†v.erase(); // Erase all.</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>inrprod2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>int add(int a_, int b_) {</code></p>
    <p><code>†return a_ + b_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int mult(int a_, int b_) {</code></p>
    <p><code>†return a_ * b_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(3);</code></p>
    <p><code>†vectorЛintЫ v2(v1.size());</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) {</code></p>
    <p><code>† v1[i] = i + 1;</code></p>
    <p><code>† v2[i] = v1.size() - i;</code></p>
    <p><code>†}</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†cout ЛЛ "Inner product(product of sums):\n\t";</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ "\n\t";</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†int result = inner_product(v1.begin(), v1.end(), v2.begin(), 1, mult, add);</code></p>
    <p><code>†cout ЛЛ "\nis: " ЛЛ result ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mmap1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†typedef multimapЛchar, int, lessЛcharЫ Ы mmap;</code></p>
    <p><code>†mmap m;</code></p>
    <p><code>†cout ЛЛ "count('X') = " ЛЛ m.count('X') ЛЛ endl;</code></p>
    <p><code>†m.insert(pairЛconst char, intЫ('X', 10)); // Standard way.</code></p>
    <p><code>†cout ЛЛ "count('X') = " ЛЛ m.count('X') ЛЛ endl;</code></p>
    <p><code>†m.insert('X', 20); // Non-standard, but very convenient!</code></p>
    <p><code>†cout ЛЛ "count('X') = " ЛЛ m.count('X') ЛЛ endl;</code></p>
    <p><code>†m.insert('Y', 32);</code></p>
    <p><code>†mmap::iterator i = m.find('X'); // Find first match.</code></p>
    <p><code>†while (i != m.end()) { // Loop until end is reached.</code></p>
    <p><code>† cout ЛЛ (*i).first ЛЛ " -Ы " ЛЛ (*i).second ЛЛ endl;</code></p>
    <p><code>† i++;</code></p>
    <p><code>†}</code></p>
    <p><code>†int count = m.erase('X');</code></p>
    <p><code>†cout ЛЛ "Erased " ЛЛ count ЛЛ " items" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>adjfind0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers1[5] = {1, 2, 4, 8, 16};</code></p>
    <p><code>int numbers2[5] = {5, 3, 2, 1, 1};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int* location = adjacent_find(numbers1, numbers1 + 5);</code></p>
    <empty-line/>
    <p><code>†if (location != numbers1 + 5)</code></p>
    <p><code>† cout ЛЛ "Found adjacent pair of: " ЛЛ *location ЛЛ " at offset " ЛЛ (location - numbers1) ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "No adjacent pairs" ЛЛ endl;</code></p>
    <p><code>†location = adjacent_find(numbers2, numbers2 + 5);</code></p>
    <p><code>†if (location != numbers2 + 5)</code></p>
    <p><code>† cout ЛЛ "Found adjacent pair of: " ЛЛ *location ЛЛ " at offset " ЛЛ (location - numbers2) ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "No adjacent pairs" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>parsrt2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_) Л 0 ? 1: 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* names[] = {"aa", "ff", "dd", "ee", "cc", "bb"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned nameSize = sizeof(names) / sizeof(names[0]);</code></p>
    <p><code>†vectorЛchar*Ы v1(nameSize);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = names[i];</code></p>
    <p><code>†ostream_iteratorЛchar*Ы iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†partial_sort(v1.begin(), v1.begin() + nameSize/2, v1.end(), str_compare);</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mset5.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>bool less_than(int a_, int b_) {</code></p>
    <p><code>†return a_ Л b_;</code></p>
    <p><code>}</code></p>
    <p><code>bool greater_than(int a_, int b_) {</code></p>
    <p><code>†return a_ Ы b_;</code></p>
    <p><code>}</code></p>
    <p><code>int array[] = {3, 6, 1, 9};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†typedef pointer_to_binary_functionЛint, int, boolЫ fn_type;</code></p>
    <p><code>†typedef multisetЛint, fn_typeЫ mset;</code></p>
    <p><code>†fn_type f(less_than);</code></p>
    <p><code>†mset s1(array, array + 4, f);</code></p>
    <p><code>†mset::const_iterator i = s1.begin();</code></p>
    <p><code>†cout ЛЛ "Using less_than: " ЛЛ endl;</code></p>
    <p><code>†while (i != s1.end()) cout ЛЛ *i++ ЛЛ endl;</code></p>
    <p><code>†fn_type g(greater_than);</code></p>
    <p><code>†mset s2(array, array + 4, g);</code></p>
    <p><code>†i = s2.begin();</code></p>
    <p><code>†cout ЛЛ "Using greater_than: " ЛЛ endl;</code></p>
    <p><code>†while (i != s2.end()) cout ЛЛ *i++ ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mset1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†typedef multisetЛint, lessЛintЫ Ы mset;</code></p>
    <p><code>†mset s;</code></p>
    <p><code>†cout ЛЛ "count(42) = " ЛЛ s.count(42) ЛЛ endl;</code></p>
    <p><code>†s.insert(42);</code></p>
    <p><code>†cout ЛЛ "count(42) = " ЛЛ s.count(42) ЛЛ endl;</code></p>
    <p><code>†s.insert(42);</code></p>
    <p><code>†cout ЛЛ "count(42) = " ЛЛ s.count(42) ЛЛ endl;</code></p>
    <p><code>†setЛint, lessЛintЫ Ы::iterator i = s.find(40);</code></p>
    <p><code>†if (i†== s.end())†cout ЛЛ "40 Not found" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "Found " ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†i = s.find(42);</code></p>
    <p><code>†if (i†== s.end()) cout ЛЛ "Not found" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "Found " ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†int count = s.erase(42);</code></p>
    <p><code>†cout ЛЛ "Erased " ЛЛ count ЛЛ " instances" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>void print(vectorЛdoubleЫ&amp; vector_) {</code></p>
    <p><code>†for (int i = 0; i Л vector_.size(); i++)</code></p>
    <p><code>†cout ЛЛ vector_[i] ЛЛ " ";</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛdoubleЫ v1; // Empty vector of doubles.</code></p>
    <p><code>†v1.push_back(32.1);</code></p>
    <p><code>†v1.push_back(40.5);</code></p>
    <p><code>†vectorЛdoubleЫ v2; // Another empty vector of doubles.</code></p>
    <p><code>†v2.push_back(3.56);</code></p>
    <p><code>†cout ЛЛ "v1 = ";</code></p>
    <p><code>†print(v1);</code></p>
    <p><code>†cout ЛЛ "v2 = ";</code></p>
    <p><code>†print(v2);</code></p>
    <p><code>†v1.swap(v2); // Swap the vector's contents.</code></p>
    <p><code>†cout ЛЛ "v1 = ";</code></p>
    <p><code>†print(v1);</code></p>
    <p><code>†cout ЛЛ "v2 = ";</code></p>
    <p><code>†print(v2);</code></p>
    <p><code>†v2 = v1; // Assign one vector to another.</code></p>
    <p><code>†cout ЛЛ "v2 = ";</code></p>
    <p><code>†print(v2);</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>uniqcpy2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool str_equal(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_) - 0 ? 1: 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* labels[] = {"Q","Q","W","W","E","E","R","T","T","Y","Y"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned count = sizeof(labels) / sizeof(labels[0]);</code></p>
    <p><code>†ostream_iterator Лchar*Ы iter(cout);</code></p>
    <p><code>†copy(labels, labels + count, iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†char* uCopy[count];</code></p>
    <p><code>†fill(uCopy, uCopy + count, ");</code></p>
    <p><code>†unique_copy(labels, labels + count, uCopy, str_equal);</code></p>
    <p><code>†copy(labels, labels + count, iter);</code></p>
    <p><code>cout ЛЛ endl;</code></p>
    <p><code>copy(uCopy, uCopy + count, iter);</code></p>
    <p><code>cout ЛЛ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mismtch0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int n1[5] = {1, 2, 3, 4, 5};</code></p>
    <p><code>int n2[5] = {1, 2, 3, 4, 5};</code></p>
    <p><code>int n3[5] = {1, 2, 3, 2, 1};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†pair Лint*, int*Ы result;</code></p>
    <p><code>†result = mismatch(n1, n1 + 5, n2);</code></p>
    <p><code>†if (result.first == (n1 + 5) &amp;&amp; result.second†== (n2 + 5))</code></p>
    <p><code>† cout ЛЛ "n1 and n2 are the same" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "Mismatch at offset: " ЛЛ (result.first - n1) ЛЛ endl;</code></p>
    <p><code>†result = mismatch(n1, n1 + 5, n3);</code></p>
    <p><code>†if (result.first†== (n1 + 5) &amp;&amp; result.second†== (n3 + 5))</code></p>
    <p><code>† cout ЛЛ "n1 and n3 are the same" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "Mismatch at offset: " ЛЛ (result.first - n1) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rndshuf2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лstdlib.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>class MyRandomGenerator {</code></p>
    <p><code>public:</code></p>
    <p><code>†nsigned long operator()(unsigned long n_);</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>unsigned long MyRandomGenerator::operator()(unsigned long n_) {</code></p>
    <p><code>†return rand() % n_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†ostream_iterator ЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†MyRandomGenerator r;</code></p>
    <p><code>†for (int i = 0; i Л 3; i++) {</code></p>
    <p><code>† random_shuffle(v1.begin(), v1.end(), r);</code></p>
    <p><code>† copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>† cout ЛЛ endl;</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>merge2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(5);</code></p>
    <p><code>†vectorЛintЫ v2(v1.size());</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) {</code></p>
    <p><code>† v1[i] = 10 - i;</code></p>
    <p><code>† v2[i] = 7 - i;</code></p>
    <p><code>†}</code></p>
    <p><code>†vectorЛintЫ result(v1.size() + v2.size());</code></p>
    <p><code>†merge(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin(),†greaterЛintЫ());</code></p>
    <p><code>†ostream_iterator ЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†copy(result.begin(), result.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>adjfind1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†typedef vectorЛintЫ IntVector;</code></p>
    <p><code>†IntVector v(10);</code></p>
    <p><code>†for (int i = 0; i Л v.size(); i++) v[i] = i;</code></p>
    <p><code>†IntVector::iterator location;</code></p>
    <p><code>†location = adjacent_find(v.begin(), v.end());</code></p>
    <p><code>†if (location != v.end()) cout ЛЛ "Found adjacent pair of: " ЛЛ *location ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "No adjacent pairs" ЛЛ endl;</code></p>
    <p><code>†v[6] = 7;</code></p>
    <p><code>†location = adjacent_find(v.begin(), v.end());</code></p>
    <p><code>†if (location!= v.end())††cout ЛЛ "Found adjacent pair of: " ЛЛ *location ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "No adjacent pairs" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec7.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array1[] = {1, 4, 25};</code></p>
    <p><code>int array2[] = {9, 16};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(array1, array1 + 3);</code></p>
    <p><code>†v.insert(v.begin(), 0); // Insert before first element.</code></p>
    <p><code>†v.insert(v.end(), 36); // Insert after last element.</code></p>
    <p><code>†for (int i = 0; i Л v.size(); i++) cout ЛЛ "v[" ЛЛ i ЛЛ "] = " ЛЛ v[i] ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†// Insert contents of array2 before fourth element.</code></p>
    <p><code>†v.insert(v.begin() + 3, array2, array2 + 2);</code></p>
    <p><code>†for (i = 0; i Л v.size(); i++)</code></p>
    <p><code>†cout ЛЛ "v[" ЛЛ i ЛЛ "] = " ЛЛ v[i] ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bcompos1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>struct odd: public unary_functionЛint, boolЫ {</code></p>
    <p><code>†odd() {}</code></p>
    <p><code>†bool operator() (int n_) const {return (n_ % 2) - 1;}</code></p>
    <p><code>};</code></p>
    <p><code>struct positive: public unary_functionЛint, boolЫ {</code></p>
    <p><code>†positive() {}</code></p>
    <p><code>†bool operator() (int n_) const {return n_ Ы= 0;}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int array[6] = {-2, -1, 0, 1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†binary_composeЛlogical_andЛboolЫ, odd, positiveЫ b(logical_andЛboolЫ(), odd(), positive());</code></p>
    <p><code>†int* p = find_if(array, array + 6, b);</code></p>
    <p><code>†if (p != array + 6) cout ЛЛ *p ЛЛ " is odd and positive" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setsymd2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>char* word1 = "ABCDEFGHIJKLMNO";</code></p>
    <p><code>char* word2 = "LMNOPQRSTUVWXYZ";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†ostream_iteratorЛcharЫ iter(cout, " ");</code></p>
    <p><code>†cout ЛЛ "word1: ";</code></p>
    <p><code>†copy(word1, word1 + ::strlen(word1), iter);</code></p>
    <p><code>†cout ЛЛ "\nword2: ";</code></p>
    <p><code>†copy(word2, word2 + ::strlen(word2), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†set_symmetric_difference(word1, word1 + ::strlen(word1), word2, word2 + ::strlen(word2), iter, lessЛcharЫ());</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>search0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int v1[6] = {1, 1, 2, 3, 5, 8};</code></p>
    <p><code>int v2[6] = {0, 1, 2, 3, 4, 5};</code></p>
    <p><code>int v3[2] = {3, 4};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int* location;</code></p>
    <p><code>†location = search(v1, v1 + 6, v3, v3 + 2);</code></p>
    <p><code>†if (location†== v1 + 6) cout ЛЛ "v3 not contained in v1" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "Found v3 in v1 at offset: " ЛЛ location - v1 ЛЛ endl;</code></p>
    <p><code>†location = search(v2, v2 + 6, v3, v3 + 2);</code></p>
    <p><code>†if (location†== v2 + 6) cout ЛЛ "v3 not contained in v2" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "Found v3 in v2 at offset: " ЛЛ location - v2 ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>eqlrnge1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†typedef vectorЛintЫ IntVec;</code></p>
    <p><code>†IntVec v(10);</code></p>
    <p><code>†for (int i = 0; i Л v.size(); i++) v[i] = i / 3;††ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†cout ЛЛ "Within the collection:\n\t";</code></p>
    <p><code>†copy(v.begin(), v.end(), iter);</code></p>
    <p><code>†pairЛIntVec::iterator, IntVec::iteratorЫ range;</code></p>
    <p><code>†range = equal_range(v.begin(), v.end(), 2);</code></p>
    <p><code>†cout ЛЛ "\n2 can be inserted from before index " ЛЛ (range.first - v.begin())</code></p>
    <p><code>††††††ЛЛ " to before index " ЛЛ (range.second - v.begin()) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rotcopy1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>vectorЛintЫ v1(10);</code></p>
    <p><code>iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>ostream_iterator ЛintЫ iter(cout, " ");</code></p>
    <p><code>copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>cout ЛЛ endl;</code></p>
    <p><code>vectorЛintЫ v2(v1.size());</code></p>
    <p><code>for (int i = 0; i Л v1.size(); i++) {</code></p>
    <p><code>†rotate_copy(v1.begin(), v1.begin() + i, v1.end(), v2.begin());</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>}</code></p>
    <p><code>cout ЛЛ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>eqlrnge2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>char chars[] = "aabbccddggghhklllmqqqqssyyzz";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned count = sizeof(chars) - 1;</code></p>
    <p><code>†ostream_iteratorЛcharЫ iter(cout);</code></p>
    <p><code>†cout ЛЛ "Within the collection:\n\t";</code></p>
    <p><code>†copy(chars, chars + count, iter);</code></p>
    <p><code>†pairЛchar*, char*Ы range;</code></p>
    <p><code>†range = equal_range(chars, chars + count, 'q', lessЛcharЫ());</code></p>
    <p><code>†cout ЛЛ "\nq can be inserted from before index " ЛЛ (range.first - chars) ЛЛ " to before index "</code></p>
    <p><code>††††††ЛЛ (range.second - chars) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>release1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>class X {</code></p>
    <p><code>public:</code></p>
    <p><code>†X(int i_): i(i_) {}</code></p>
    <p><code>†~X() {cout ЛЛ "Delete X(" ЛЛ i ЛЛ ")" ЛЛ endl;}</code></p>
    <p><code>†int i;</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>ostream&amp; operator ЛЛ (ostream&amp; stream_, const X&amp; x_) {</code></p>
    <p><code>†return stream_ ЛЛ "X(" ЛЛ x_.i ЛЛ ")";</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛX*Ы v;</code></p>
    <p><code>†v.push_back(new X(2));</code></p>
    <p><code>†v.push_back(new X(1));</code></p>
    <p><code>†v.push_back(new X(4));</code></p>
    <p><code>†vectorЛX*Ы::iterator i;</code></p>
    <p><code>†for (i = v.begin(); i!= v.end(); i++) cout ЛЛ *(*i) ЛЛ endl;</code></p>
    <p><code>†release(v.begin(), v.end()); // Delete heap-based objects.</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>incl1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†vectorЛintЫ v2(3);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) {</code></p>
    <p><code>† v1[i] = i;</code></p>
    <p><code>†}</code></p>
    <p><code>†if (includes(v1.begin(), v1.end(), v2.begin(), v2.end())) cout ЛЛ "v1 includes v2" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "v1 does not include v2" ЛЛ endl;</code></p>
    <p><code>†for (i = 0; i Л v2.size(); i++) v2[i] = i + 3;</code></p>
    <p><code>†if (includes(v1.begin(), v1.end(), v2.begin(), v2.end())) cout ЛЛ "v1 includes v2" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "v1 does not include v2" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setintr2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>char* word1 = "ABCDEFGHIJKLMNO";</code></p>
    <p><code>char* word2 = "LMNOPQRSTUVWXYZ";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†ostream_iterator ЛcharЫ iter(cout, " ");</code></p>
    <p><code>†cout ЛЛ "word1: ";</code></p>
    <p><code>†copy(word1, word1 + ::strlen(word1), iter);</code></p>
    <p><code>†cout ЛЛ "\nword2: ";</code></p>
    <p><code>†copy(word2, word2 + ::strlen(word2), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†set_intersection(word1, word1 + ::strlen(word1), word2, word2 + ::strlen(word2), iter, lessЛcharЫ());</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>inrprod1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(3);</code></p>
    <p><code>†vectorЛintЫ v2(v1.size());</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) {</code></p>
    <p><code>† v1[i] = i + 1;</code></p>
    <p><code>† v2[i] = v1.size() - i;</code></p>
    <p><code>†}</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†cout ЛЛ "Inner product(sum of products) of:\n\t";</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ "\n\t";</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†int result = inner_product(v1.begin(), v1.end(), v2.begin(), 0);</code></p>
    <p><code>cout ЛЛ "\nis: " ЛЛ result ЛЛ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>merge1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(5);</code></p>
    <p><code>†vectorЛintЫ v2(v1.size());</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†iota(v2.begin(), v2.end(), 3);</code></p>
    <p><code>†vectorЛintЫ result(v1.size() + v2.size());</code></p>
    <p><code>†merge(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†copy(result.begin(), result.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bcompos2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>struct odd: public unary_functionЛint, boolЫ {</code></p>
    <p><code>†odd() {}</code></p>
    <p><code>†bool operator() (int n_) const† {return (n_ % 2) - 1;}</code></p>
    <p><code>};</code></p>
    <p><code>struct positive: public unary_functionЛint, boolЫ {</code></p>
    <p><code>†positive() {}</code></p>
    <p><code>†bool operator() (int n_) const† {return n_ Ы= 0;}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int array[6] = {-2, -1, 0, 1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int* p = find_if(array, array + 6, compose2(logical_andЛboolЫ(), odd(), positive()));</code></p>
    <p><code>†if (p != array + 6) cout ЛЛ *p ЛЛ " is odd and positive" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>error3.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>// Compile this code without defining OS_USE_EXCEPTIONS.</code></p>
    <p><code>void my_handler(int code_, const char* str_) {</code></p>
    <p><code>†cout ЛЛ "Caught " ЛЛ str_ ЛЛ "[code " ЛЛ code_ ЛЛ "]" ЛЛ endl;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†os_handler_function_t old_h = os_set_error_handler(my_handler);</code></p>
    <p><code>†vectorЛintЫ v;</code></p>
    <p><code>†v.pop_back(); // Generates an empty object error.</code></p>
    <p><code>†cout ЛЛ "returned from pop_back()" ЛЛ endl;</code></p>
    <p><code>†os_set_error_handler(old_h);</code></p>
    <p><code>†v.pop_back(); // Generates an empty object error.</code></p>
    <p><code>†cout ЛЛ "successful termination" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>incl0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers1[5] = {1, 2, 3, 4, 5};</code></p>
    <p><code>int numbers2[5] = {1, 2, 4, 8, 16};</code></p>
    <p><code>int numbers3[2] = {4, 8};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†if (includes(numbers1, numbers1 + 5, numbers3, numbers3 + 2))</code></p>
    <p><code>† cout ЛЛ "numbers1 includes numbers3" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "numbers1 does not include numbers3" ЛЛ endl;</code></p>
    <p><code>†if (includes(numbers2, numbers2 + 5, numbers3, numbers3 + 2))</code></p>
    <p><code>† cout ЛЛ "numbers2 includes numbers3" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "numbers2 does not include numbers3" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setdiff2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>char* word1 = "ABCDEFGHIJKLMNO";</code></p>
    <p><code>char* word2 = "LMNOPQRSTUVWXYZ";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†ostream_iteratorЛcharЫ iter(cout, " ");</code></p>
    <p><code>†cout ЛЛ "word1: ";</code></p>
    <p><code>†copy(word1, word1 + ::strlen(word1), iter);</code></p>
    <p><code>†cout ЛЛ "\nword2: ";</code></p>
    <p><code>†copy(word2, word2 + ::strlen(word2), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†set_difference(word1, word1 + ::strlen(word1),††word2, word2 + ::strlen(word2), iter, lessЛcharЫ());</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setunon2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>char* word1 = "ABCDEFGHIJKLMNO";</code></p>
    <p><code>char* word2 = "LMNOPQRSTUVWXYZ";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†ostream_iteratorЛcharЫ iter(cout, " ");</code></p>
    <p><code>†cout ЛЛ "word1: ";</code></p>
    <p><code>†copy(word1, word1 + ::strlen(word1), iter);</code></p>
    <p><code>†cout ЛЛ "\nword2: ";</code></p>
    <p><code>†copy(word2, word2 + ::strlen(word2), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†set_union(word1, word1 + ::strlen(word1),† word2, word2 + ::strlen(word2), iter, lessЛcharЫ());</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>unique2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool str_equal(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_)†== 0 ? 1: 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* labels[] = {"Q","Q","W","W","E","E","R","T","T","Y","Y"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned count = sizeof(labels) / sizeof(labels[0]);</code></p>
    <p><code>†ostream_iteratorЛchar*Ы iter(cout);</code></p>
    <p><code>†copy(labels, labels + count, iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†unique(labels, labels + count, str_equal);</code></p>
    <p><code>†copy(labels, labels + count, iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>parsrtc1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лstdlib.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = rand() % 10;</code></p>
    <p><code>†vectorЛintЫ result(5);</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†partial_sort_copy(v1.begin(), v1.end(), result.begin(), result.end());</code></p>
    <p><code>†copy(result.begin(), result.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>equal1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = i;</code></p>
    <p><code>†vectorЛintЫ v2(10);</code></p>
    <p><code>†if (equal(v1.begin(), v1.end(), v2.begin())) cout ЛЛ "v1 is equal to v2" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "v1 is not equal to v2" ЛЛ endl;</code></p>
    <p><code>†copy(v1.begin(), v1.end(), v2.begin());</code></p>
    <p><code>†if (equal(v1.begin(), v1.end(), v2.begin())) cout ЛЛ "v1 is equal to v2" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "v1 is not equal to v2" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>equal0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers1[5] = {1, 2, 3, 4, 5};</code></p>
    <p><code>int numbers2[5] = {1, 2, 4, 8, 16};</code></p>
    <p><code>int numbers3[2] = {1, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†if (equal(numbers1, numbers1 + 5, numbers2)) </code></p>
    <p><code>† cout ЛЛ "numbers1 is equal to numbers2" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "numbers1 is not equal to numbers2" ЛЛ endl;</code></p>
    <p><code>†if (equal(numbers3, numbers3 + 2, numbers1))</code></p>
    <p><code>† cout ЛЛ "numbers3 is equal to numbers1" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "numbers3 is not equal to numbers1" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>genern2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstdlib.hЫ</code></p>
    <empty-line/>
    <p><code>class Fibonacci {</code></p>
    <p><code>public:</code></p>
    <p><code>†Fibonacci(): v1(0), v2(1) {}</code></p>
    <p><code>†int operator() ();</code></p>
    <p><code>private:</code></p>
    <p><code>†int v1;</code></p>
    <p><code>†int v2;</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int Fibonacci::operator() () {</code></p>
    <p><code>†int r = v1 + v2;</code></p>
    <p><code>†v1 = v2;</code></p>
    <p><code>†v2 = r;</code></p>
    <p><code>†return v1;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†Fibonacci generator;</code></p>
    <p><code>†generate_n(v1.begin(), v1.size(), generator);</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>gener2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstdlib.hЫ</code></p>
    <empty-line/>
    <p><code>class Fibonacci {</code></p>
    <p><code>public:</code></p>
    <p><code>†Fibonacci(): v1(0), v2(1) {}</code></p>
    <p><code>†int operator() ();</code></p>
    <p><code>†private:</code></p>
    <p><code>†int v1;</code></p>
    <p><code>†int v2;</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int Fibonacci::operator() () {</code></p>
    <p><code>†int r = v1 + v2;</code></p>
    <p><code>†v1 = v2;</code></p>
    <p><code>†v2 = r;</code></p>
    <p><code>†return v1;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†Fibonacci generator;</code></p>
    <p><code>†generate(v1.begin(), v1.end(), generator);</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>repcpif1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>bool odd(int a_) {</code></p>
    <p><code>†return a_ % 2;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = i % 5;</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†vectorЛintЫ v2(v1.size());</code></p>
    <p><code>†replace_copy_if(v1.begin(), v1.end(), v2.begin(), odd, 42);</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setsymd.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int v1[3] = {13, 18, 23};</code></p>
    <p><code>int v2[4] = {10, 13, 17, 23};</code></p>
    <p><code>int result[4] = {0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†set_symmetric_difference(v1, v1 + 3, v2, v2 + 4, result);</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>deque1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†dequeЛintЫ d;</code></p>
    <p><code>†d.push_back(4); // Add after end.</code></p>
    <p><code>†d.push_back(9);</code></p>
    <p><code>†d.push_back(16);</code></p>
    <p><code>†d.push_front(1); // Insert at beginning.</code></p>
    <p><code>†for (int i = 0; i Л d.size(); i++) cout ЛЛ "d[" ЛЛ i ЛЛ "] = " ЛЛ d[i] ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†d.pop_front(); // Erase first element.</code></p>
    <p><code>†d[2] = 25; // Replace last element.</code></p>
    <p><code>†for (i = 0; i Л d.size(); i++)</code></p>
    <p><code>†cout ЛЛ "d[" ЛЛ i ЛЛ "] = " ЛЛ d[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>findif1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>bool div_3(int a_) {</code></p>
    <p><code>†return a_ % 3 ? 0 : 1;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†typedef vectorЛintЫ IntVec;</code></p>
    <p><code>†IntVec v(10);</code></p>
    <p><code>†for (int i = 0; i Л v.size(); i++) v[i] = (i + 1) * (i + 1);</code></p>
    <p><code>†IntVec::iterator iter;</code></p>
    <p><code>†iter = find_if(v.begin(), v.end(), div_3);</code></p>
    <p><code>†if (iter!= v.end())</code></p>
    <p><code>† cout ЛЛ "Value " ЛЛ *iter ЛЛ " at offset " ЛЛ (iter - v.begin()) ЛЛ " is divisible by 3" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ucompos1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лmath.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>struct square_root: public unary_functionЛdouble, doubleЫ {</code></p>
    <p><code>†square_root() {}</code></p>
    <p><code>†double operator() (double x_) const {return sqrt(x_);}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int input[3] = {-1, -4, -16};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int output[3];</code></p>
    <p><code>†transform(input, input + 3, output, unary_composeЛsquare_root, negateЛintЫ Ы(square_root(), negateЛintЫ()));</code></p>
    <p><code>†for (int i = 0; i Л 3; i++) cout ЛЛ output[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rawiter.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>class X {</code></p>
    <p><code>public:</code></p>
    <p><code>†X(int i_ = 0): i (i_) {}</code></p>
    <p><code>†operator int() const {return i;}</code></p>
    <p><code>private:</code></p>
    <p><code>†int i;</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†os_heap_allocatorЛXЫ a;</code></p>
    <p><code>†// Allocate (but do not construct) storage for 5 elements.</code></p>
    <p><code>† os_heap_allocatorЛXЫ::pointer p = a.allocate(5);</code></p>
    <p><code>†raw_storage_iteratorЛX*, XЫ r(p);</code></p>
    <p><code>†for (int i = 0; i Л 5; i++) *r++ = X(i);</code></p>
    <p><code>†for (i = 0; i Л 5; i++) cout ЛЛ *p++ ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>set2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†setЛint, lessЛintЫ Ы s;</code></p>
    <p><code>†pairЛsetЛint, lessЛintЫ Ы::const_iterator, boolЫ p;</code></p>
    <p><code>†p = s.insert(42);</code></p>
    <p><code>†if (p.second) cout ЛЛ "Inserted new element " ЛЛ *(p.first) ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "Existing element = " ЛЛ *(p.first) ЛЛ endl;</code></p>
    <p><code>†p = s.insert(42);</code></p>
    <p><code>†if (p.second) cout ЛЛ "Inserted new element " ЛЛ *(p.first) ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "Existing element = " ЛЛ *(p.first) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mset3.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[] = {3, 6, 1, 2, 3, 2, 6, 7, 9};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†multisetЛint, lessЛintЫ Ы s(array, array + 9);</code></p>
    <p><code>†multisetЛint, lessЛintЫ Ы::iterator i;</code></p>
    <p><code>†// Return location of first element that is not less than 3</code></p>
    <p><code>†i = s.lower_bound(3);</code></p>
    <p><code>†cout ЛЛ "lower bound = " ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†// Return location of first element that is greater than 3</code></p>
    <p><code>†i = s.upper_bound(3);</code></p>
    <p><code>†cout ЛЛ "upper bound = " ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>binsrch2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_) Л† 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* labels[] = {"aa", "dd", "ff", "jj", "ss", "zz"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned count = sizeof(labels) / sizeof(labels[0]);</code></p>
    <p><code>†if (binary_search(labels, labels + count, "ff", str_compare)) cout ЛЛ "ff is in labels." ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "ff is not in labels." ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>nthelem2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лstdlib.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = rand() % 10;</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†nth_element(v1.begin(), v1.begin() + v1.size() / 2, v1.end(), greaterЛintЫ());</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setintr1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†vectorЛintЫ v2(10);</code></p>
    <p><code>†iota(v2.begin(), v2.end(), 7);</code></p>
    <p><code>†ostream_iterator ЛintЫ iter(cout, " ");</code></p>
    <p><code>†cout ЛЛ "v1: ";</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ "\nv2: ";</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setdiff1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†vectorЛintЫ v2(10);</code></p>
    <p><code>†iota(v2.begin(), v2.end(), 7);</code></p>
    <p><code>†ostream_iterator ЛintЫ iter(cout, " ");</code></p>
    <p><code>†cout ЛЛ "v1: ";</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ "\nv2: ";</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>adjdiff2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int mult(int a_, int b_) {</code></p>
    <p><code>†return a_ * b_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(10);</code></p>
    <p><code>†for (int i = 0; i Л v.size(); i++) v[i] = i + 1;</code></p>
    <p><code>†vectorЛintЫ rslt(v.size()); </code></p>
    <p><code>†adjacent_difference(v.begin(), v.end(), rslt.begin(), mult);</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v.begin(), v.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†copy(rslt.begin(), rslt.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rotate1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) {</code></p>
    <p><code>† rotate(v1.begin(), v1.begin() + i, v1.end());</code></p>
    <p><code>†ostream_iterator ЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>}</code></p>
    <p><code>cout ЛЛ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setunon1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†vectorЛintЫ v2(10);</code></p>
    <p><code>†iota(v2.begin(), v2.end(), 7);</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†cout ЛЛ "v1: ";</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ "\nv2: ";</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>insert1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>char* array1[] = {"laurie", "jennifer", "leisa"};</code></p>
    <p><code>char* array2[] = {"amanda", "saskia", "carrie"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†dequeЛchar*Ы names(array1, array1 + 3);</code></p>
    <p><code>†dequeЛchar*Ы::iterator i = names.begin() + 2;</code></p>
    <p><code>†copy(array2, array2 + 3, insert_iteratorЛdeque Лchar*Ы Ы(names, i));</code></p>
    <p><code>†dequeЛchar*Ы::iterator j;</code></p>
    <p><code>†for (j = names.begin(); j!= names.end(); j++) cout ЛЛ *j ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ucompos2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лmath.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>struct square_root: public unary_functionЛdouble, doubleЫ {</code></p>
    <p><code>†square_root() {}</code></p>
    <p><code>†double operator() (double x_) const {return sqrt(x_);}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int input[3] = {-1, -4, -16};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int output[3];</code></p>
    <p><code>†transform(input, input + 3, output, compose1(square_root(), negateЛintЫ()));</code></p>
    <p><code>†for (int i = 0; i Л 3; i++) cout ЛЛ output[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>parsrt1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лstdlib.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++)</code></p>
    <p><code>†v1[i] = rand() % 10;</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†partial_sort(v1.begin(), v1.begin() + v1.size() / 2, v1.end());</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>equal2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>bool values_squared(int a_, int b_) {</code></p>
    <p><code>†return (a_ * a_†== b_);</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†vectorЛintЫ v2(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) {</code></p>
    <p><code>† v1[i] = i;</code></p>
    <p><code>† v2[i] = i * i;</code></p>
    <p><code>†}</code></p>
    <p><code>†if (equal(v1.begin(), v1.end(), v2.begin(), values_squared))</code></p>
    <p><code>† cout ЛЛ "v2[i]†== v1[i] * v1[i]" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "v2[i] != v1[i] * v1[i]" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>inplmrg2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = (v1.size() - i - 1) % 5;</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†inplace_merge(v1.begin(), v1.begin() + 5, v1.end(), greaterЛintЫ());</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>nthelem1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лstdlib.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = rand() % 10;</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†nth_element(v1.begin(), v1.begin() + v1.size() / 2, v1.end());</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec4.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(4);</code></p>
    <p><code>†v[0] = 1;</code></p>
    <p><code>†v[1] = 4;</code></p>
    <p><code>†v[2] = 9;</code></p>
    <p><code>†v[3] = 16;</code></p>
    <p><code>†cout ЛЛ "front = " ЛЛ v.front() ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "back = " ЛЛ v.back() ЛЛ ", size = " ЛЛ v.size() ЛЛ endl;</code></p>
    <p><code>†v.push_back(25);</code></p>
    <p><code>†cout ЛЛ "back = " ЛЛ v.back() ЛЛ ", size = " ЛЛ v.size() ЛЛ endl;</code></p>
    <p><code>†v.pop_back();</code></p>
    <p><code>†cout ЛЛ "back = " ЛЛ v.back() ЛЛ ", size = " ЛЛ v.size() ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>lwrbnd2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool char_str_less(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_) Л 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* str[] = {"a", "a", "b", "b", "q", "w", "z"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned strCt = sizeof(str)/sizeof(str[0]);</code></p>
    <p><code>†cout ЛЛ "d can be inserted at index: "</code></p>
    <p><code>† ЛЛ (lower_bound(str, str + strCt, "d", char_str_less) - str) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pheap2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v;</code></p>
    <empty-line/>
    <p><code>†v.push_back(1);</code></p>
    <p><code>†v.push_back(20);</code></p>
    <p><code>†v.push_back(4);</code></p>
    <p><code>†make_heap(v.begin(), v.end(), greaterЛintЫ());</code></p>
    <empty-line/>
    <p><code>†v.push_back(7);</code></p>
    <p><code>†push_heap(v.begin(), v.end(), greaterЛintЫ());</code></p>
    <empty-line/>
    <p><code>†sort_heap(v.begin(), v.end(), greaterЛintЫ());</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v.begin(), v.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <empty-line/>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>insert2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>char* array1[] = {"laurie", "jennifer", "leisa"};</code></p>
    <p><code>char* array2[] = {"amanda", "saskia", "carrie"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†dequeЛchar*Ы names(array1, array1 + 3);</code></p>
    <p><code>†dequeЛchar*Ы::iterator i = names.begin() + 2;</code></p>
    <p><code>†copy(array2, array2 + 3, inserter(names, i));</code></p>
    <p><code>†dequeЛchar*Ы::iterator j;</code></p>
    <p><code>†for (j = names.begin(); j!= names.end(); j++) cout ЛЛ *j ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>} </code></p>
   </section>
   <section>
    <title>
     <p>uprbnd2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool char_str_less(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_) Л 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* str[] = {"a", "a", "b", "b", "q", "w", "z"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned strCt = sizeof(str)/sizeof(str[0]);</code></p>
    <p><code>†cout ЛЛ "d can be inserted at index: "</code></p>
    <p><code>† ЛЛ upper_bound(str, str + strCt, "d", char_str_less) - str ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec3.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛcharЫ v1; // Empty vector of characters.</code></p>
    <p><code>†v1.push_back('h');</code></p>
    <p><code>†v1.push_back('i');</code></p>
    <p><code>†cout ЛЛ "v1 = " ЛЛ v1[0] ЛЛ v1[1] ЛЛ endl;</code></p>
    <p><code>†vectorЛcharЫ v2(v1);</code></p>
    <p><code>†v2[1] = 'o'; // Replace second character.</code></p>
    <p><code>†cout ЛЛ "v2 = " ЛЛ v2[0] ЛЛ v2[1] ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "(v1†== v2) = " ЛЛ (v1†== v2) ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "(v1 Л v2) = " ЛЛ (v1 Л v2) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iter4.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v; // Empty vector of integers.</code></p>
    <p><code>†v.push_back(1);</code></p>
    <p><code>†v.push_back(2);</code></p>
    <p><code>†v.push_back(3);</code></p>
    <p><code>†// Position immediately after last item.</code></p>
    <p><code>†vectorЛintЫ::iterator i = v.end();</code></p>
    <p><code>†// Move back one and then access.</code></p>
    <p><code>††cout ЛЛ "last element is " ЛЛ *--i ЛЛ endl;</code></p>
    <p><code>†i -= 2; // Jump back two items.</code></p>
    <p><code>†cout ЛЛ "first element is " ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setdiff0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int v1[3] = {13, 18, 23};</code></p>
    <p><code>int v2[4] = {10, 13, 17, 23};</code></p>
    <p><code>int result[4] = {0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†set_difference(v1, v1 + 3, v2, v2 + 4, result);</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†set_difference(v2, v2 + 4, v1, v1 + 2, result);</code></p>
    <p><code>†for (i = 0; i Л 4; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>lexcmp2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>const unsigned size = 6;</code></p>
    <p><code>char n1[size] = "shoe";</code></p>
    <p><code>char n2[size] = "shine";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†bool before = lexicographical_compare(n1, n1 + size, n2, n2 + size, greaterЛcharЫ());</code></p>
    <p><code>†if (before) cout ЛЛ n1 ЛЛ " is after " ЛЛ n2 ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ n2 ЛЛ " is after " ЛЛ n1 ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>adjdiff1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(10);</code></p>
    <p><code>†for (int i = 0; i Л v.size(); i++) v[i] = i * i;</code></p>
    <p><code>†vectorЛintЫ result(v.size());</code></p>
    <p><code>†adjacent_difference(v.begin(), v.end(), result.begin());</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v.begin(), v.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†copy(result.begin(), result.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>stblptn1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лstdlib.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = rand() % 20;</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†stable_partition(v1.begin(), v1.end(), bind2nd(lessЛintЫ(), 11));</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ptition1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лstdlib.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = rand() % 20;</code></p>
    <p><code>†ostream_iterator ЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†partition(v1.begin(), v1.end(), bind2nd(lessЛintЫ(), 11));</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1; // Empty vector of integers.</code></p>
    <p><code>†cout ЛЛ "empty = " ЛЛ v1.empty() ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "size = " ЛЛ v1.size() ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "max_size = " ЛЛ v1.max_size() ЛЛ endl;</code></p>
    <p><code>†v1.push_back(42); // Add an integer to the vector.</code></p>
    <p><code>†cout ЛЛ "size = " ЛЛ v1.size() ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "v1[0] = " ЛЛ v1[0] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>sort2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 50, -10, 11, 42, 19};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int count = sizeof(array) / sizeof(array[0]);</code></p>
    <p><code>†ostream_iterator ЛintЫ iter(cout, " ");</code></p>
    <p><code>†cout ЛЛ "before: ";</code></p>
    <p><code>†copy(array, array + count, iter);</code></p>
    <p><code>†cout ЛЛ "\nafter: ";</code></p>
    <p><code>†sort(array, array + count, greaterЛintЫ());</code></p>
    <p><code>†copy(array, array + count, iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>copy4.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†typedef vectorЛintЫ IVec;</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int loc = 0; loc Л v1.size(); loc++) v1[loc] = loc;</code></p>
    <p><code>†vectorЛintЫ v2;</code></p>
    <p><code>†insert_iteratorЛIVecЫ i (v2, v2.begin());</code></p>
    <p><code>†copy(v1.begin(), v1.end(), i);</code></p>
    <p><code>†ostream_iteratorЛintЫ outiter(cout, " ");</code></p>
    <p><code>†copy(v2.begin(), v2.end(), outIter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>prevprm2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(3);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†for (int i = 0; i Л 9; i++) {</code></p>
    <p><code>† prev_permutation(v1.begin(), v1.end(), greaterЛintЫ());</code></p>
    <p><code>† copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>† cout ЛЛ endl;</code></p>
    <p><code>†}</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>trnsfrm2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>char map_char(char a_, int b_) {</code></p>
    <p><code>†return char(a_ + b_);</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int trans[] = {-4, 4, -6, -6, -10, 0, 10, -6, 6, 0, -1, -77};</code></p>
    <p><code>char n[] = "Larry Mullen";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned count† = ::strlen(n);</code></p>
    <p><code>†ostream_iterator ЛcharЫ iter(cout);</code></p>
    <p><code>†transform(n, n + count, trans, iter, map_char);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iter1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛconst char*Ы v; // Vector of character strings.</code></p>
    <p><code>†v.push_back((char*) "zippy"); // First element.</code></p>
    <p><code>†v.push_back((char*) "motorboy"); // Second element.</code></p>
    <p><code>†vectorЛconst char*Ы::iterator i = v.begin(); // Position at end.</code></p>
    <p><code>†for (i = v.begin(); i != v.end(); i++) cout ЛЛ *i ЛЛ endl; // Display item.</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>maxelem2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_) Л 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* names[] = {"Brett", "Graham", "Jack", "Mike", "Todd"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned namesCt = sizeof(names)/sizeof(names[0]);</code></p>
    <p><code>†cout ЛЛ *max_element(names, names + namesCt, str_compare) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>minelem2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_) Л 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* names[] = {"Brett", "Graham", "Jack", "Mike", "Todd"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned namesCt = sizeof(names)/sizeof(names[0]);</code></p>
    <p><code>†cout ЛЛ *min_element(names, names + namesCt, str_compare) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>partsum2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(5);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 1);</code></p>
    <p><code>†vectorЛintЫ v2(v1.size());</code></p>
    <p><code>†partial_sum(v1.begin(), v1.end(), v2.begin(), timesЛintЫ());</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>istmit1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†char buffer[100];</code></p>
    <p><code>†int i = 0;</code></p>
    <p><code>†cin.unsetf(ios::skipws); // Disable white-space skipping.</code></p>
    <p><code>†cout ЛЛ "Please enter a string: ";</code></p>
    <p><code>†istream_iteratorЛchar, ptrdiff_tЫ s(cin);</code></p>
    <p><code>†while (*s!= '\n') buffer[i++] = *s++;</code></p>
    <p><code>†buffer[i] = '\0'; // Null terminate buffer.</code></p>
    <p><code>†cout ЛЛ "read " ЛЛ buffer ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>findif0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>bool odd(int a_) {</code></p>
    <p><code>†return a_ % 2;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {2, 4, 8, 15, 32, 64};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int* location = find_if(numbers, numbers + 6, odd);</code></p>
    <p><code>†if (location != numbers + 6)</code></p>
    <p><code>† cout ЛЛ "Value " ЛЛ *location ЛЛ " at offset " ЛЛ (location - numbers) ЛЛ " is odd" ЛЛ endl; </code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pheap1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v;</code></p>
    <empty-line/>
    <p><code>†v.push_back(1);</code></p>
    <p><code>†v.push_back(20);</code></p>
    <p><code>†v.push_back(4);</code></p>
    <p><code>†make_heap(v.begin(), v.end());</code></p>
    <empty-line/>
    <p><code>†v.push_back(7);</code></p>
    <p><code>†push_heap(v.begin(), v.end());</code></p>
    <empty-line/>
    <p><code>†sort_heap(v.begin(), v.end());</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v.begin(), v.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <empty-line/>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>stblsrt2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool string_less(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_) Л 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* letters[6] = {"bb", "aa", "ll", "dd", "qq", "cc"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†stable_sort(letters, letters + 6, string_less);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ letters[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>nextprm1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(3);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†for (int i = 0; i Л 9; i++) {</code></p>
    <p><code>† next_permutation(v1.begin(), v1.end());</code></p>
    <p><code>† copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>† cout ЛЛ endl;</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>prevprm1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(3);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†for (int i = 0; i Л 9; i++) {</code></p>
    <p><code>† prev_permutation(v1.begin(), v1.end());</code></p>
    <p><code>† copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>† cout ЛЛ endl;</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rndshuf1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†for (int i = 0; i Л 3; i++) {</code></p>
    <p><code>† random_shuffle(v1.begin(), v1.end());</code></p>
    <p><code>† copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>† cout ЛЛ endl;</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ptrbinf1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int sum(int x_, int y_) {</code></p>
    <p><code>†return x_ + y_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int input1[4] = {7, 2, 3, 5};</code></p>
    <p><code>int input2[4] = {1, 5, 5, 8};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int output[4];</code></p>
    <p><code>†transform(input1, input1 + 4, input2, output, pointer_to_binary_functionЛint, int, intЫ(sum));</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ output[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iter2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>void print (const vectorЛconst char*Ы&amp; v_) {</code></p>
    <p><code>†vectorЛconst char*Ы::const_iterator i;</code></p>
    <p><code>†for (i = v_.begin(); i != v_.end(); i++) cout ЛЛ *i ЛЛ endl;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛconst char*Ы v; // Vector of character strings.</code></p>
    <p><code>†v.push_back((char*) "zippy");</code></p>
    <p><code>†v.push_back((char*) "motorboy");</code></p>
    <p><code>†print (v);</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>partsum1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†vectorЛintЫ v2(v1.size());</code></p>
    <p><code>†partial_sum(v1.begin(), v1.end(), v2.begin());</code></p>
    <p><code>†ostream_iterator ЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>replif1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>bool odd(int a_) {</code></p>
    <p><code>†return a_ % 2;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) {</code></p>
    <p><code>† v1[i] = i % 5;</code></p>
    <p><code>††cout ЛЛ v1[i] ЛЛ ' ';</code></p>
    <p><code>†}</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†replace_if(v1.begin(), v1.end(), odd, 42);</code></p>
    <p><code>†for (i = 0; i Л v1.size(); i++) cout ЛЛ v1[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mset4.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[] = {3, 6, 1, 2, 3, 2, 6, 7, 9};</code></p>
    <empty-line/>
    <p><code>int main() </code><code>{</code></p>
    <p><code>†typedef multisetЛint, lessЛintЫ Ы mset;</code></p>
    <p><code>†mset s(array, array + 9);</code></p>
    <p><code>†pairЛmset::const_iterator, mset::const_iteratorЫ p = s.equal_range(3);</code></p>
    <p><code>†cout ЛЛ "lower bound = " ЛЛ *(p.first) ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "upper bound = " ЛЛ *(p.second) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iter3.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛconst char*Ы v; // Vector of character strings.</code></p>
    <p><code>†v.push_back((char*) "zippy"); // First element.</code></p>
    <p><code>†v.push_back((char*) "motorboy"); // Second element.</code></p>
    <p><code>†vectorЛconst char*Ы::reverse_iterator i;</code></p>
    <p><code>†for (i = v.rbegin(); i!= v.rend(); i++) cout ЛЛ *i ЛЛ endl; // Display item.</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>list2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array1[] = {1, 16};</code></p>
    <p><code>int array2[] = {4, 9};</code></p>
    <empty-line/>
    <p><code>int main()†{</code></p>
    <p><code>†listЛintЫ l1(array1, array1 + 2);</code></p>
    <p><code>†listЛintЫ l2(array2, array2 + 2);</code></p>
    <p><code>†listЛintЫ::iterator i = l1.begin();</code></p>
    <p><code>†i++;</code></p>
    <p><code>†l1.splice(i, l2, l2.begin(), l2.end());</code></p>
    <p><code>†i = l1.begin();</code></p>
    <p><code>†while (i != l1.end()) cout ЛЛ *i++ ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>set1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†setЛint, lessЛintЫ Ы s;</code></p>
    <p><code>†cout ЛЛ "count(42) = " ЛЛ s.count(42) ЛЛ endl;</code></p>
    <p><code>†s.insert(42);</code></p>
    <p><code>†cout ЛЛ "count(42) = " ЛЛ s.count(42) ЛЛ endl;</code></p>
    <p><code>†s.insert(42);</code></p>
    <p><code>†cout ЛЛ "count(42) = " ЛЛ s.count(42) ЛЛ endl;</code></p>
    <p><code>†int count = s.erase(42);</code></p>
    <p><code>†cout ЛЛ count ЛЛ " elements erased" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>list1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array1[] = {9, 16, 36};</code></p>
    <p><code>int array2[] = {1, 4};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†listЛintЫ l1(array1, array1 + 3);</code></p>
    <p><code>†listЛintЫ l2(array2, array2 + 2);</code></p>
    <p><code>†listЛintЫ::iterator i1 = l1.begin();</code></p>
    <p><code>†l1.splice(i1, l2);</code></p>
    <p><code>†listЛintЫ::iterator i2 = l1.begin();</code></p>
    <p><code>†while (i2!= l1.end()) cout ЛЛ *i2++ ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>alg5.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†listЛintЫ years;</code></p>
    <p><code>†years.push_back(1962);</code></p>
    <p><code>†years.push_back(1992);</code></p>
    <p><code>†years.push_back(2001);</code></p>
    <p><code>†years.push_back(1999);</code></p>
    <p><code>†sort(years.begin(), years.end()); // Causes linker error.</code></p>
    <p><code>†listЛintЫ::iterator i;</code></p>
    <p><code>†for (i = years.begin(); i != years.end(); i++) cout ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>eqlrnge0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[10] = {0, 0, 1, 1, 2, 2, 2, 2, 3, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†pair Лint*, int*Ы range;</code></p>
    <p><code>†range = equal_range(numbers, numbers + 10, 2);</code></p>
    <p><code>†cout ЛЛ "2 can be inserted from before index " ЛЛ (range.first - numbers)</code></p>
    <p><code>† ЛЛ " to before index " ЛЛ (range.second - numbers) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>advance.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†typedef vectorЛintЫ IntVector;</code></p>
    <p><code>†IntVector v(10);</code></p>
    <p><code>†for (int i = 0; i Л v.size(); i++) v[i] = i;</code></p>
    <p><code>†IntVector::iterator location = v.begin();</code></p>
    <p><code>†cout ЛЛ "At Beginning: " ЛЛ *location ЛЛ endl;</code></p>
    <p><code>†advance(location, 5);</code></p>
    <p><code>†cout ЛЛ "At Beginning + 5: " ЛЛ *location ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>replace1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = i % 5;</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†replace(v1.begin(), v1.end(), 2, 42);</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>alg3.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ i;</code></p>
    <p><code>†i.push_back(1);</code></p>
    <p><code>†i.push_back(4);</code></p>
    <p><code>†i.push_back(2);</code></p>
    <p><code>†i.push_back(8);</code></p>
    <p><code>†i.push_back(2);</code></p>
    <p><code>†i.push_back(2);</code></p>
    <p><code>†int n = 0; // Must be initialized, as count increments n.</code></p>
    <p><code>†count(i.begin(), i.end(), 2, n);</code></p>
    <p><code>†cout ЛЛ "Count of 2s = " ЛЛ n ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>func2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>bool bigger_than(int x_, int y_) {</code></p>
    <p><code>†return x_ Ы y_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫv;</code></p>
    <p><code>†v.push_back(4);</code></p>
    <p><code>†v.push_back(1);</code></p>
    <p><code>†v.push_back(5);</code></p>
    <p><code>†sort(v.begin(), v.end(), bigger_than);</code></p>
    <p><code>†vectorЛintЫ::iterator i;</code></p>
    <p><code>†for (i = v.begin(); i != v.end(); i++) cout ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>unegate1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>struct odd: public unary_functionЛint, boolЫ {</code></p>
    <p><code>†odd() {}</code></p>
    <p><code>†bool operator() (int n_) const {return (n_ % 2) - 1;}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int* p = find_if(array, array + 3, unary_negateЛoddЫ(odd()));</code></p>
    <p><code>†if (p != array + 3)</code></p>
    <p><code>†cout ЛЛ *p ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>alg4.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ years;</code></p>
    <p><code>†years.push_back(1962);</code></p>
    <p><code>†years.push_back(1992);</code></p>
    <p><code>†years.push_back(2001);</code></p>
    <p><code>†years.push_back(1999);</code></p>
    <p><code>†sort(years.begin(), years.end());</code></p>
    <p><code>†vectorЛintЫ::iterator i;</code></p>
    <p><code>†for (i = years.begin(); i!= years.end(); i++)</code></p>
    <p><code>†cout ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>countif1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int odd(int a_) {</code></p>
    <p><code>†return a_ % 2;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ numbers(100);</code></p>
    <p><code>†for (int i = 0; i Л 100; i++) numbers[i] = i % 3;</code></p>
    <p><code>†int elements = 0;</code></p>
    <p><code>†count_if(numbers.begin(), numbers.end(), odd, elements);</code></p>
    <p><code>†cout ЛЛ "Found " ЛЛ elements ЛЛ " odd elements." ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>lwrbnd1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(20);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) {</code></p>
    <p><code>† v1[i] = i/4;</code></p>
    <p><code>† cout ЛЛ v1[i] ЛЛ ' ';</code></p>
    <p><code>†}</code></p>
    <p><code>†int* location = lower_bound(v1.begin(), v1.end(), 3);</code></p>
    <p><code>†cout ЛЛ "\n3 can be inserted at index: " ЛЛ (location - v1.begin()) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>lexcmp1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>const unsigned size = 6;</code></p>
    <p><code>char n1[size] = "shoe";</code></p>
    <p><code>char n2[size] = "shine";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†bool before = lexicographical_compare(n1, n1 + size, n2, n2 + size);</code></p>
    <p><code>†if (before) cout ЛЛ n1 ЛЛ " is before " ЛЛ n2 ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ n2 ЛЛ " is before " ЛЛ n1 ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>copyb.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = i;</code></p>
    <p><code>†vectorЛintЫ v2(v1.size());</code></p>
    <p><code>†copy_backward(v1.begin(), v1.end(), v2.end());</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ptrbinf2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int sum(int x_, int y_) {</code></p>
    <p><code>†return x_ + y_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int input1[4] = {7, 2, 3, 5};</code></p>
    <p><code>int input2[4] = {1, 5, 5, 8};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int output[4];</code></p>
    <p><code>†transform(input1, input1 + 4, input2, output, ptr_fun(sum));</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ output[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>copyb0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[5] = {1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int result[5];</code></p>
    <p><code>†copy_backward(numbers, numbers + 5, result + 5);</code></p>
    <p><code>†for (int i = 0; i Л 5; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†for (i = 0; i Л 5; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>binsert1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>char* array[] = {"laurie", "jennifer", "leisa"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛchar*Ы names;</code></p>
    <p><code>†copy(array, array + 3, back_insert_iteratorЛvectorЛchar*Ы Ы(names));</code></p>
    <p><code>†vectorЛchar*Ы::iterator i;</code></p>
    <p><code>†for (i = names.begin(); i!= names.end(); i++) cout ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>unegate2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>struct odd: public unary_functionЛint, boolЫ {</code></p>
    <p><code>†odd() {}</code></p>
    <p><code>†bool operator() (int n_) const {return (n_ % 2) - 1;}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int* p = find_if(array, array + 3, not1 (odd()));</code></p>
    <p><code>†if (p != array + 3) cout ЛЛ *p ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>revcopy1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int result[6];</code></p>
    <p><code>†reverse_copy(numbers, numbers + 6, result);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†for (i = 0; i Л 6; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>finsert1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>char* array[] = {"laurie", "jennifer", "leisa"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†dequeЛchar*Ы names;</code></p>
    <p><code>†copy(array, array + 3, front_insert_iteratorЛdeque Лchar*Ы Ы(names));</code></p>
    <p><code>†dequeЛchar*Ы::iterator i;</code></p>
    <p><code>†for (i = names.begin(); i!= names.end(); i++) cout ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>remcpif1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>bool odd(int a_) {</code></p>
    <p><code>†return a_ % 2;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {1, 2, 3, 1, 2, 3};</code></p>
    <p><code>int result[6] = {0, 0, 0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†remove_copy_if(numbers, numbers + 6, result, odd);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>inplmrg1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {1, 10, 42, 3, 16, 32};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†inplace_merge(numbers, numbers + 3, numbers + 6);</code></p>
    <p><code>†for (i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>list4.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array1[] = {1, 3, 6, 7};</code></p>
    <p><code>int array2[] = {2, 4};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†listЛintЫ l1(array1, array1 + 4);</code></p>
    <p><code>†listЛintЫ l2(array2, array2 + 2);</code></p>
    <p><code>†l1.merge(l2);</code></p>
    <p><code>†for (listЛintЫ::iterator i = l1.begin(); i != l1.end(); i++) cout ЛЛ *i;</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>revbit1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 5, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†listЛintЫ v(array, array + 4);</code></p>
    <p><code>†reverse_bidirectional_iteratorЛlistЛintЫ::iterator, int,†listЛintЫ::reference, listЛintЫ::difference_typeЫ r(v.end());</code></p>
    <p><code>†while (r != v.begin())</code></p>
    <p><code>†cout ЛЛ *r++ ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>copy3.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = i;</code></p>
    <p><code>†vectorЛintЫ v2(10);</code></p>
    <p><code>†copy(v1.begin(), v1.end(), v2.begin());</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>merge0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers1[5] = {1, 6, 13, 25, 101};</code></p>
    <p><code>int numbers2[5] = {-5, 26, 36, 46, 99};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int result[10];</code></p>
    <p><code>†merge(numbers1, numbers1 + 5, numbers2, numbers2 + 5, result);</code></p>
    <p><code>†for (int i = 0; i Л 10; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>reviter1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 5, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(array, array + 4);</code></p>
    <p><code>†stl_reverse_iteratorЛvectorЛintЫ::iterator, int, vectorЛintЫ::reference, vectorЛintЫ::difference_typeЫ r (v.end());</code></p>
    <p><code>†while (r!= v.begin()) cout ЛЛ *r++ ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>find1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int years[] = {1942, 1952, 1962, 1972, 1982, 1992};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†const unsigned yearCount = sizeof(years) / sizeof(years[0]);</code></p>
    <p><code>†int* location = find(years, years + yearCount, 1972);</code></p>
    <p><code>†cout ЛЛ "Found 1972 at offset " ЛЛ (location - years) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>trnsfrm1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int negate_int(int a_) {</code></p>
    <p><code>†return -a_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {-5, -1, 0, 1, 6, 11};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int result[6];</code></p>
    <p><code>†transform(numbers, numbers + 6, result, negate_int);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>binsert2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>char* array[] = {"laurie", "jennifer", "leisa"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛchar*Ы names;</code></p>
    <p><code>†copy(array, array + 3, back_inserter(names));</code></p>
    <p><code>†vectorЛchar*Ы::iterator i;</code></p>
    <p><code>†for (i = names.begin(); i!= names.end(); i++)†cout ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>finsert2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>char* array[] = {"laurie", "jennifer", "leisa"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†dequeЛchar*Ы names;</code></p>
    <p><code>†copy(array, array + 3, front_inserter(names));</code></p>
    <p><code>†dequeЛchar*Ы::iterator i;</code></p>
    <p><code>†for (i = names.begin(); i!= names.end(); i++) cout ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mset2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>char* names[] = {"dave", "alf", "chas", "bob", "ed", "chas"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†typedef multisetЛchar*, less_sЫ mset;</code></p>
    <p><code>†mset s;</code></p>
    <p><code>†s.insert(names, names + 6);</code></p>
    <p><code>†for (mset::iterator i = s.begin(); i!= s.end(); i++) cout ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ostmit.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 5, 2, 4};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†char* string = "hello";</code></p>
    <p><code>†ostream_iteratorЛcharЫ it1(cout);</code></p>
    <p><code>†copy(string, string + 5, it1);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†ostream_iteratorЛintЫ it2(cout);</code></p>
    <p><code>†copy(array, array + 4, it2);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ptrunf1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>bool even(int n_) {</code></p>
    <p><code>†return (n_ % 2)†== 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int* p = find_if(array, array + 3, pointer_to_unary_functionЛint, boolЫ(even));</code></p>
    <p><code>†if (p != array + 3) cout ЛЛ *p ЛЛ " is even" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>func1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>bool bigger(int i_) {</code></p>
    <p><code>†return i_ Ы 3;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v;</code></p>
    <p><code>†v.push_back(4);</code></p>
    <p><code>†v.push_back(1);</code></p>
    <p><code>†v.push_back(5);</code></p>
    <p><code>†int n = 0;</code></p>
    <p><code>†count_if(v.begin(), v.end(), bigger, n);</code></p>
    <p><code>†cout ЛЛ "Number greater than 3 = " ЛЛ n ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>stblptn0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>bool less_10(int a_) {</code></p>
    <p><code>†return a_ Л 10 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {10, 5, 11, 20, 6, -2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†stable_partition(numbers, numbers + 6, less_10);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setunon0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int v1[3] = {13, 18, 23};</code></p>
    <p><code>int v2[4] = {10, 13, 17, 23};</code></p>
    <p><code>int result[7] = {0, 0, 0, 0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†set_union(v1, v1 + 3, v2, v2 + 4, result);</code></p>
    <p><code>†for (int i = 0; i Л 7; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mkheap1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {5, 10, 4, 13, 11, 19};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†make_heap(numbers, numbers + 6, greaterЛintЫ());</code></p>
    <p><code>†for (int i = 6; i Ы= 1; i--) {</code></p>
    <p><code>† cout ЛЛ numbers[0] ЛЛ endl;</code></p>
    <p><code>† pop_heap(numbers, numbers + i, greaterЛintЫ());</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setintr0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int v1[3] = {13, 18, 23};</code></p>
    <p><code>int v2[4] = {10, 13, 17, 23};</code></p>
    <p><code>int result[4] = {0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†set_intersection(v1, v1 + 3, v2, v2 + 4, result);</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>logicand.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>bool input1[4] = {1, 1, 0, 1};</code></p>
    <p><code>bool input2[4] = {0, 1, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int output[4];</code></p>
    <p><code>†transform(input1, input1 + 4, input2, output, logical_andЛboolЫ());</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ output[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>logicor.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>bool input1[4] = {1, 1, 0, 1};</code></p>
    <p><code>bool input2[4] = {0, 1, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int output[4];</code></p>
    <p><code>†transform(input1, input1 + 4, input2, output, logical_orЛboolЫ());</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ output[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>nequal.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int input1[4] = {1, 7, 2, 2};</code></p>
    <p><code>int input2[4] = {1, 6, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int output[4];</code></p>
    <p><code>†transform(input1, input1 + 4, input2, output, not_equal_toЛintЫ());</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ output[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ptition0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int less_10(int a_) {</code></p>
    <p><code>†return a_ Л 10 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {6, 12, 3, 10, 1, 20};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†partition(numbers, numbers + 6, less_10);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>inrprod0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>int vector1[5] = {1, 2, 3, 4, 5};</code></p>
    <p><code>int vector2[5] = {1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int result;</code></p>
    <p><code>†result = inner_product(vector1, vector1 + 5, vector2, 0);</code></p>
    <p><code>†cout ЛЛ "Inner product = " ЛЛ result ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>func3.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫv;</code></p>
    <p><code>†v.push_back(4);</code></p>
    <p><code>†v.push_back(1);</code></p>
    <p><code>†v.push_back(5);</code></p>
    <p><code>†sort(v.begin(), v.end(), greaterЛintЫ());</code></p>
    <p><code>†vectorЛintЫ::iterator i;</code></p>
    <p><code>†for (i = v.begin(); i != v.end(); i++)††cout ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>modulus.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int input1[4] = {6, 8, 10, 2};</code></p>
    <p><code>int input2[4] = {4, 2, 11, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int output[4];</code></p>
    <p><code>†transform(input1, input1 + 4, input2, output, modulusЛintЫ());</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ output[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>uprbnd1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int array[20];</code></p>
    <p><code>†for (int i = 0; i Л 20; i++) {</code></p>
    <p><code>† array[i] = i/4;</code></p>
    <p><code>† cout ЛЛ array[i] ЛЛ ' ';</code></p>
    <p><code>†}</code></p>
    <p><code>†cout ЛЛ "\n3 can be inserted at index: "</code></p>
    <p><code>† ЛЛ upper_bound(array, array + 20, 3) - array ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>equalto.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int input1[4] = {1, 7, 2, 2};</code></p>
    <p><code>int input2[4] = {1, 6, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int output[4];</code></p>
    <p><code>†transform(input1, input1 + 4, input2, output, equal_toЛintЫ());</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ output[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>count1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ numbers(100);</code></p>
    <p><code>†for (int i = 0; i Л 100; i++) numbers[i] = i % 3;</code></p>
    <p><code>†int elements = 0;</code></p>
    <p><code>†count(numbers.begin(), numbers.end(), 2, elements);</code></p>
    <p><code>†cout ЛЛ "Found " ЛЛ elements ЛЛ " 2's." ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>uniqcpy1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[8] = {0, 1, 1, 2, 2, 2, 3, 4};</code></p>
    <p><code>int result[8] = {0, 0, 0, 0, 0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†unique_copy(numbers, numbers + 8, result);</code></p>
    <p><code>†for (int i = 0; i Л 8; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>minus.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int input1[4] = {1, 5, 7, 8};</code></p>
    <p><code>int input2[4] = {1, 4, 8, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int output[4];</code></p>
    <p><code>†transform(input1, input1 + 4, input2, output, minusЛintЫ());</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ output[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>replcpy1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 0, 1, 2};</code></p>
    <p><code>int result[6] = {0, 0, 0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†replace_copy(numbers, numbers + 6, result, 2, 42);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>swprnge1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†char* word1 = "World";</code></p>
    <p><code>†char* word2 = "Hello";</code></p>
    <p><code>†cout ЛЛ word1 ЛЛ " " ЛЛ word2 ЛЛ endl;</code></p>
    <p><code>†swap_ranges(word1, word1 + ::strlen(word1), word2);</code></p>
    <p><code>†cout ЛЛ word1 ЛЛ " " ЛЛ word2 ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec8.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v;</code></p>
    <p><code>†cout ЛЛ "capacity = " ЛЛ v.capacity() ЛЛ endl;</code></p>
    <p><code>†v.push_back(42);</code></p>
    <p><code>†cout ЛЛ "capacity = " ЛЛ v.capacity() ЛЛ endl;</code></p>
    <p><code>†v.reserve (5000);</code></p>
    <p><code>†cout ЛЛ "capacity = " ЛЛ v.capacity() ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>plus.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int input1[4] = {1, 6, 11, 8};</code></p>
    <p><code>int input2[4] = {1, 5, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int total = inner_product(input1, input1 + 4, input2, 0, plusЛintЫ(), timesЛintЫ());</code></p>
    <p><code>†cout ЛЛ "total = " ЛЛ total ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>remcopy1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {1, 2, 3, 1, 2, 3};</code></p>
    <p><code>int result[6] = {0, 0, 0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†remove_copy(numbers, numbers + 6, result, 2);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>error2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>// Compile this code with the symbol OS_USE_EXCEPTIONS defined.</code></p>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v;</code></p>
    <p><code>†try {</code></p>
    <p><code>† v.pop_back(); // Generates an exception.</code></p>
    <p><code>†} catch (const char* str) {</code></p>
    <p><code>† cout ЛЛ "Caught exception " ЛЛ str ЛЛ endl;</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iterswp1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(6);</code></p>
    <p><code>†iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>†iter_swap(v1.begin(), v1.begin() + 3);</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>remif1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>bool odd(int a_) {</code></p>
    <p><code>†return a_ % 2;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 0, 1, 1, 2, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†remove_if(numbers, numbers + 6, odd);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++)</code></p>
    <p><code>†cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>foreach1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>void print_sqr(int a_) {</code></p>
    <p><code>†cout ЛЛ a_ * a_ ЛЛ " ";</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†for (int i = 0; i Л v1.size(); i++) v1[i] = i;</code></p>
    <p><code>†for_each(v1.begin(), v1.end(), print_sqr);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>parsrtc0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {5, 2, 4, 3, 1, 6};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int result[3];</code></p>
    <p><code>†partial_sort_copy(numbers, numbers + 6, result, result + 3);</code></p>
    <p><code>†for (int i = 0; i Л 3; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pqueue2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†priority_queueЛdequeЛchar*Ы, greater_sЫ q;</code></p>
    <p><code>†q.push((char*) "cat");</code></p>
    <p><code>†q.push((char*) "dog");</code></p>
    <p><code>†q.push((char*) "ape");</code></p>
    <p><code>†while (!q.empty()) {</code></p>
    <p><code>† cout ЛЛ q.top() ЛЛ endl;</code></p>
    <p><code>† q.pop();</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>binsrch1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int vector[100];</code></p>
    <p><code>†for (int i = 0; i Л 100; i++) vector[i] = i;</code></p>
    <p><code>†if (binary_search(vector, vector + 100, 42)) cout ЛЛ "found 42" ЛЛ endl;</code></p>
    <p><code>†else cout ЛЛ "did not find 42" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ptrunf2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>bool even(int n_) {</code></p>
    <p><code>†return (n_ % 2)†== 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int* p = find_if(array, array + 3, ptr_fun(even));</code></p>
    <p><code>†if (p != array + 3) cout ЛЛ *p ЛЛ " is even" ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rotcopy0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int result[6];</code></p>
    <p><code>†rotate_copy(numbers, numbers + 3, numbers + 6, result);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mkheap0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {5, 10, 4, 13, 11, 19};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†make_heap(numbers, numbers + 6);</code></p>
    <p><code>†for (int i = 6; i Ы= 1; i--) {</code></p>
    <p><code>† cout ЛЛ numbers[0] ЛЛ endl;</code></p>
    <p><code>† pop_heap(numbers, numbers + i);</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>copy1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>char string[23] = "A string to be copied.";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†char result[23];</code></p>
    <p><code>†copy(string, string + 23, result);</code></p>
    <p><code>†cout ЛЛ " Src: " ЛЛ string ЛЛ "\nDest: " ЛЛ result ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>find0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[10] = {0, 1, 4, 9, 16, 25, 36, 49, 64};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int* location;</code></p>
    <p><code>†location = find(numbers, numbers + 10, 25);</code></p>
    <p><code>†cout ЛЛ "Found 25 at offset " ЛЛ (location - numbers) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>partsum0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {1, 2, 3, 4, 5, 6};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int result[6];</code></p>
    <p><code>†partial_sum(numbers, numbers + 6, result);</code></p>
    <p><code>†for (int i = 0; i Л 6; i ++) cout ЛЛ result[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bvec1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†bit_vector b(3);</code></p>
    <p><code>†for (int i = 0; i Л b.size(); i++) cout ЛЛ b[i];</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†b[0] = b[2] = 1;</code></p>
    <p><code>†for (i = 0; i Л b.size(); i++) cout ЛЛ b[i];</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bind2nd1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†replace_if(array, array + 3, binder2ndЛgreaterЛintЫ Ы(greaterЛintЫ(), 2), 4);</code></p>
    <p><code>†for (int i = 0; i Л 3; i++) cout ЛЛ array[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bind1st1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int* p = remove_if(array, array + 3, binder1stЛlessЛintЫ Ы(lessЛintЫ(), 2));</code></p>
    <p><code>†for (int* i = array; i != p; i++) cout ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>reviter2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 5, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(array, array + 4);</code></p>
    <p><code>†vectorЛintЫ::reverse_iterator r;</code></p>
    <p><code>†for (r = v.rbegin(); r != v.rend(); r++) cout ЛЛ *r ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>copy2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(10);</code></p>
    <p><code>†for (int i = 0; i Л v.size(); i++) v[i] = i;</code></p>
    <p><code>†ostream_iteratorЛintЫ iter(cout, " ");</code></p>
    <p><code>†copy(v.begin(), v.end(), iter);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>max2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_) Л 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†cout ЛЛ max("shoe", "shine", str_compare) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>min2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstring.hЫ</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code>†return ::strcmp(a_, b_) Л 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†cout ЛЛ min("shoe", "shine", str_compare) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>parsrt0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {5, 2, 4, 3, 1, 6};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†partial_sort(numbers, numbers + 3, numbers + 6);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>partsrt0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {5, 2, 4, 3, 1, 6};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†partial_sort(numbers, numbers + 3, numbers + 6);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bnegate1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[4] = {4, 9, 7, 1};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†sort(array, array + 4, binary_negateЛgreaterЛintЫ Ы(greaterЛintЫ()));</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ array[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>nthelem0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {5, 2, 4, 1, 0, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†nth_element(numbers, numbers + 3, numbers + 6);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>revbit2.cpp</p>
    </title>
    <empty-line/>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 5, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†listЛintЫ v(array, array + 4);</code></p>
    <p><code>†listЛintЫ::reverse_iterator r;</code></p>
    <p><code>†for (r = v.rbegin(); r != v.rend(); r++) cout ЛЛ *r ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>count0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[10] = {1, 2, 4, 1, 2, 4, 1, 2, 4, 1};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int result = 0;</code></p>
    <p><code>†count(numbers, numbers + 10, 1, result);</code></p>
    <p><code>†cout ЛЛ "Found " ЛЛ result ЛЛ " 1's." ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>negate.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int input[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int output[3];</code></p>
    <p><code>†transform(input, input + 3, output, negateЛintЫ());</code></p>
    <p><code>†for (int i = 0; i Л 3; i++) cout ЛЛ output[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pqueue1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†priority_queueЛdequeЛintЫ, lessЛintЫ Ы q;</code></p>
    <p><code>†q.push(42);</code></p>
    <p><code>†q.push(101);</code></p>
    <p><code>†q.push(69);</code></p>
    <p><code>†while (!q.empty()) {</code></p>
    <p><code>† cout ЛЛ q.top() ЛЛ endl;</code></p>
    <p><code>† q.pop();</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>genern1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstdlib.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v1(10);</code></p>
    <p><code>†generate_n(v1.begin(), v1.size(), rand);</code></p>
    <p><code>†for (int i = 0; i Л 10; i++) cout ЛЛ v1[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rotate0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†rotate(numbers, numbers + 3, numbers + 6);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>foreach0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>void print(int a_) {</code></p>
    <p><code>†cout ЛЛ a_ ЛЛ ' ';</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[10] = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†for_each(numbers, numbers + 10, print);</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>alg2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int i[] = {1, 4, 2, 8, 2, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int n = 0; // Must be initialized, as count increments n.</code></p>
    <p><code>†count(i, i + 6, 2, n);</code></p>
    <p><code>†cout ЛЛ "Count of 2s = " ЛЛ n ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>gener1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstdlib.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int numbers[10];</code></p>
    <p><code>†generate(numbers, numbers + 10, rand);</code></p>
    <p><code>†for (int i = 0; i Л 10; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>replace0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 0, 1, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†replace(numbers, numbers + 6, 2, 42);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rndshuf0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {1, 2, 3, 4, 5, 6};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†random_shuffle(numbers, numbers + 6);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bind1st2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int* p = remove_if(array, array + 3, bind1st(lessЛintЫ(), 2));</code></p>
    <p><code>†for (int* i = array; i != p; i++) cout ЛЛ *i ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>unique1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[8] = {0, 1, 1, 2, 2, 2, 3, 4};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†unique(numbers, numbers + 8);</code></p>
    <p><code>†for (int i = 0; i Л 8; i ++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bind2nd2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†replace_if(array, array + 3, bind2nd(greaterЛint (), 2), 4);</code></p>
    <p><code>†for (int i = 0; i Л 3; i++) cout ЛЛ array[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec5.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 4, 9, 16};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(array, array + 4);</code></p>
    <p><code>†for (int i = 0; i Л v.size(); i++) cout ЛЛ "v[" ЛЛ i ЛЛ "] = " ЛЛ v[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iterswp0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†iter_swap(numbers, numbers + 3);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>remove1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {1, 2, 3, 1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†remove(numbers, numbers + 6, 1);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>stblsrt1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int array[6] = {1, 50, -10, 11, 42, 19};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†stable_sort(array, array + 6);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ array[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>reverse1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†reverse(numbers, numbers + 6);</code></p>
    <p><code>†for (int i = 0; i Л 6; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>logicnot.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>bool input[7] = {1, 0, 0, 1, 1, 1, 1};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int n = 0;</code></p>
    <p><code>†count_if(input, input + 7, logical_notЛboolЫ(), n);</code></p>
    <p><code>†cout ЛЛ "count = " ЛЛ n ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bnegate2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[4] = {4, 9, 7, 1};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†sort(array, array + 4, not2(greaterЛintЫ()));</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ array[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>queue1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†queueЛlistЛintЫ Ы q;</code></p>
    <p><code>†q.push(42);</code></p>
    <p><code>†q.push(101);</code></p>
    <p><code>†q.push(69);</code></p>
    <p><code>†while (!q.empty()) {</code></p>
    <p><code>† cout ЛЛ q.front() ЛЛ endl;</code></p>
    <p><code>† q.pop();</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>stack1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†stackЛdequeЛintЫ Ы s;</code></p>
    <p><code>†s.push(42);</code></p>
    <p><code>†s.push(101);</code></p>
    <p><code>†s.push(69);</code></p>
    <p><code>†while (!s.empty()) {</code></p>
    <p><code>† cout ЛЛ s.top() ЛЛ endl;</code></p>
    <p><code>† s.pop();</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>greateq.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[4] = {3, 1, 4, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†sort(array, array + 4, greater_equalЛintЫ());</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ array[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>stack2.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†stackЛlistЛintЫ Ы s;</code></p>
    <p><code>†s.push(42);</code></p>
    <p><code>†s.push(101);</code></p>
    <p><code>†s.push(69);</code></p>
    <p><code>†while (!s.empty()) {</code></p>
    <p><code>† cout ЛЛ s.top() ЛЛ endl;</code></p>
    <p><code>† s.pop();</code></p>
    <p><code>†}</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>lesseq.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[4] = {3, 1, 4, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†sort(array, array + 4, less_equalЛintЫ());</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ array[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>divides.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int input[3] = {2, 3, 4};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int result = accumulate(input, input + 3, 48, dividesЛintЫ());</code></p>
    <p><code>†cout ЛЛ "result = " ЛЛ result ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>greater.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[4] = {3, 1, 4, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†sort(array, array + 4, greaterЛintЫ());</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ array[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>swap1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int a = 42;</code></p>
    <p><code>†int b = 19;</code></p>
    <p><code>†cout ЛЛ "a = " ЛЛ a ЛЛ " b = " ЛЛ b ЛЛ endl;</code></p>
    <p><code>†swap(a, b);</code></p>
    <p><code>†cout ЛЛ "a = " ЛЛ a ЛЛ " b = " ЛЛ b ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>times.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int input[4] = {1, 5, 7, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int total = accumulate(input, input + 4, 1, timesЛintЫ());</code></p>
    <p><code>†cout ЛЛ "total = " ЛЛ total ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>less.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int array[4] = {3, 1, 4, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†sort(array, array + 4, lessЛintЫ ());</code></p>
    <p><code>†for (int i = 0; i Л 4; i++) cout ЛЛ array[i] ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>alg1.cpp</p>
    </title>
    <p><code>#include Лiostream.hЫ</code></p>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int i = min(4, 7);</code></p>
    <p><code>†cout ЛЛ "min(4, 7) = " ЛЛ i ЛЛ endl;</code></p>
    <p><code>†char c = maX('a', 'z');</code></p>
    <p><code>†cout ЛЛ "maX('a', 'z') = " ЛЛ c ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>filln1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(10);</code></p>
    <p><code>†fill_n(v.begin(), v.size(), 42);</code></p>
    <p><code>†for (int i = 0; i Л 10; i++) cout ЛЛ v[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iota1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int numbers[10];</code></p>
    <p><code>†iota(numbers, numbers + 10, 42);</code></p>
    <p><code>†for (int i = 0; i Л 10; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>nextprm0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int v1[3] = {0, 1, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†next_permutation(v1, v1 + 3);</code></p>
    <p><code>†for (int i = 0; i Л 3; i++) cout ЛЛ v1[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>prevprm0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int v1[3] = {0, 1, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†prev_permutation(v1, v1 + 3);</code></p>
    <p><code>†for (int i = 0; i Л 3; i++) cout ЛЛ v1[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>fill1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v(10);</code></p>
    <p><code>†fill(v.begin(), v.end(), 42);</code></p>
    <p><code>†for (int i = 0; i Л 10; i++) cout ЛЛ v[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pair2.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†pairЛint, intЫ p = make_pair(1, 10);</code></p>
    <p><code>†cout ЛЛ "p.first = " ЛЛ p.first ЛЛ endl;</code></p>
    <p><code>†cout ЛЛ "p.second = " ЛЛ p.second ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>error1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <empty-line/>
    <p><code>// Compile this code without defining the symbol OS_USE_EXCEPTIONS.</code></p>
    <p><code>int main() {</code></p>
    <p><code>†vectorЛintЫ v;</code></p>
    <p><code>†v.pop_back(); // Generates an empty object error.</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pair0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†pairЛint, intЫ p = make_pair(1, 10);</code></p>
    <p><code>†cout ЛЛ "p.first = " ЛЛ p.first ЛЛ ", p.second = " ЛЛ p.second ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pair1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†pairЛint, intЫ p = make_pair(1, 10);</code></p>
    <p><code>†cout ЛЛ "p.first = " ЛЛ p.first ЛЛ ", p.second = " ЛЛ p.second ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>minelem1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {-10, 15, -100, 36, -242, 42};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†cout ЛЛ *min_element(numbers, numbers + 6) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>maxelem1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {4, 10, 56, 11, -42, 19};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†cout ЛЛ *max_element(numbers, numbers + 6) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>max1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†cout ЛЛ max(42, 100) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>min1.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†cout ЛЛ min(42, 100) ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>adjdiff0.cpp</p>
    </title>
    <p><code>#include Лstl.hЫ</code></p>
    <p><code>#include Лiostream.hЫ</code></p>
    <empty-line/>
    <p><code>int numbers[5] = {1, 2, 4, 8, 16};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>†int difference[5];</code></p>
    <p><code>†adjacent_difference(numbers, numbers + 5, difference);</code></p>
    <p><code>†for (int i = 0; i Л 5; i++) cout ЛЛ numbers[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†for (i = 0; i Л 5; i++) cout ЛЛ difference[i] ЛЛ ' ';</code></p>
    <p><code>†cout ЛЛ endl;</code></p>
    <p><code>†return 0;</code></p>
    <p><code>}</code></p>
   </section>
  </section>
 </body>
</FictionBook>
