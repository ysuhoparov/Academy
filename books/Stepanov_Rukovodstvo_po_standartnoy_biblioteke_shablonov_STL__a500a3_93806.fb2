<?xml version="1.0" encoding="windows-1251"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink">
 <description>
  <title-info>
   <genre>comp_programming</genre>
   <author>
    <first-name>Александр</first-name>
    <last-name>Степанов</last-name>
    <email>stepanov@mti.sgi.com</email>
   </author>
   <author>
    <first-name>Менг</first-name>
    <last-name>Ли</last-name>
    <email>lee@hlp.hp.com</email>
   </author>
   <book-title>РУКОВОДСТВО ПО СТАНДАРТНОЙ БИБЛИОТЕКЕ ШАБЛОНОВ (STL)</book-title>
   <date>1999</date>
   <lang>ru</lang>
   <src-lang>en</src-lang>
   <translator>
    <first-name>Алексей</first-name>
    <last-name>Суханов</last-name>
   </translator>
   <translator>
    <first-name>Андрей</first-name>
    <last-name>Кутырин</last-name>
   </translator>
  </title-info>
  <document-info>
   <author>
    <nickname>honorato bonafe</nickname>
   </author>
   <program-used>Fiction Book Designer, FB Editor v2.0</program-used>
   <date value="2009-09-02">02.09.2009</date>
   <id>FBD-9F0713-1705-7D48-14A2-7EFB-4F34-F62F8A</id>
   <version>1.0</version>
   <history>
    <p>1.0 chm-›fb2 </p>
   </history>
  </document-info>
  <publish-info>
   <publisher>МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ ИНСТИТУТ РАДИОТЕХНИКИ, ЭЛЕКТРОНИКИ И АВТОМАТИКИ (ТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ)</publisher>
   <city>Москва</city>
   <year>1999</year>
  </publish-info>
 </description>
 <body>
  <title>
   <p>Александр Степанов</p>
   <p>Менг Ли</p>
   <p>РУКОВОДСТВО ПО СТАНДАРТНОЙ БИБЛИОТЕКЕ ШАБЛОНОВ (STL)</p>
  </title>
  <section>
   <title>
    <p>Введение</p>
   </title>
   <p>Стандартная Библиотека Шаблонов предоставляет набор хорошо сконструированных и согласованно работающих вместе обобщённых компонентов C++. Особая забота была проявлена для обеспечения того, чтобы все шаблонные алгоритмы работали не только со структурами данных в библиотеке, но также и с встроенными структурами данных C++. Например, все алгоритмы работают с обычными указателями. Ортогональный проект библиотеки позволяет программистам использовать библиотечные структуры данных со своими собственными алгоритмами, а библиотечные алгоритмы - со своими собственными структурами данных. Хорошо определённые семантические требования и требования сложности гарантируют, что компонент пользователя будет работать с библиотекой и что он будет работать эффективно. Эта гибкость обеспечивает широкую применимость библиотеки.</p>
   <p>Другое важное соображение - эффективность. C++ успешен, потому что он объединяет выразительную мощность с эффективностью. Много усилий было потрачено, чтобы проверить, что каждый шаблонный компонент в библиотеке имеет обобщённую реализацию, которая имеет эффективность выполнения с разницей в пределах нескольких процентов от эффективности соответствующей программы ручной кодировки.</p>
   <p>Третьим соображением в проекте была разработка библиотечной структуры, которая, будучи естественной и лёгкой для понимания, основана на прочной теоретической основе.</p>
  </section>
  <section>
   <title>
    <p>Структура библиотеки</p>
   </title>
   <p>Библиотека содержит пять основных видов компонентов:</p>
   <p>- алгоритм (<emphasis>algorithm</emphasis>): определяет вычислительную процедуру.</p>
   <p>- контейнер (<emphasis>container</emphasis>): управляет набором объектов в памяти.</p>
   <p>- итератор (<emphasis>iterator</emphasis>): обеспечивает для алгоритма средство доступа к содержимому контейнера.</p>
   <p>- функциональный объект (<emphasis>function object</emphasis>): инкапсулирует функцию в объекте для использования другими компонентами.</p>
   <p>- адаптер (<emphasis>adaptor</emphasis>): адаптирует компонент для обеспечения различного интерфейса.</p>
   <p>Такое разделение позволяет нам уменьшить количество компонентов. Например, вместо написания функции поиска элемента для каждого вида контейнера мы обеспечиваем единственную версию, которая работает с каждым из них, пока удовлетворяется основной набор требований.</p>
   <p>Следующее описание разъясняет структуру библиотеки. Если программные компоненты сведены в таблицу как трёхмерный массив, где одно измерение представляет различные типы данных (например, int, double), второе измерение представляет различные контейнеры (например, вектор, связный список, файл), а третье измерение представляет различные алгоритмы с контейнерами (например, поиск, сортировка, перемещение по кругу), если i, j и k - размеры измерений, тогда должно быть разработано i* j *k различных версий кода. При использовании шаблонных функций, которые берут параметрами типы данных, нам нужно только j * k версий. Далее, если заставим наши алгоритмы работать с различными контейнерами, то нам нужно просто j+k версий. Это значительно упрощает разработку программ, а также позволяет очень гибким способом использовать компоненты в библиотеке вместе с определяемыми пользователем компонентами. Пользователь может легко определить специализированный контейнерный класс и использовать для него библиотечную функцию сортировки. Для сортировки пользователь может выбрать какую-то другую функцию сравнения либо через обычный указатель на сравнивающую функцию, либо через функциональный объект (объект, для которого определён operator()), который сравнивает. Если пользователю необходимо выполнить передвижение через контейнер в обратном направлении, то используется адаптер reverse_iterator.</p>
   <p>Библиотека расширяет основные средства C++ последовательным способом, так что программисту на C/C++ легко начать пользоваться библиотекой. Например, библиотека содержит шаблонную функцию merge (слияние). Когда пользователю нужно два массива a и b объединить в с, то это может быть выполнено так:</p>
   <p><code>int a[1000];</code></p>
   <p><code>int b[2000];</code></p>
   <p><code>int c[3000];</code></p>
   <p><code>…</code></p>
   <p><code>merge(a, a+1000, b, b+2000, c);</code></p>
   <p>Когда пользователь хочет объединить вектор и список (оба - шаблонные классы в библиотеке) и поместить результат в заново распределённую неинициализированную память, то это может быть выполнено так:</p>
   <p><code>vector‹Employee› a;</code></p>
   <p><code>list‹Employee› b;</code></p>
   <p><code>…</code></p>
   <p><code>Employee* с = allocate(a.size() + b.size(), (Employee*)0);</code></p>
   <p><code>merge(a.begin(), a.end(), b.begin(), b.end(), raw_storage_iterator‹Employee*, Employee›(c));</code></p>
   <p>где begin() и end() - функции-члены контейнеров, которые возвращают правильные типы итераторов или указателе-подобных объектов, позволяющие merge выполнить задание, а raw_storage_iterator - адаптер, который позволяет алгоритмам помещать результаты непосредственно в неинициализированную память, вызывая соответствующий конструктор копирования.</p>
   <p>Во многих случаях полезно перемещаться через потоки ввода-вывода таким же образом, как через обычные структуры данных. Например, если мы хотим объединить две структуры данных и затем сохранить их в файле, было бы хорошо избежать создания вспомогательной структуры данных для хранения результата, а поместить результат непосредственно в соответствующий файл. Библиотека обеспечивает и istream_iterator, и ostream_iterator шаблонные классы, чтобы многие из библиотечных алгоритмов могли работать с потоками ввода-вывода, которые представляют однородные блоки данных. Далее приводится программа, которая читает файл, состоящий из целых чисел, из стандартного ввода, удаляя все числа, делящиеся на параметр команды, и записывает результат в стандартный вывод:</p>
   <p><code>main(int argc, char** argv) {</code></p>
   <p><code> if (argc!= 2) throw("usage: remove_if_divides integer\n ");</code></p>
   <p><code> remove_copy_if(istream_iterator‹int›(cin), istream_iterator‹int›(), ostream_iterator‹int›(cout, "\n"),  not1(bind2nd(modulus‹int›(), atoi(argv[1]))));</code></p>
   <p><code>}</code></p>
   <p>Вся работа выполняется алгоритмом remove_copy_if, который читает целые числа одно за другим, пока итератор ввода не становится равным <emphasis>end-of-stream</emphasis> (<emphasis>конец-потока</emphasis>) итератору, который создаётся конструктором без параметров. (Вообще все алгоритмы работают способом "отсюда досюда", используя два итератора, которые показывают начало и конец ввода.) Потом remove_copy_if записывает целые числа, которые выдерживают проверку, в выходной поток через итератор вывода, который связан с cout. В качестве предиката remove_copy_if использует функциональный объект, созданный из функционального объекта modulus‹int›, который берёт i и j и возвращает i % j как бинарный предикат, и превращает в унарный предикат, используя bind2nd, чтобы связать второй параметр с параметром командной строки atoi(argv[1]). Потом отрицание этого унарного предиката получается с помощью адаптера функции not1.</p>
   <p>Несколько более реалистичный пример - фильтрующая программа, которая берёт файл и беспорядочно перетасовывает его строки.</p>
   <p><code>main(int argc, char**) {</code></p>
   <p><code> if (argc!= 1) throw("usage: shuffle\n");</code></p>
   <p><code> vector‹string› v;</code></p>
   <p><code> copy(istream_iterator‹string›(cin), istream_iterator‹string›(), inserter(v, v.end()));</code></p>
   <p><code> random_shuffle(v.begin(), v.end());</code></p>
   <p><code> copy(v.begin(), v.end(), ostream_iterator‹string›(cout));</code></p>
   <p><code>}</code></p>
   <p>В этом примере copy перемещает строки из стандартного ввода в вектор, но так как вектор предварительно не размещён в памяти, используется итератор вставки, чтобы вставить в вектор строки одну за другой. (Эта методика позволяет всем функциям копирования работать в обычном режиме замены также, как в режиме вставки.) Потом random_shuffle перетасовывает вектор, а другой вызов copy копирует его в поток cout.</p>
  </section>
  <section>
   <title>
    <p>Требования</p>
   </title>
   <p>Для гарантии совместной работы различные компоненты библиотеки должны удовлетворять некоторым основным требованиям. Требования должны быть общими, насколько это возможно, так что вместо высказывания "класс X должен определить функцию-член operator++() ", мы говорим "для любого объекта x класса X определён ++x ". (Не определено, является ли оператор членом или глобальной функцией.) Требования установлены в терминах чётких выражений, которые определяют допустимые условия типов, удовлетворяющих требованиям. Для каждого набора требований имеется таблица, которая определяет начальный набор допустимых выражений и их семантику. Любой обобщённый алгоритм, который использует требования, должен быть написан в терминах допустимых выражений для своих формальных параметров.</p>
   <p>Если требуется, чтобы была операция линейного времени сложности, это значит - не хуже, чем линейного времени, и операция постоянного времени удовлетворяет требованию.</p>
   <p>В некоторых случаях мы представили семантические требования, использующие код C++. Такой код предназначен как спецификация эквивалентности одной конструкции другой, не обязательно как способ, которым конструкция должна быть реализована (хотя в некоторых случаях данный код, однозначно, является оптимальной реализацией).</p>
  </section>
  <section>
   <title>
    <p>Основные компоненты</p>
   </title>
   <section>
    <p>Этот раздел содержит некоторые основные шаблонные функции и классы, которые используются в остальной части библиотеки.</p>
   </section>
   <section>
    <title>
     <p>Операторы (Operators)</p>
    </title>
    <p>Чтобы избежать избыточных определений operator!= из operator== и operator›, ‹=, ›= из operator‹, библиотека обеспечивает следующее:</p>
    <p><code>template ‹class Tl, class T2›</code></p>
    <p><code>inline bool operator!=(const T1&amp; x, const T2&amp; y) {</code></p>
    <p><code> return !(x == y);</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>template ‹class Tl, class T2›</code></p>
    <p><code>inline bool operator›(const T1&amp; x, const T2&amp; y) {</code></p>
    <p><code> return y ‹ x;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>template ‹class Tl, class T2›</code></p>
    <p><code>inline bool operator‹=(const T1&amp; x, const T2&amp; y) {</code></p>
    <p><code> return !(y ‹ x);</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>template ‹class Tl, class T2›</code></p>
    <p><code>inline bool operator›=(const T1&amp; x, const T2&amp; y) {</code></p>
    <p><code> return !(x ‹ y);</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>Пара (Pair)</p>
    </title>
    <p>Библиотека включает шаблоны для разнородных пар значений.</p>
    <p><code>template ‹class T1, class T2›</code></p>
    <p><code>struct pair {</code></p>
    <p><code> T1 first;</code></p>
    <p><code> T2 second;</code></p>
    <p><code> pair() {}</code></p>
    <p><code> pair(const T1&amp; x, const T2&amp; y): first(x), second(y) {}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>template ‹class T1, class T2›</code></p>
    <p><code>inline bool operator==(const pair‹Tl,T2›&amp; x, const pair‹Tl,T2›&amp; y) {</code></p>
    <p><code> return x.first == y.first &amp;&amp; x.second == y.second;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>template ‹class T1, class T2›</code></p>
    <p><code>inline bool operator‹(const pair‹Tl,T2›&amp; x, const pair‹Tl,T2›&amp; y) {</code></p>
    <p><code> return x.first ‹ y.first || (!(y.first ‹ x.first) &amp;&amp; x.second ‹ y.second);</code></p>
    <p><code>}</code></p>
    <p>Библиотека обеспечивает соответствующую шаблонную функцию make_pair, чтобы упростить конструкцию пар. Вместо выражения, например:</p>
    <p><code>return pair‹int, double›(5, 3.1415926); // явные типы,</code></p>
    <p>можно написать</p>
    <p><code>return make_pair(5, 3.1415926); // типы выводятся.</code></p>
    <empty-line/>
    <p><code>template ‹class Tl, class T2›</code></p>
    <p><code>inline pair‹Tl,T2› make_pair(const T1&amp; x, const T2&amp; y) {</code></p>
    <p><code> return pair‹Tl,T2›(x, y);</code></p>
    <p><code>}</code></p>
   </section>
  </section>
  <section>
   <title>
    <p>Итераторы</p>
   </title>
   <section>
    <p>Итераторы - это обобщение указателей, которые позволяют программисту работать с различными структурами данных (контейнерами) единообразным способом. Чтобы создать шаблонные алгоритмы, которые правильно и эффективно работают с различными типами структур данных, нам нужно формализовать не только интерфейсы, но также семантику и предположения сложности итераторов. Итераторы - это объекты, которые имеют operator*, возвращающий значение некоторого класса или встроенного типа T, называемого <emphasis>значимым типом</emphasis> (<emphasis>value type</emphasis>) итератора. Для каждого типа итератора X, для которого определено равенство, имеется соответствующий знаковый целочисленный тип, называемый <emphasis>типом расстояния</emphasis> (<emphasis>distanсe type</emphasis>) итератора.</p>
    <p>Так как итераторы - обобщение указателей, их семантика - обобщение семантики указателей в C++. Это гарантирует, что каждая шаблонная функция, которая использует итераторы, работает с обычными указателями. Есть пять категорий итераторов в зависимости от операций, определённых для них: <emphasis>ввода</emphasis> (<emphasis>input iterators</emphasis>), <emphasis>вывода</emphasis> (<emphasis>output iterators</emphasis>), <emphasis>последовательные</emphasis> (<emphasis>forward iterators</emphasis>), <emphasis>двунаправленные</emphasis> (<emphasis>bidirectional iterators</emphasis>) и <emphasis>произвольного доступа</emphasis> (<emphasis>random access iterators</emphasis>.) Последовательные итераторы удовлетворяют всем требованиям итераторов ввода и вывода и могут использоваться всякий раз, когда определяется тот или другой вид. Двунаправленные итераторы удовлетворяют всем требованиям последовательных итераторов и могут использоваться всякий раз, когда определяется последовательный итератор. Итераторы произвольного доступа удовлетворяют всем требованиям двунаправленных итераторов и могут использоваться всякий раз, когда определяется двунаправленный итератор. Имеется дополнительный атрибут, который могли быть иметь последовательные, двунаправленные и произвольного доступа итераторы, то есть они могут быть <emphasis>модифицируемые</emphasis> (<emphasis>mutable</emphasis>) или <emphasis>постоянные</emphasis> (<emphasis>constant</emphasis>) в зависимости от того, ведёт ли себя результат operator* как ссылка или как ссылка на константу. Постоянные итераторы не удовлетворяют требованиям итераторов вывода.</p>
    <p><strong>Таблица 1. Отношения среди категорий итераторов</strong> </p>
    <table>
     <tr align="left">
      <td rowspan="2" align="left" valign="top">Произвольного доступа -› Двунаправленные -› Последовательные --&gt; </td>
      <td align="left" valign="top">- › Ввода </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">- › Вывода</td>
     </tr>
    </table>
    <p>Точно также, как обычный указатель на массив гарантирует, что имеется значение указателя, указывающего за последний элемент массива, так и для любого типа итератора имеется значение итератора, который указывает за последний элемент соответствующего контейнера. Эти значения называются <emphasis>законечными</emphasis> (<emphasis>past-the-end</emphasis>) значениями. Значения итератора, для которых operator* определён, называются <emphasis>разыменовываемыми</emphasis> (<emphasis>dereferenceable</emphasis>). Библиотека никогда не допускает, что законечные значения являются разыменовываемыми. Итераторы могут также иметь <emphasis>исключительные</emphasis> (<emphasis>singular</emphasis>) значения, которые не связаны ни с каким контейнером. Например, после объявления неинициализированного указателя x (например, int* x;), всегда должно предполагаться, что x имеет исключительное значение указателя. Результаты большинства выражений не определены для исключительных значений. Единственное исключение - присваивание неисключительного значения итератору, который имеет исключительное значение. В этом случае исключительное значение перезаписывается таким же образом, как любое другое значение. Разыменовываемые и законечные значения всегда являются неисключительными.</p>
    <p>Итератор j называется <emphasis>доступным</emphasis> (<emphasis>reachable</emphasis>) из итератора i, если и только если имеется конечная последовательность применений operator++ к i, которая делает i==j. Если i и j относятся к одному и тому же контейнеру, тогда или j доступен из i, или i доступен из j, или оба доступны (i==j).</p>
    <p>Большинство алгоритмических шаблонов библиотеки, которые работают со структурами данных, имеют интерфейсы, которые используют диапазоны. Диапазон - это пара итераторов, которые указывают начало и конец вычисления. Интервал [i,i) - пустой диапазон; вообще, диапазон [i,j) относится к элементам в структуре данных, начиная с элемента, указываемого i, и до элемента, но не включая его, указываемого j. Диапазон [i,j) допустим, если и только если j доступен из i. Результат применения алгоритмов библиотеки к недопустимым диапазонам не определён.</p>
    <p>Все категории итераторов требуют только те функции, которые осуществимы для данной категории со сложностью постоянного времени (амортизированные). Поэтому таблицы требований для итераторов не имеют столбца сложности.</p>
    <p>В следующих разделах мы принимаем: a и b - значения X, n - значение типа расстояния Distance, u, tmp и m - идентификаторы, r и s - леводопустимые (lvalues) значения X, t - значение значимого типа T.</p>
   </section>
   <section>
    <title>
     <p>Итераторы ввода (Input iterators)</p>
    </title>
    <p>Класс или встроенный тип X удовлетворяет требованиям итератора ввода для значимого типа T, если справедливы следующие выражения:</p>
    <p><strong>Таблица 2. Требования итератора ввода</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнения </th>
      <th align="left" valign="top">утверждение/примечание состояние до/после </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X(a)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">X(a) - копия a. примечание: предполагается деструктор. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X u(a); <emphasis>X u = a; </emphasis></td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">после: u - копия a.</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">u = a </td>
      <td align="left" valign="top">X&amp;</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">после: u - копия a. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a == b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">если a - копия b, тогда a == b возвращает true. == - это отношение эквивалентности в области действия ==. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a!= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a == b)</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">*a </td>
      <td align="left" valign="top">обратимый в T</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">до: a - разыменовываемое. если a - копия b, то *a эквивалентно *b. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">++r </td>
      <td align="left" valign="top">X&amp;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">до: r - разыменовываемое. после: r - разыменовываемое или r - законечное. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">void r++ </td>
      <td align="left" valign="top">void </td>
      <td align="left" valign="top">void ++r</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">*r++ </td>
      <td align="left" valign="top">Т </td>
      <td align="left" valign="top">{X tmp = r; ++r; return tmp;}</td>
      <td align="left" valign="top">-</td>
     </tr>
    </table>
    <p><strong>ПРИМЕЧАНИЕ.</strong> Для итераторов ввода нет никаких требований на тип или значение r++ кроме требования, чтобы *r++ работал соответственным образом. В частности, r == s не подразумевает, что ++r == ++s. (Равенство не гарантирует свойство замены или ссылочной прозрачности.) Что касается ++r, то нет больше никаких требований на значения любых копий r за исключением того, что они могут быть безопасно уничтожены или присвоены. После выполнения ++r не требуется, чтобы были копии (предыдущего) r в области ==. Алгоритмы с итераторами ввода никогда не должны пытаться проходить через тот же самый итератор дважды. Они должны быть <emphasis>однопроходными</emphasis> (<emphasis>single pass</emphasis>) алгоритмами. <emphasis>Не требуется, чтобы значимый тип T был леводопустимым типом (lvalue type)</emphasis>. Эти алгоритмы могут использоваться с входными потоками как источниками входных данных через класс istream_iterator.</p>
   </section>
   <section>
    <title>
     <p>Итераторы вывода (Output iterators)</p>
    </title>
    <p>Класс или встроенный тип X удовлетворяет требованиям итератора вывода, если справедливы следующие выражения:</p>
    <p><strong>Таблица 3. Требования итератора вывода</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнения </th>
      <th align="left" valign="top">утверждение/примечание состояние до/после </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X(a)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">*a = t эквивалентно *X(a) = t. примечание: предполагается деструктор. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X u(a); <emphasis>X u = a; </emphasis></td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">*a = t </td>
      <td align="left" valign="top">результат не используется</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">++r </td>
      <td align="left" valign="top">X&amp;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r++ </td>
      <td align="left" valign="top">Х или Х&amp;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
     </tr>
    </table>
    <p><strong>ПРИМЕЧАНИЕ.</strong> Единственное допустимое использование operator* - на левой стороне выражения присваивания. <emphasis>Присваивание через то же самое значение итератора происходит только однажды</emphasis>. Алгоритмы с итераторами вывода никогда не должны пытаться проходить через тот же самый итератор дважды. Они должны быть <emphasis>однопроходными</emphasis> (<emphasis>single pass</emphasis>) алгоритмами. Равенство и неравенство не обязательно определены. Алгоритмы, которые берут итераторы вывода, могут использоваться с выходными потоками для помещения в них данных через класс ostream_iterator, также как с итераторами вставки и вставляющими указателями. В частности, следующие два условия должны соблюдаться: во-первых, через любое значение итератора должно выполняться присваивание до его увеличения (то есть, для итератора вывода i недопустима последовательность кода i++; i++;); во-вторых, любое значение итератора вывода может иметь только одну активную копию в любое данное время (например, недопустима последовательность кода i = j; *++i = a; *j = b;).</p>
   </section>
   <section>
    <title>
     <p>Последовательные итераторы (Forward iterators)</p>
    </title>
    <p>Класс или встроенный тип X удовлетворяет требованиям последовательного итератора, если справедливы следующие выражения:</p>
    <p><strong>Таблица 4. Требования последовательного итератора</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнения </th>
      <th align="left" valign="top">утверждение/примечание состояние до/после</th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X u;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">примечание: u может иметь исключительное значение. примечание: предполагается деструктор. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X()</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">примечание: X() может быть исключительным. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X(a);</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">a == X(a) </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X u(a); X u = a;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">X u; u = a; </td>
      <td align="left" valign="top">после: u == a. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a == b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">== - это отношение эквивалентности. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a!= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a == b)</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r = a </td>
      <td align="left" valign="top">X&amp;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">после: r == a. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">*a </td>
      <td align="left" valign="top">обратимый в T</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">до: a - разыменовываемое. a==b подразумевает *a==*b. Если X - модифицируемый, то *a = t - допустимо. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">++r </td>
      <td align="left" valign="top">X&amp;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">до: r - разыменовываемое. после: r - разыменовываемое или r - законечное. r == s и r - разыменовываемое подразумевает ++r==++s. &amp;r==&amp;++r. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r++ </td>
      <td align="left" valign="top">X </td>
      <td align="left" valign="top">{X tmp = r; <emphasis>++ r; return tmp;}</emphasis></td>
      <td align="left" valign="top">- </td>
     </tr>
    </table>
    <p><strong>ПРИМЕЧАНИЕ.</strong> Тот факт, что r == s подразумевает ++r == ++s (что неверно для итераторов ввода и вывода) и что удалено ограничение на число присваиваний через итератор (которое применяется к итераторам вывода), позволяет использование многопроходных однонаправленных алгоритмов с последовательными итераторами.</p>
   </section>
   <section>
    <title>
     <p>Двунаправленные итераторы (Bidirectional iterators)</p>
    </title>
    <p>Класс или встроенный тип X удовлетворяет требованиям двунаправленного итератора, если к таблице, которая определяет последовательные итераторы, мы добавим следующие строки:</p>
    <p><strong>Таблица 5. Требования двунаправленного итератора (в дополнение к последовательному итератору)</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнения </th>
      <th align="left" valign="top">утверждение/примечание состояние до/после </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">--r </td>
      <td align="left" valign="top">X&amp;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">до: существует s такое, что r==++s. после: s - разыменовываемое. --(++r)==r. --r==--s подразумевает r==s.&amp;r==&amp;--r. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r-- </td>
      <td align="left" valign="top">X </td>
      <td align="left" valign="top">{X tmp = r; -<emphasis>-r; return tmp;}</emphasis></td>
      <td align="left" valign="top"><emphasis>-</emphasis> </td>
     </tr>
    </table>
    <p><strong>ПРИМЕЧАНИЕ.</strong> Двунаправленные итераторы позволяют алгоритмам перемещать итераторы назад так же, как вперёд.</p>
   </section>
   <section>
    <title>
     <p>Итераторы произвольного доступа (Random access iterators)</p>
    </title>
    <p>Класс или встроенный тип X удовлетворяет требованиям итераторов произвольного доступа, если к таблице, которая определяет двунаправленные итераторы, мы добавим следующие строки:</p>
    <p><strong>Таблица 6: Требования итератора произвольного доступа (в дополнение к двунаправленному итератору)</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнения </th>
      <th align="left" valign="top">утверждение/примечание состояние до/после </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r += n </td>
      <td align="left" valign="top">X&amp; </td>
      <td align="left" valign="top">{Distance m = n; if(m ›= 0) while(m--) ++r; else while(m++) --r; return r;}</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a + n <emphasis>n + a </emphasis></td>
      <td align="left" valign="top">X </td>
      <td align="left" valign="top">{X tmp = a; <emphasis>return tmp += n;} </emphasis></td>
      <td align="left" valign="top">a + n == n + a. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r -= n</td>
      <td align="left" valign="top">X&amp; </td>
      <td align="left" valign="top">return r += -n;</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a - n </td>
      <td align="left" valign="top">X </td>
      <td align="left" valign="top">{X tmp = a; <emphasis>return tmp -= n;}</emphasis></td>
      <td align="left" valign="top"><emphasis>-</emphasis></td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">b - a </td>
      <td align="left" valign="top">Distance</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">до: существует значение n типа Distance такое, что a+n=b. b==a+(b-a). </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a[n] </td>
      <td align="left" valign="top">обратимый в T</td>
      <td align="left" valign="top">*(a + n)</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a ‹ b </td>
      <td align="left" valign="top">обратимый в bool </td>
      <td align="left" valign="top">b - a › 0 </td>
      <td align="left" valign="top">‹ - это отношение полного упорядочения </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a › b </td>
      <td align="left" valign="top">обратимый в bool </td>
      <td align="left" valign="top">b ‹ a </td>
      <td align="left" valign="top">› - это отношение полного упорядочения, противоположное ‹. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a ›= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a ‹ b)</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a ‹= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a › b)</td>
      <td align="left" valign="top">- </td>
     </tr>
    </table>
   </section>
   <section>
    <title>
     <p>Теги итераторов (Iterator tags)</p>
    </title>
    <section>
     <p>Чтобы осуществлять алгоритмы только в терминах итераторов, часто бывает необходимо вывести тип значения и тип расстояния из итератора. Для решения этой задачи требуется, чтобы для итератора i любой категории, отличной от итератора вывода, выражение value_type(i) возвращало (T*)(0), а выражение distance_type(i) возвращало (Distance*)(0). Для итераторов вывода эти выражения не требуются.</p>
    </section>
    <section>
     <title>
      <p>Примеры использования тегов итераторов</p>
     </title>
     <p>Для всех типов обычных указателей мы можем определить value_type и distance_type с помощью следующего:</p>
     <p><code>template ‹class T›</code></p>
     <p><code>inline T* value_type(const T*) {return (T*)(0);}</code></p>
     <empty-line/>
     <p><code>template ‹class T›</code></p>
     <p><code>inline ptrdiff_t* distance_type(const T*) {return (ptrdiff_t*)(0);}</code></p>
     <p>Тогда, если мы хотим осуществить обобщённую функцию reverse, мы пишем следующее:</p>
     <p><code>template ‹class BidirectionalIterator›</code></p>
     <p><code>inline void reverse(BidirectionalIterator first, BidirectionalIterator last) {</code></p>
     <p><code> _reverse(first, last, value_type(first), distance_type(first));</code></p>
     <p><code>}</code></p>
     <p>где _reverse определена следующим образом:</p>
     <p><code>template ‹class BidirectionalIterator, class T, class Distance›</code></p>
     <p><code>void _reverse(BidirectionalIterator first, BidirectionalIterator last, T*, Distance*) {</code></p>
     <p><code> Distance n;</code></p>
     <p><code> distance(first, last, n); // смотри раздел "Операции с итераторами"</code></p>
     <p><code> --n;</code></p>
     <p><code> while (n › 0) {</code></p>
     <p><code>  T tmp = *first;</code></p>
     <p><code>  *first++ = *--last;</code></p>
     <p><code>  *last = tmp;</code></p>
     <p><code>  n -= 2;</code></p>
     <p><code> }</code></p>
     <p><code>}</code></p>
     <p>Если имеется дополнительный тип указателя _huge такой, что разность двух указателей _huge имеет тип long long, мы определяем:</p>
     <p><code>template ‹class T›</code></p>
     <p><code>inline T* value_type(const T _huge *) {return (T*) (0);}</code></p>
     <empty-line/>
     <p><code>template ‹class T›</code></p>
     <p><code>inline long long* distance_type(const T _huge *) {</code></p>
     <p><code> return (long long*)(0);</code></p>
     <p><code>}</code></p>
     <p>Часто желательно для шаблонной функции выяснить, какова наиболее специфичная категория её итераторного аргумента, так чтобы функция могла выбирать наиболее эффективный алгоритм во время компиляции. Чтобы облегчить это, библиотека вводит классы <emphasis>тегов категорий</emphasis> (<emphasis>category tag</emphasis>), которые используются как теги времени компиляции для выбора алгоритма. Это следущие теги: input_iterator_tag, output_iterator_tag, forward_iterator_tag, bidirectional_iterator_tag и random_access_iterator_tag. Каждый итератор i должен иметь выражение iterator_category(i), определённое для него, которое возвращает тег наиболее специфичной категории, который описывает его поведение. Например, мы определяем, что все типы указателей находятся в категории итераторов произвольного доступа:</p>
     <p><code>template ‹class T›</code></p>
     <p><code>inline random_access_iterator_tag iterator_category(const T*) {</code></p>
     <p><code> return random_access_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p>Определяемый пользователем итератор BinaryTreeIterator может быть включен в категорию двунаправленных итераторов следующим образом:</p>
     <p><code>template ‹class T›</code></p>
     <p><code>inline bidirectional_iterator_tag iterator_category(const BinaryTreeIterator‹T›&amp;) {</code></p>
     <p><code> return bidirectional_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p>Если шаблонная функция evolve хорошо определена для двунаправленных итераторов, но может быть осуществлена более эффективно для итераторов произвольного доступа, тогда реализация выглядит так:</p>
     <p><code>template ‹class BidirectionalIterator›</code></p>
     <p><code>inline void evolve(BidirectionalIterator first, BidirectionalIterator last) {</code></p>
     <p><code> evolve(first, last, iterator_category(first));</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template ‹class BidirectionalIterator›</code></p>
     <p><code>void evolve(BidirectionalIterator first, BidirectionalIterator last, bidirectional_iterator_tag) {</code></p>
     <p><code> //… более универсальный, но менее эффективный алгоритм</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator›</code></p>
     <p><code>void evolve(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag) {</code></p>
     <p><code> //… более эффективный, но менее универсальный алгоритм</code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>Примитивы, определённые в библиотеке</p>
     </title>
     <p>Чтобы упростить задачу определения iterator_category, value_type и distance_type для определяемых пользователем итераторов, библиотека обеспечивает следующие предопределённые классы и функции:</p>
     <p><code>// iterator tags (теги итераторов)</code></p>
     <p><code>struct input_iterator_tag {};</code></p>
     <p><code>struct output_iterator_tag {};</code></p>
     <p><code>struct forward_iterator_tag {};</code></p>
     <p><code>struct bidirectional_iterator_tag {};</code></p>
     <p><code>struct random_access_iterator_tag {};</code></p>
     <empty-line/>
     <p><code>// iterator bases (базовые классы итераторов)</code></p>
     <p><code>template ‹class T, class Distance = ptrdiff_t› struct input_iterator {};</code></p>
     <p><code>struct output_iterator {};</code></p>
     <p><code>// output_iterator не шаблон, потому что у итераторов вывода</code></p>
     <p><code>// не определены ни значимый тип, ни тип расстояния.</code></p>
     <p><code>template ‹class T, class Distance = ptrdiff_t›</code></p>
     <p><code>struct forward_iterator {};</code></p>
     <p><code>template ‹class T, class Distance = ptrdiff_t›</code></p>
     <p><code>struct bidirectional_iterator {};</code></p>
     <p><code>template ‹class T, class Distance = ptrdiff_t›</code></p>
     <p><code>struct random_access_iterator {};</code></p>
     <empty-line/>
     <p><code>// iterator_category (функции категорий итераторов)</code></p>
     <p><code>template ‹class T, class Distance›</code></p>
     <p><code>inline input_iterator_tag iterator_category(const input_iterator‹T, Distance›&amp;) {</code></p>
     <p><code> return input_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p><code>inline output_iterator_tag iterator_category(const output_iterator&amp;) {</code></p>
     <p><code> return output_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p><code>template ‹class T, class Distance›</code></p>
     <p><code>inline forward_iterator_tag iterator_category(const forward_iterator‹T, Distance›&amp;) {</code></p>
     <p><code> return forward_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p><code>template ‹class T, class Distance› </code></p>
     <p><code>inline bidirectional_iterator_tag iterator_category(const bidirectional_iterator‹T, Distance›&amp;) {</code></p>
     <p><code> return bidirectional_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p><code>template ‹class T, class Distance›</code></p>
     <p><code>inline random_access_iterator_tag iterator_category(const random_access_iterator‹T, Distance›&amp;) {</code></p>
     <p><code> return random_access_iterator_tag();</code></p>
     <p><code>}</code></p>
     <p><code>template ‹class T›</code></p>
     <p><code>inline random_access_iterator_tag iterator_category(const T*) {</code></p>
     <p><code> return random_access_iterator_tag();</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>// value_type of iterator (функции значимого типа итераторов)</code></p>
     <p><code>template ‹class T, class Distance›</code></p>
     <p><code>inline T* value_type(const input_iterator‹T, Distance›&amp;) {</code></p>
     <p><code> return (T*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template ‹class T, class Distance›</code></p>
     <p><code>inline T* value_type(const forward_iterator‹T, Distance›&amp;) {</code></p>
     <p><code> return (T*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template ‹class T, class Distance›</code></p>
     <p><code>inline T* value_type(const bidirectional_iterator‹T, Distance›&amp;) {</code></p>
     <p><code> return (T*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template ‹class T, class Distance›</code></p>
     <p><code>inline T* value_type(const random_access_iterator‹T, Distance›&amp;) {</code></p>
     <p><code> return (T*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template ‹class T›</code></p>
     <p><code>inline T* value_type(const T*) {return (T*) (0);}</code></p>
     <empty-line/>
     <p><code>// distance_type of iterator (функции типа расстояния итераторов)</code></p>
     <p><code>template ‹class T, class Distance›</code></p>
     <p><code>inline Distance* distance_type(const input_iterator‹T, Distance›&amp;) {</code></p>
     <p><code> return (Distance*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template ‹class T, class Distance›</code></p>
     <p><code>inline Distance* distance_type(const forward_iterator‹T, Distance›&amp;) {</code></p>
     <p><code> return (Distance*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template ‹class T, class Distance›</code></p>
     <p><code>inline Distance* distance_type(const bidirectional_iterator‹T, Distance›&amp;) {</code></p>
     <p><code> return (Distance*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template ‹class T, class Distance›</code></p>
     <p><code>inline Distance* distance_type(const random_access_iterator‹T, Distance›&amp;) {</code></p>
     <p><code> return (Distance*) (0);</code></p>
     <p><code>}</code></p>
     <p><code>template ‹class T›</code></p>
     <p><code>inline ptrdiff_t* distance_type(const T*) {return (ptrdiff_t*) (0);}</code></p>
     <p>Если пользователь хочет определить двунаправленный итератор для некоторой структуры данных, содержащей double, и такой, чтобы работал с большой (large) моделью памяти компьютера, то это может быть сделано таким определением:</p>
     <p><code>class MyIterator: public bidirectional_iterator ‹double, long› {</code></p>
     <p><code> // код, осуществляющий ++, и т.д.</code></p>
     <p><code>};</code></p>
     <p>Тогда нет необходимости определять iterator_category, value_type, и distance_type в MyIterator.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Операции с итераторами (Iterator operations)</p>
    </title>
    <p>Так как только итераторы произвольного доступа обеспечивают + и - операторы, библиотека предоставляет две шаблонные функции advance и distance. Эти функции используют + и - для итераторов произвольного доступа (и имеют, поэтому, сложность постоянного времени для них); для итераторов ввода, последовательных и двунаправленных итераторов функции используют ++, чтобы обеспечить реализацию со сложностью линейного времени. advance берет отрицательный параметр n только для итераторов произвольного доступа и двунаправленных итераторов. advance увеличивает (или уменьшает для отрицательного n) итераторную ссылку i на n. distance увеличивает n на число единиц, сколько требуется, чтобы дойти от first до last.</p>
    <p><code>template ‹class InputIterator, class Distance›</code></p>
    <p><code>inline void advance(InputIterator&amp; i, Distance n);</code></p>
    <empty-line/>
    <p><code>template ‹class InputIterator, class Distance›</code></p>
    <p><code>inline void distance(InputIterator first, InputIterator last, Distance&amp; n);</code></p>
    <p>distance должна быть функцией 3-х параметров, сохраняющей результат в ссылке вместо возвращения результата, потому что тип расстояния не может быть выведен из встроенных итераторных типов, таких как int*.</p>
   </section>
  </section>
  <section>
   <title>
    <p>Функциональные объекты</p>
   </title>
   <section>
    <p>Функциональные объекты - это объекты, для которых определён operator(). Они важны для эффективного использования библиотеки. В местах, где ожидается передача указателя на функцию алгоритмическому шаблону, интерфейс установлен на приём объекта с определённым operator(). Это не только заставляет алгоритмические шаблоны работать с указателями на функции, но также позволяет им работать с произвольными функциональными объектами. Использование функциональных объектов вместе с функциональными шаблонами увеличивает выразительную мощность библиотеки также, как делает результирующий код более эффективным. Например, если мы хотим поэлементно сложить два вектора a и b, содержащие double, и поместить результат в a, мы можем сделать зто так:</p>
    <p><code>transform(a.begin(), a.end(), b.begin(), a.begin(), plus‹double›());</code></p>
    <p>Если мы хотим отрицать каждый элемент a, мы можем сделать это так:</p>
    <p><code>transform(a.begin(), a.end(), a.begin(), negate‹double›());</code></p>
    <p>Соответствующие функции вставят сложение и отрицание.</p>
    <p>Чтобы позволить адаптерам и другим компонентам манипулировать функциональными объектами, которые используют один или два параметра, требуется, чтобы они соответственно обеспечили определение типов (typedefs) argument_type и result_type для функциональных объектов, которые используют один параметр, и first_argument_type, second_argument_type и result_type для функциональных объектов, которые используют два параметра.</p>
   </section>
   <section>
    <title>
     <p>Базовые классы (Base)</p>
    </title>
    <p>Следующие классы предоставляются, чтобы упростить определение типов (typedefs) параметров и результата:</p>
    <p><code>template ‹class Arg, class Result›</code></p>
    <p><code>struct unary_function {</code></p>
    <p><code> typedef Arg argument_type;</code></p>
    <p><code> typedef Result result_type;</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>template ‹class Arg1, class Arg2, class Result›</code></p>
    <p><code>struct binary_function {</code></p>
    <p><code> typedef Arg1 first_argument_type;</code></p>
    <p><code> typedef Arg2 second_argument_type;</code></p>
    <p><code> typedef Result result_type;</code></p>
    <p><code>};</code></p>
   </section>
   <section>
    <title>
     <p>Арифметические операции (Arithmetic operations)</p>
    </title>
    <p>Библиотека обеспечивает базовые классы функциональных объектов для всех арифметических операторов языка.</p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct plus: binary_function‹T, T, T› {</code></p>
    <p><code> Т operator()(const T&amp; x, const T&amp; y) const {return x + y;}</code></p>
    <p><code>};</code></p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct minus: binary_function‹T, T, T› {</code></p>
    <p><code> Т operator()(const T&amp; x, const T&amp; y) const {return x - y;}</code></p>
    <p><code>};</code></p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct times: binary_function‹T, T, T› {</code></p>
    <p><code> Т operator()(const T&amp; x, const T&amp; y) const (return x * y;}</code></p>
    <p><code>};</code></p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct divides: binary_function‹T, T, T› {</code></p>
    <p><code> Т operator()(const T&amp; x, const T&amp; y) const {return x / y;}</code></p>
    <p><code>};</code></p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct modulus: binary_function‹T, T, T› {</code></p>
    <p><code> Т operator()(const T&amp; x, const T&amp; y) const {return x % y;}</code></p>
    <p><code>};</code></p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct negate: unary_function‹T, T› {</code></p>
    <p><code> Т operator()(const T&amp; x) const {return -x;}</code></p>
    <p><code>};</code></p>
   </section>
   <section>
    <title>
     <p>Сравнения (Comparisons)</p>
    </title>
    <p>Библиотека обеспечивает базовые классы функциональных объектов для всех операторов сравнения языка</p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct equal_to: binary_function‹T, T, bool› {</code></p>
    <p><code> bool operator()(const T&amp; x, const T&amp; y) const {return x == y;}</code></p>
    <p><code>};</code></p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct not_equal_to: binary_function‹T, T, bool› {</code></p>
    <p><code> bool operator()(const T&amp; x, const T&amp; y) const {return x!= y;}</code></p>
    <p><code>};</code></p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct greater: binary_function‹T, T, bool› {</code></p>
    <p><code> bool operator()(const T&amp; x, const T&amp; y) const {return x › y;}</code></p>
    <p><code>};</code></p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct less: binary_function‹T, T, bool› {</code></p>
    <p><code> bool operator()(const T&amp; x, const T&amp; y) const {return x ‹ y;}</code></p>
    <p><code>};</code></p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct greater_equal: binary_function‹T, T, bool› {</code></p>
    <p><code> bool operator()(const T&amp; x, const T&amp; y) const {return x ›= y;}</code></p>
    <p><code>};</code></p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct less_equal: binary_function‹T, T, bool› {</code></p>
    <p><code> bool operator()(const T&amp; x, const T&amp; y) const {return x ‹= y;}</code></p>
    <p><code>};</code></p>
   </section>
   <section>
    <title>
     <p>Логические операции (Logical operations)</p>
    </title>
    <p><code>template ‹class T›</code></p>
    <p><code>struct logical_and: binary_function‹T, T, bool› {</code></p>
    <p><code> bool operator()(const T&amp; x, const T&amp; y) const {return x&amp;&amp; y;}</code></p>
    <p><code>};</code></p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct logical_or: binary_function‹T, T, bool› {</code></p>
    <p><code> bool operator()(const T&amp; x, const T&amp; y) const {return x || y;}</code></p>
    <p><code>};</code></p>
    <p><code>template ‹class T›</code></p>
    <p><code>struct logical_not: unary_function‹T, bool› {</code></p>
    <p><code> bool operator()(const T&amp; x) const {return!x;}</code></p>
    <p><code>};</code></p>
   </section>
  </section>
  <section>
   <title>
    <p>Распределители</p>
   </title>
   <section>
    <p>Одна из общих проблем в мобильности - это способность инкапсулировать информацию относительно модели памяти. Эта информация включает типы указателей, тип их разности, тип размера объектов в этой модели памяти, также как её примитивы выделения и освобождения памяти.</p>
    <p>STL принимается за эту проблему, обеспечивая стандартный набор требований для <emphasis>распределителей</emphasis> (<emphasis>allocators</emphasis>), являющихся объектами, которые инкапсулируют эту информацию. Все контейнеры в STL параметризованы в терминах распределителей. Это значительно упрощает задачу взаимодействия с многочисленными моделями памяти.</p>
   </section>
   <section>
    <title>
     <p>Требования распределителей (Allocator requirements)</p>
    </title>
    <p>В следующей таблице мы предполагаем, что X - класс распределителей для объектов типа T, a - значение X, n имеет тип X::size_type, p имеет тип X::pointer, r имеет тип X::reference и s имеет тип X::const_reference.</p>
    <p>Все операции c распределителями, как ожидается, сводятся к постоянному времени.</p>
    <p><strong>Таблица 7. Требования распределителей</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">утверждение/примечание состояние до/после </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::value_type </td>
      <td align="left" valign="top">Т</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::reference </td>
      <td align="left" valign="top">леводопустимое значение T (lvalue of T)</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::const_reference </td>
      <td align="left" valign="top">const lvalue of T</td>
      <td align="left" valign="top">- </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::pointer </td>
      <td align="left" valign="top">указатель на тип T </td>
      <td align="left" valign="top">результатом operator* для значений X::pointer является reference. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::const_pointer </td>
      <td align="left" valign="top">указатель на тип const T </td>
      <td align="left" valign="top">результат operator* для значений X::const_pointer &#8213; const_reference; это - тот же самый тип указателя, как X::pointer, в частности, sizeof(X::const_pointer)==sizeof(X::pointer). </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X:: size_type </td>
      <td align="left" valign="top">беззнаковый целочисленный тип </td>
      <td align="left" valign="top">тип, который может представлять размер самого большого объекта в модели памяти. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::difference_type </td>
      <td align="left" valign="top">знаковый целочисленный тип </td>
      <td align="left" valign="top">тип, который может представлять разность между двумя любыми указателями в модели памяти. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X a;</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">примечание: предполагается деструктор. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.address(r) </td>
      <td align="left" valign="top">указатель </td>
      <td align="left" valign="top">*(a.address(r))==r. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.const_address(s) </td>
      <td align="left" valign="top">const_pointer </td>
      <td align="left" valign="top">*(a.address(s))==s. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.allocate(n) </td>
      <td align="left" valign="top">X::pointer </td>
      <td align="left" valign="top">память распределяется для n объектов типа T, но объекты не создаются. allocate может вызывать соответствующее исключение. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.deallocate(p) </td>
      <td align="left" valign="top">результат не используется </td>
      <td align="left" valign="top">все объекты в области, указываемой p, должны быть уничтожены до этого запроса.</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">construct(p, a) </td>
      <td align="left" valign="top">void </td>
      <td align="left" valign="top">после: *p==a. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">destroy(p) </td>
      <td align="left" valign="top">void </td>
      <td align="left" valign="top">значение, указываемое p, уничтожается. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.init_page_size() </td>
      <td align="left" valign="top">X::size_type </td>
      <td align="left" valign="top">возвращённое значение - оптимальное значение для начального размера буфера данного типа. Предполагается, что если k возвращено функцией init_page_size, t - время конструирования для T, и u - время, которое требуется для выполнения allocate(k), тогда k*t будет намного больше, чем u. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.max_size() </td>
      <td align="left" valign="top">X::size_type </td>
      <td align="left" valign="top">наибольшее положительное значение X::difference_type </td>
     </tr>
    </table>
    <p>pointer относится к категории модифицируемых итераторов произвольного доступа, ссылающихся на T. const_pointer относится к категории постоянных итераторов произвольного доступа, ссылающихся на T. Имеется определённое преобразование из pointer в const_pointer.</p>
    <p>Для любого шаблона распределителя Alloc имеется определение для типа void. У Alloc‹void› определены только конструктор, деструктор и Alloc‹void›::pointer. Преобразования определены из любого Alloc‹T›::pointer в Alloc‹void›::pointer и обратно, так что для любого p будет p == Alloc‹T›::pointer(Alloc‹void›::pointer(p)).</p>
   </section>
   <section>
    <title>
     <p>Распределитель по умолчанию (The default allocator)</p>
    </title>
    <p><code>template ‹class T›</code></p>
    <p><code>class allocator {</code></p>
    <p><code>public:</code></p>
    <p><code> typedef T* pointer;</code></p>
    <p><code> typedef const T* const_pointer;</code></p>
    <p><code> typedef T&amp; reference;</code></p>
    <p><code> typedef const T&amp; const_reference;</code></p>
    <p><code> typedef T value_type;</code></p>
    <p><code> typedef size_t size_type;</code></p>
    <p><code> typedef ptrdiff_t difference_type;</code></p>
    <p><code> allocator();</code></p>
    <p><code> ~allocator();</code></p>
    <p><code> pointer address(reference x);</code></p>
    <p><code> const_pointer const_address(const_reference x);</code></p>
    <p><code> pointer allocate(size_type n);</code></p>
    <p><code> void deallocate(pointer p);</code></p>
    <p><code> size_type init_page_size();</code></p>
    <p><code> size_type max_size();</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>class allocator‹void› {</code></p>
    <p><code>public:</code></p>
    <p><code> typedef void* pointer;</code></p>
    <p><code> allocator();</code></p>
    <p><code> ~allocator();</code></p>
    <p><code>};</code></p>
    <p>Предполагается, что в дополнение к allocator поставщики библиотеки обеспечивают распределители для всех моделей памяти.</p>
   </section>
  </section>
  <section>
   <title>
    <p>Контейнеры</p>
   </title>
   <section>
    <p>Контейнеры - это объекты, которые содержат другие объекты. Они управляют размещением в памяти и свобождением этих объектов через конструкторы, деструкторы, операции вставки и удаления.</p>
    <p>В следующей таблице мы полагаем, что X - контейнерный класс, содержащий объекты типа T, a и b - значения X, u - идентификатор, r - значение X&amp;.</p>
    <p><strong>Таблица 8. Требования контейнеров</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнения </th>
      <th align="left" valign="top">утверждение/примечание состояние до/после </th>
      <th align="left" valign="top">сложность </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::value_type </td>
      <td align="left" valign="top">Т</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">время компиляции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::reference</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">время компиляции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::const_reference</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">время компиляции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::pointer </td>
      <td align="left" valign="top">тип указателя, указывающий на X::reference</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">указатель на T в модели памяти, используемой контейнером </td>
      <td align="left" valign="top">время компиляции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::iterator </td>
      <td align="left" valign="top">тип итератора, указывающий на X::reference</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">итератор любой категории, кроме итератора вывода. </td>
      <td align="left" valign="top">время компиляции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::const_iterator </td>
      <td align="left" valign="top">тип итератора, указывающий на X::<emphasis>const_reference </emphasis></td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">постоянный итератор любой категории, кроме итератора вывода. </td>
      <td align="left" valign="top">время компиляции</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::difference<emphasis>_</emphasis>type</td>
      <td align="left" valign="top">знаковый целочисленный тип</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">идентичен типу расстояния X::iterator и X::const_iterator </td>
      <td align="left" valign="top">время компиляции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::size_type </td>
      <td align="left" valign="top">беззнаковый целочисленный тип</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">size_type может представлять любое неотрицательное значение difference_type </td>
      <td align="left" valign="top">время компиляции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X u;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">после: u.size()==0. </td>
      <td align="left" valign="top">постоянная</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X()</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">X().size()==0. </td>
      <td align="left" valign="top">постоянная</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X(a)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">a==X(a). </td>
      <td align="left" valign="top">линейная </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X u(a); X u==a;</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">X u; u = a; </td>
      <td align="left" valign="top">после: u==a. </td>
      <td align="left" valign="top">линейная </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">(&amp;a)-›~X() </td>
      <td align="left" valign="top">результат не используется</td>
      <td align="left" valign="top">- </td>
      <td align="left" valign="top">после: a.size()==0. примечание: деструктор применяется к каждому элементу a, и вся память возвращается. </td>
      <td align="left" valign="top">линейная </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.begin() </td>
      <td align="left" valign="top">iterator; const_iterator для постоянного a</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">постоянная </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.end() </td>
      <td align="left" valign="top">iterator; const_iterator для постоянного a</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">постоянная </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a==b </td>
      <td align="left" valign="top">обратимый в bool </td>
      <td align="left" valign="top">a.size()==b.size() &amp;&amp; equal(a.begin(), a.end(), b.begin())</td>
      <td align="left" valign="top"><emphasis>==</emphasis> - это отношение эквивалентности. примечание: equal определяется в разделе алгоритмов. </td>
      <td align="left" valign="top">линейная </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a!= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a==b)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">линейная </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">r = a </td>
      <td align="left" valign="top">X&amp; </td>
      <td align="left" valign="top">if(&amp;r!=&amp;a){ (&amp;r)-›X::~X(); new(&amp;r)X(a); return r;}</td>
      <td align="left" valign="top">после: r==a.</td>
      <td align="left" valign="top">линейнaя </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.size() </td>
      <td align="left" valign="top">size_type </td>
      <td align="left" valign="top">size_type n = 0; distance(a.begin(), a.end(), n); return n;</td>
      <td align="left" valign="top"><emphasis>-</emphasis></td>
      <td align="left" valign="top">постоянная</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.max_size() </td>
      <td align="left" valign="top">size_type</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">size() самого большого возможного контейнера. </td>
      <td align="left" valign="top">постоянная</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.empty() </td>
      <td align="left" valign="top">обратимый в bool </td>
      <td align="left" valign="top">a.size()==0</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">постоянная </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a ‹ b </td>
      <td align="left" valign="top">обратимый в bool </td>
      <td align="left" valign="top">lexicographical_compare(a.begin(), a.end(), b.begin(), b.end())</td>
      <td align="left" valign="top">до: ‹ определён для значений T. ‹ - отношение полного упорядочения. lexicographical_compare определяется в разделе алгоритмов. </td>
      <td align="left" valign="top">линейная </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a › b </td>
      <td align="left" valign="top">обратимый в bool </td>
      <td align="left" valign="top">b ‹ a</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">линейнaя </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a ‹= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a › b)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">линейная </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a ›= b </td>
      <td align="left" valign="top">обратимый в bool</td>
      <td align="left" valign="top">!(a ‹ b)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">линейная </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.swap(b) </td>
      <td align="left" valign="top">void </td>
      <td align="left" valign="top">swap(a, b)</td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">постоянная </td>
     </tr>
    </table>
    <p>Функция-член size() возвращает число элементов в контейнере. Её семантика определяется правилами конструкторов, вставок и удалений.</p>
    <p>begin() возвращает итератор, ссылающийся на первый элемент в контейнере. end() возвращает итератор, который является законечным.</p>
    <p>Если тип итератора контейнера принадлежит к категории двунаправленных итераторов или итераторов произвольного доступа, то контейнер называется reversible (обратимым) и удовлетворяет следующим дополнительным требованиям:</p>
    <p><strong>Таблица 9. Требования обратимых контейнеров (в дополнение к контейнерам)</strong> </p>
    <table>
     <tr align="left">
      <th align="left" valign="top">выражение </th>
      <th align="left" valign="top">возвращаемый тип </th>
      <th align="left" valign="top">семантика исполнения </th>
      <th align="left" valign="top">сложность </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::reverse_iterator </td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">reverse_iterator‹iterator, value_type, reference, difference_type› для итератора произвольного доступа. reverse_bidirectional_iterator‹iterator, value_type, reference, difference_type› для двунаправленного итератора </td>
      <td align="left" valign="top">время компиляции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">X::const_reverse_iterator </td>
      <td align="left" valign="top">-</td>
      <td align="left" valign="top">reverse_iterator‹const_iterator, value_type, const_reference, difference_type› для итератора произвольного доступа. reverse_bidirectional_iterator‹const_iterator, value_type, const_reference, difference_type› для двунаправленного итератора. </td>
      <td align="left" valign="top">время компиляции </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.rbegin() </td>
      <td align="left" valign="top">reverse_iterator; const_reverse_iterator для постоянного a </td>
      <td align="left" valign="top">reverse_iterator(end()) </td>
      <td align="left" valign="top">постоянная </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">a.rend() </td>
      <td align="left" valign="top">reverse_iterator; const_reverse_iterator для постоянного a </td>
      <td align="left" valign="top">reverse_iterator(begin()) </td>
      <td align="left" valign="top">постоянная </td>
     </tr>
    </table>
   </section>
   <section>
    <title>
     <p>Последовательности (Sequences)</p>
    </title>
    <section>
     <p>Последовательность - это вид контейнера, который организует конечное множество объектов одного и того же типа в строгом линейном порядке. Библиотека обеспечивает три основных вида последовательных контейнеров: vector (вектор), list (список) и deque (двусторонняя очередь). Она также предоставляет контейнерные адаптеры, которые облегчают создание абстрактных типов данных, таких как стеки или очереди, из основных видов последовательностей (или из других видов последовательностей, которые пользователь может сам определить).</p>
     <p>В следующих двух таблицах X - последовательный класс, a - значение X, i и j удовлетворяют требованиям итераторов ввода, [i, j) - допустимый диапазон, n - значение X::size_type, p - допустимый итератор для a, q - разыменовываемый итератор для a, [q1, q2) - допустимый диапазон в a, t - значение X::value_type.</p>
     <p>Сложности выражений зависят от последовательностей.</p>
     <p><strong>Таблица 10. Требования последовательностей (в дополнение к контейнерам)</strong> </p>
     <empty-line/>
     <table>
      <tr align="left">
       <th align="left" valign="top">выражение </th>
       <th align="left" valign="top">возвращаемый тип </th>
       <th align="left" valign="top">утверждение/примечание состояние до/после </th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X(n, t) X a(n, t); </td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">после: size()==n. создаёт последовательность с n копиями t. </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X(i, j) X a(i, j); </td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">после: size()==расстоянию между i и j. создаёт последовательность, равную диапазону [i, j). </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.insert(p, t) </td>
       <td align="left" valign="top">iterator </td>
       <td align="left" valign="top">вставляет копию t перед p. возвращаемое значение указывает на вставленную копию.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.insert(p, n, t) </td>
       <td align="left" valign="top">результат не используется </td>
       <td align="left" valign="top">вставляет n копий t перед p. </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.insert(p, i, j) </td>
       <td align="left" valign="top">результат не используется </td>
       <td align="left" valign="top">вставляет копии элементов из диапазона [i, j) перед p. </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.erase(q) </td>
       <td align="left" valign="top">результат не используется </td>
       <td align="left" valign="top">удаляет элемент, указываемый q. </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.erase(ql, q2) </td>
       <td align="left" valign="top">результат не используется </td>
       <td align="left" valign="top">удаляет элементы в диапазоне [ql, q2). </td>
      </tr>
     </table>
     <p>vector (вектор), list (список) и deque (двусторонняя очередь) выдвигают программисту различные предложения сложности и должны использоваться соответственно. vectоr - тип последовательности, которая используется по умолчанию. list нужно использовать, когда имеются частые вставки и удаления из середины последовательности, deque - структура данных для выбора, когда большинство вставок и удалений происходит в начале или в конце последовательности.</p>
     <p>Типы iterator и const_iterator для последовательностей должны быть, по крайней мере, из категории последовательных итераторов.</p>
     <p><strong>Таблица 11. Необязательные операции последовательностей</strong> </p>
     <table>
      <tr align="left">
       <th align="left" valign="top">выражение </th>
       <th align="left" valign="top">возвращаемый тип </th>
       <th align="left" valign="top">семантика исполнения </th>
       <th align="left" valign="top">контейнер </th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.front() </td>
       <td align="left" valign="top">reference; const_reference для постоянного a </td>
       <td align="left" valign="top">*a.begin() </td>
       <td align="left" valign="top">vector, list, deque </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.back() </td>
       <td align="left" valign="top">reference; const_reference для постоянного a </td>
       <td align="left" valign="top">*a.(--end()) </td>
       <td align="left" valign="top">vector, list, deque </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.push_front(t) </td>
       <td align="left" valign="top">void </td>
       <td align="left" valign="top">a.insert(a.begin(), t) </td>
       <td align="left" valign="top">list, deque </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.push_back(t) </td>
       <td align="left" valign="top">void </td>
       <td align="left" valign="top">a.insert(a.end(), t) </td>
       <td align="left" valign="top">vector, list, deque</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.pop_front() </td>
       <td align="left" valign="top">void </td>
       <td align="left" valign="top">a.erase(a.begin()) </td>
       <td align="left" valign="top">list, deque </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.pop_back() </td>
       <td align="left" valign="top">void</td>
       <td align="left" valign="top">a.erase(--a.end()) </td>
       <td align="left" valign="top">vector, list, deque </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a[n] </td>
       <td align="left" valign="top">reference; const_reference для постоянного a </td>
       <td align="left" valign="top">*(a.begin() + n) </td>
       <td align="left" valign="top">vector, deque </td>
      </tr>
     </table>
     <p>Все операции в расположенной выше таблице обеспечиваются только для контейнеров, для которых они занимают постоянное время.</p>
    </section>
    <section>
     <title>
      <p>Вектор (Vector)</p>
     </title>
     <p>vector - вид последовательности, которая поддерживает итераторы произвольного доступа. Кроме того, он поддерживает операции вставки и удаления в конце с постоянным (амортизированным) временем; вставка и удаление в середине занимают линейное время. Управление памятью обрабатывается автоматически, хотя для улучшения эффективности можно давать подсказки.</p>
     <p><code>template ‹class T, template ‹class U› class Allocator = allocator›</code></p>
     <p><code>class vector {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code> // определения типов (typedefs):</code></p>
     <p><code> typedef iterator;</code></p>
     <p><code> typedef const_iterator;</code></p>
     <p><code> typedef Allocator‹T›::pointer pointer;</code></p>
     <p><code> typedef Allocator‹T›::reference reference;</code></p>
     <p><code> typedef Allocator‹T›::const_reference const_reference;</code></p>
     <p><code> typedef size_type;</code></p>
     <p><code> typedef difference_type;</code></p>
     <p><code> typedef T value_type;</code></p>
     <p><code> typedef reverse_iterator;</code></p>
     <p><code> typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code> // размещение/освобождение (allocation/deallocation):</code></p>
     <p><code> vector();</code></p>
     <p><code> vector(size_type n, const T&amp; value = T());</code></p>
     <p><code> vector(const vector‹T, Allocator›&amp; x);</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> vector(InputIterator first, InputIterator last);</code></p>
     <p><code> ~vector();</code></p>
     <p><code> vector‹T, Allocator›&amp; operator=(const vector‹T, Allocator›&amp; x);</code></p>
     <p><code> void reserve(size_type n);</code></p>
     <p><code> void swap(vector‹T, Allocator›&amp; x);</code></p>
     <empty-line/>
     <p><code> // средства доступа (accessors):</code></p>
     <p><code> iterator begin();</code></p>
     <p><code> const_iterator begin() const;</code></p>
     <p><code> iterator end();</code></p>
     <p><code> const_iterator end() const;</code></p>
     <p><code> reverse_iterator rbegin();</code></p>
     <p><code> const_reverse_iterator rbegin();</code></p>
     <p><code> reverse_iterator rend();</code></p>
     <p><code> const_reverse_iterator rend();</code></p>
     <p><code> size_type size() const;</code></p>
     <p><code> size_type max_size() const;</code></p>
     <p><code> size_type capacity() const;</code></p>
     <p><code> bool empty() const;</code></p>
     <p><code> reference operator[](size_type n);</code></p>
     <p><code> const_reference operator[](size_type n) const;</code></p>
     <p><code> reference front();</code></p>
     <p><code> const_reference front() const;</code></p>
     <p><code> reference back();</code></p>
     <p><code> const_reference back() const;</code></p>
     <empty-line/>
     <p><code> // вставка/стирание (insert/irase):</code></p>
     <p><code> void push_back(const T&amp; x);</code></p>
     <p><code> iterator insert(iterator position, const T&amp; x = T());</code></p>
     <p><code> void insert(iterator position, size_type n, const T&amp; x);</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> void insert(iterator position, InputIterator first, InputIterator last);</code></p>
     <p><code> void pop_back();</code></p>
     <p><code> void erase(iterator position);</code></p>
     <p><code> void erase(iterator first, iterator last);</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class T, class Allocator›</code></p>
     <p><code>bool operator==(const vector‹T, Allocator›&amp; x, const vector‹T, Allocator›&amp; y);</code></p>
     <empty-line/>
     <p><code>template ‹class T, class Allocator›</code></p>
     <p><code>bool operator‹(const vector‹T, Allocator›&amp; x, const vector‹T, Allocator›&amp; y);</code></p>
     <p>iterator - это итератор произвольного доступа, ссылающийся на T. Точный тип зависит от исполнения и определяется в Allocator.</p>
     <p>const_iterator - это постоянный итератор произвольного доступа, ссылающийся на const T. Точный тип зависит от исполнения и определяется в Allocator. Гарантируется, что имеется конструктор для const_iterator из iterator.</p>
     <p>size_type - беззнаковый целочисленный тип. Точный тип зависит от исполнения и определяется в Allocator.</p>
     <p>difference_type - знаковый целочисленный тип. Точный тип зависит от исполнения и определяется в Allocator.</p>
     <p>Конструктор template ‹class InputIterator› vector(InputIterator first, InputIterator last) делает только N вызовов конструктора копирования T (где N - расстояние между first и last) и никаких перераспределений, если итераторы first и last относятся к последовательной, двунаправленной или произвольного доступа категориям. Он делает, самое большее, 2N вызовов конструктора копирования T и logN перераспределений, если они - только итераторы ввода, так как невозможно определить расстояние между first и last и затем сделать копирование.</p>
     <p>Функция-член capasity (ёмкость) возвращает размер распределённой памяти в векторе. Функция-член reserve - директива, которая сообщает vector (вектору) запланированноe изменение размера, так чтобы он мог соответственно управлять распределением памяти. Это не изменяет размер последовательности и занимает, самое большее, линейное время от размера последовательности. Перераспределение в этом случае происходит тогда и только тогда, когда текущая ёмкость меньше, чем параметр reserve. После reserve ёмкость (capasity) больше или равна параметру reserve, если происходит перераспределение; а иначе равна предыдущему значению capasity. Перераспределение делает недействительными все ссылки, указатели и итераторы, ссылающиеся на элементы в последовательности. Гарантируется, что нет никакого перераспределения во время вставок, которые происходят после того, как reserve выполняется, до времени, когда размер вектора достигает размера, указанного reserve.</p>
     <p>insert (вставка) вызывает перераспределение, если новый размер больше, чем старая ёмкость. Если никакого перераспределения не происходит, все итераторы и ссылки перед точкой вставки остаются справедливыми. Вставка единственного элемента в вектор линейна относительно расстояния от точки вставки до конца вектора. Амортизированная сложность во время жизни вектора, вставляющего единственный элемент в свой конец, постоянна. Вставка множественных элементов в вектор с единственным вызовом вставляющей функции-члена линейна относительно суммы числа элементов плюс расстояние до конца вектора. Другими словами, намного быстрее вставить много элементов в середину вектора сразу, чем делать вставку по одному элементу. Шаблонная вставляющая функция-член предраспределяет достаточно памяти для вставки, если итераторы first и last относятся к последовательной, двунаправленной или произвольного доступа категориям. Иначе функция вставляет элементы один за другим и не должна использоваться для вставки в середину векторов.</p>
     <p>erase (стирание) делает недействительными все итераторы и ссылки после пункта стирания. Деструктор T вызывается столько раз, каково число стёртых элементов, а оператор присваивания T вызывается столько раз, каково число элементов в векторе после стёртых элементов.</p>
     <p>Чтобы оптимизировать распределение места, даётся определение для bool.</p>
     <p><code>class vector‹bool, allocator› {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code> // битовая ссылка (bit reference):</code></p>
     <p><code> class reference {</code></p>
     <p><code> public:</code></p>
     <p><code>  ~reference();</code></p>
     <p><code>  operator bool() const;</code></p>
     <p><code>  reference&amp; operator=(const bool x);</code></p>
     <p><code>  void flip(); // инвертирует бит (flips the bit)</code></p>
     <p><code> };</code></p>
     <empty-line/>
     <p><code> // определения типов (typedefs):</code></p>
     <p><code> typedef bool const_reference;</code></p>
     <p><code> typedef iterator;</code></p>
     <p><code> typedef const_iterator;</code></p>
     <p><code> typedef size_t size_type;</code></p>
     <p><code> typedef ptrdiff_t difference_type;</code></p>
     <p><code> typedef bool value_type;</code></p>
     <p><code> typedef reverse_iterator;</code></p>
     <p><code> typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code> // размещение/освобождение (allocation/deallocation):</code></p>
     <p><code> vector();</code></p>
     <p><code> vector(size_type n, const bool&amp; value = bool());</code></p>
     <p><code> vector(const vector‹bool, allocator›&amp; x);</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> vector(InputIterator first, InputIterator last);</code></p>
     <p><code> ~vector();</code></p>
     <p><code> vector‹bool, allocator›&amp; operator=(const vector‹bool, allocator›&amp; x);</code></p>
     <p><code> void reserve(size_type n);</code></p>
     <p><code> void swap(vector‹bool, allocator›&amp; x);</code></p>
     <empty-line/>
     <p><code> // средства доступа (accessors):</code></p>
     <p><code> iterator begin();</code></p>
     <p><code> const_iterator begin() const;</code></p>
     <p><code> iterator end();</code></p>
     <p><code> const_iterator end() const;</code></p>
     <p><code> reverse_iterator rbegin();</code></p>
     <p><code> const_reverse_iterator rbegin();</code></p>
     <p><code> reverse_iterator rend();</code></p>
     <p><code> const_reverse_iterator rend();</code></p>
     <p><code> size_type size() const;</code></p>
     <p><code> size_type max_size() const;</code></p>
     <p><code> size_type capacity() const;</code></p>
     <p><code> bool empty() const;</code></p>
     <p><code> reference operator[](size_type n);</code></p>
     <p><code> const_reference operator[](size_type n) const;</code></p>
     <p><code> reference front();</code></p>
     <p><code> const_reference front() const;</code></p>
     <p><code> reference back();</code></p>
     <p><code> const_reference back() const;</code></p>
     <empty-line/>
     <p><code> // вставка/стирание (insert/irase):</code></p>
     <p><code> void push_back(const bool&amp; x);</code></p>
     <p><code> iterator insert(iterator position, const bool&amp; x = bool());</code></p>
     <p><code> void insert(iterator position, size_type n, const bool&amp; x);</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> void insert(iterator position, InputIterator first, InputIterator last);</code></p>
     <p><code> void pop_back();</code></p>
     <p><code> void erase(iterator position);</code></p>
     <p><code> void erase(iterator first, iterator last);</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>void swap(vector‹bool, allocator›::reference x, vector‹bool, allocator›::reference y);</code></p>
     <p><code>bool operator==(const vector‹bool, allocator›&amp; x, const vector‹bool, allocator›&amp; y);</code></p>
     <p><code>bool operator‹(const vector‹bool, allocator›&amp; x, const vector‹bool, allocator›&amp; y);</code></p>
     <p>reference - класс, который имитирует поведение ссылок отдельного бита в vector‹bool›.</p>
     <p>Ожидается, что каждое исполнение обеспечит определение vector‹bool› для всех поддерживаемых моделей памяти.</p>
     <cite>
      <p>Сейчас невозможно шаблонизировать определение. То есть мы не можем написать: </p>
      <p><code>template ‹template ‹class U› class Allocator = allocator› </code></p>
      <p><code>class vector‹bool, Allocator› {/*… */}; </code></p>
      <p>Поэтому обеспечивается только vector‹bool, Allocator›. </p>
     </cite>
    </section>
    <section>
     <title>
      <p>Список (List)</p>
     </title>
     <p>list - вид последовательности, которая поддерживает двунаправленные итераторы и позволяет операции вставки и стирания с постоянным временем в любом месте последовательности, с управлением памятью, обрабатываемым автоматически. В отличие от векторов и двусторонних очередей, быстрый произвольный доступ к элементам списка не поддерживается, но многим алгоритмам, во всяком случае, только и нужен последовательный доступ.</p>
     <p><code>template ‹class T, template ‹class U› class Allocator = allocator›</code></p>
     <p><code>class list {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code> // определения типов:</code></p>
     <p><code> typedef iterator;</code></p>
     <p><code> typedef const_iterator;</code></p>
     <p><code> typedef Allocator‹T›::pointer pointer;</code></p>
     <p><code> typedef Allocator‹T›::reference reference;</code></p>
     <p><code> typedef Allocator‹T›::const_reference const_reference;</code></p>
     <p><code> typedef size_type;</code></p>
     <p><code> typedef difference_type;</code></p>
     <p><code> typedef Т value_type;</code></p>
     <p><code> typedef reverse_iterator;</code></p>
     <p><code> typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code> // размещение/удаление:</code></p>
     <p><code> list()</code></p>
     <p><code> list(size_type n, const T&amp; value = T());</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> list(InputIterator first, InputIterator last);</code></p>
     <p><code> list(const list‹T, Allocator›&amp; x);</code></p>
     <p><code> ~list();</code></p>
     <p><code> list‹T, Allocator›&amp; operator=(const list‹T,Allocator›&amp; x);</code></p>
     <p><code> void swap(list‹T, Allocator&amp; x);</code></p>
     <empty-line/>
     <p><code> // средства доступа:</code></p>
     <p><code> iterator begin();</code></p>
     <p><code> const_iterator begin() const;</code></p>
     <p><code> iterator end();</code></p>
     <p><code> const_iterator end() const;</code></p>
     <p><code> reverse_iterator rbegin();</code></p>
     <p><code> const_reverse_iterator rbegin();</code></p>
     <p><code> reverse_iterator rend();</code></p>
     <p><code> const_reverse_iterator rend();</code></p>
     <p><code> bool empty() const;</code></p>
     <p><code> size_type size() const;</code></p>
     <p><code> size_type max_size() const;</code></p>
     <p><code> reference front();</code></p>
     <p><code> const_reference front() const;</code></p>
     <p><code> reference back();</code></p>
     <p><code> const_reference back() const;</code></p>
     <empty-line/>
     <p><code> // вставка/стирание:</code></p>
     <p><code> void push_front(const T&amp; x);</code></p>
     <p><code> void push_back(const T&amp; x);</code></p>
     <p><code> iterator insert(iterator position, const T&amp; x = T());</code></p>
     <p><code> void insert(iterator position, size_type n, const T&amp; x);</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> void insert(iterator position, InputIterator first, InputIterator last);</code></p>
     <p><code> void pop_front();</code></p>
     <p><code> void pop_back();</code></p>
     <p><code> void erase(iterator position);</code></p>
     <p><code> void erase(iterator first, iterator last);</code></p>
     <empty-line/>
     <p><code> // специальные модифицирующие операции cо списком:</code></p>
     <p><code> void splice(iterator position, list‹T, Allocator›&amp; x);</code></p>
     <p><code> void splice(iterator position, list‹T, Allocator›&amp; x, iterator i);</code></p>
     <p><code> void splice(iterator position, list‹T, Allocator›&amp; x, iterator first, iterator last);</code></p>
     <p><code> void remove(const T&amp; value);</code></p>
     <p><code> template ‹class Predicate› </code></p>
     <p><code> void remove_if(Predicate pred);</code></p>
     <p><code> void unique();</code></p>
     <p><code> template ‹class BinaryPredicate› </code></p>
     <p><code> void unique(BinaryPredicate binary_pred);</code></p>
     <p><code> void merge(list‹T, Allocator›&amp; x);</code></p>
     <p><code> template ‹class Compare›</code></p>
     <p><code> void merge(list‹T,Allocator›&amp; x, Compare comp);</code></p>
     <p><code> void reverse();</code></p>
     <p><code> void sort();</code></p>
     <p><code> template ‹class Compare› void sort(Compare comp);</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class T, class Allocator›</code></p>
     <p><code>bool operator==(const list‹T, Allocator›&amp; x, const list‹T, Allocator›&amp; y);</code></p>
     <empty-line/>
     <p><code>template ‹class T, class Allocator›</code></p>
     <p><code>bool operator‹(const list‹T, Allocator›&amp; x, const list‹T, Allocator›&amp; y);</code></p>
     <p>iterator - двунаправленный итератор, ссылающийся на T. Точный тип зависит от исполнения и определяется в Allocator.</p>
     <p>const_iterator - постоянный двунаправленный итератор, ссылающийся на const T. Точный тип зависит от исполнения и определяется в Allocator. Гарантируется, что имеется конструктор для const_iterator из iterator.</p>
     <p>size_type - беззнаковый целочисленный тип. Точный тип зависит от исполнения и определяется в Allocator.</p>
     <p>difference_type - знаковый целочисленный тип. Точный тип зависит от исполнения и определяется в Allocator.</p>
     <p>insert не влияет на действительность итераторов и ссылок. Вставка единственного элемента в список занимает постоянное время, и ровно один раз вызывается конструктор копирования T. Вставка множественных элементов в список зависит линейно от числа вставленных элементов, а число вызовов конструктора копирования T точно равно числу вставленных элементов.</p>
     <p>erase делает недействительными только итераторы и ссылки для стёртых элементов. Стирание единственного элемента - операция постоянного времени с единственным вызовом деструктора T. Стирание диапазона в списке занимает линейное время от размера диапазона, а число вызовов деструктора типа T точно равно размеру диапазона.</p>
     <p>Так как списки позволяют быструю вставку и стирание в середине списка, то некоторые операции определяются специально для них:</p>
     <p>list обеспечивает три операции стыковки, которые разрушительно перемещают элементы из одного списка в другой:</p>
     <p>void splice(iterator position, list‹T, Allocator›&amp; x) вставляет содержимое x перед position, и x становится пустым. Требуется постоянное время. Результат не определён, если &amp;x==this.</p>
     <p>void splice(iterator position, list‹T, Allocator›&amp; x, iterator i) вставляет элемент, указываемый i, из списка x перед position и удаляет элемент из x. Требуется постоянное время. i - допустимый разыменовываемый итератор списка x. Результат не изменяется, если position==i или position==++i.</p>
     <p>void splice(iterator position, list‹T, Allocator›&amp; x, iterator first, iterator last) вставляет элементы из диапазона [first, last) перед position и удаляет элементы из x. Требуется постоянное время, если &amp;x==this; иначе требуется линейное время. [first, last) - допустимый диапазон в x. Результат не определён, если position - итератор в диапазоне [first, last).</p>
     <p>remove стирает все элементы в списке, указанном итератором списка i, для которого выполняются следующие условия: *i==value, pred(*i)==true. remove устойчиво, то есть относительный порядок элементов, которые не удалены, тот же самый, как их относительный порядок в первоначальном списке. Соответствующий предикат применяется точно size() раз.</p>
     <p>unique стирает все, кроме первого элемента, из каждой последовательной группы равных элементов в списке. Соответствующий бинарный предикат применяется точно size() - 1 раз.</p>
     <p>merge сливает список аргумента со списком (предполагается, что оба сортированы). Слияние устойчиво, то есть для равных элементов в двух списках элементы списка всегда предшествуют элементам из списка аргумента. x пуст после слияния. Выполняется, самое большее, size() + x.size() - 1 сравнений.</p>
     <p>reverse переставляет элементы в списке в обратном порядке. Операция линейного времени.</p>
     <p>sort сортирует список согласно operator‹ или сравнивающему функциональному объекту. Она устойчива, то есть относительный порядок равных элементов сохраняется. Выполняется приблизительно NlogN сравнений, где N равно size().</p>
    </section>
    <section>
     <title>
      <p>Двусторонняя очередь (Deque)</p>
     </title>
     <p>deque - вид последовательности, которая, подобно вектору, поддерживает итераторы произвольного доступа. Кроме того она поддерживает операции вставки и стирания в начале или в конце за постоянное время; вставка и стирание в середине занимают линейное время. Как с векторами, управление памятью обрабатывается автоматически.</p>
     <p><code>template ‹class T, template ‹class U› class Allocator = allocator›</code></p>
     <p><code>class deque {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code> // typedefs:</code></p>
     <p><code> typedef iterator;</code></p>
     <p><code> typedef const_iterator;</code></p>
     <p><code> typedef Allocator‹T›::pointer pointer;</code></p>
     <p><code> typedef Allocator‹T›::reference reference;</code></p>
     <p><code> typedef Allocator‹T›::const_reference const_reference;</code></p>
     <p><code> typedef size_type;</code></p>
     <p><code> typedef difference_type;</code></p>
     <p><code> typedef Т value_type;</code></p>
     <p><code> typedef reverse_iterator;</code></p>
     <p><code> typedef const_revcrse_iterator;</code></p>
     <empty-line/>
     <p><code> // размещение/удаление:</code></p>
     <p><code> deque();</code></p>
     <p><code> deque(size_type n, const T&amp; value = T());</code></p>
     <p><code> deque(const deque‹T, Allocator›&amp; x);</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> deque(InputIterator first, InputIterator last);</code></p>
     <p><code> ~deque();</code></p>
     <p><code> deque‹T, Allocator›&amp; operator=(const deque‹T,Allocator›&amp; x);</code></p>
     <p><code> void swap(deque‹T, Allocator›&amp; x);</code></p>
     <empty-line/>
     <p><code> // средства доступа:</code></p>
     <p><code> iterator begin();</code></p>
     <p><code> const_iterator begin() const;</code></p>
     <p><code> iterator end();</code></p>
     <p><code> const_iterator end() const;</code></p>
     <p><code> reverse_iterator rbegin();</code></p>
     <p><code> const_reverse_iterator rbegin();</code></p>
     <p><code> reverse_iterator rend();</code></p>
     <p><code> const_reverse_iterator rend();</code></p>
     <p><code> size_type size() const;</code></p>
     <p><code> size_type max_size() const;</code></p>
     <p><code> bool empty() const;</code></p>
     <p><code> reference operator[](size_type n);</code></p>
     <p><code> const_reference operator[](size_type n) const;</code></p>
     <p><code> reference front();</code></p>
     <p><code> const_reference front() const;</code></p>
     <p><code> reference back();</code></p>
     <p><code> const_reference back() const;</code></p>
     <empty-line/>
     <p><code> // вставка/стирание:</code></p>
     <p><code> void push_front(const T&amp; x);</code></p>
     <p><code> void push_back(const T&amp; x);</code></p>
     <p><code> iterator insert(iterator position, const T&amp; x = T());</code></p>
     <p><code> void insert(iterator position, size_type n, const T&amp; x);</code></p>
     <p><code> template</code></p>
     <p><code> void insert(iterator position, InputIterator first, InputIterator last);</code></p>
     <p><code> void pop_front();</code></p>
     <p><code> void pop_back();</code></p>
     <p><code> void erase(iterator position);</code></p>
     <p><code> void erase(iterator first, iterator last);</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class T, class Allocator›</code></p>
     <p><code>bool operator==(const deque‹T, Allocator›&amp; x, const deque‹T, Allocator›&amp; y);</code></p>
     <empty-line/>
     <p><code>template ‹class T, class Allocator›</code></p>
     <p><code>bool operator‹(const deque‹T, Allocator›&amp; x, const deque‹T, Allocator›&amp; y);</code></p>
     <p>iterator - итератор произвольного доступа, ссылающийся на T. Точный тип зависит от исполнения и определяется в Allocator.</p>
     <p>const_iterator - постоянный итератор произвольного доступа, ссылающийся на const T. Точный тип зависит от исполнения и определяется в Allocator. Гарантируется, что имеется конструктор для const_iterator из iterator.</p>
     <p>size_type - беззнаковый целочисленный тип. Точный тип зависит от исполнения и определяется в Allocator.</p>
     <p>difference_type - знаковый целочисленный тип. Точный зависит от исполнения и определяется в Allocator.</p>
     <p>insert (вставка) в середину двусторонней очереди делает недействительными все итераторы и ссылки двусторонней очереди. insert и push (помещение) с обоих концов двусторонней очереди делают недействительными все итераторы двусторонней очереди, но не влияют на действительность всех ссылок на двустороннюю очередь. В худшем случае вставка единственного элемента в двустороннюю очередь занимает линейное время от минимума двух расстояний: от точки вставки - до начала и до конца двусторонней очереди. Вставка единственного элемента либо в начало, либо в конец двусторонней очереди всегда занимает постоянное время и вызывает единственный запрос конструктора копии T. То есть двусторонняя очередь особенно оптимизирована для помещения и извлечения элементов в начале и в конце.</p>
     <p>erase (стирание) в середине двусторонней очереди делает недействительными все итераторы и ссылки двусторонней очереди. erase и pop (извлечение) с обоих концов двусторонней очереди делают недействительными только итераторы и ссылки на стёртый элемент. Число вызовов деструктора равно числу стёртых элементов, а число вызовов оператора присваивания равно минимуму из числа элементов перед стёртыми элементами и числа элементов после стёртых элементов.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Ассоциативные контейнеры (Associative containers)</p>
    </title>
    <section>
     <p>Ассоциативные контейнеры обеспечивают быстрый поиск данных, основанных на ключах. Библиотека предоставляет четыре основных вида ассоциативных контейнеров: set (множество), multiset (множество с дубликатами), map (словарь) и multimap (словарь с дубликатами).</p>
     <p>Все они берут в качестве параметров Key (ключ) и упорядочивающее отношение Compare, которое вызывает полное упорядочение по элементам Key. Кроме того, map и multimap ассоциируют произвольный тип T с Key. Объект типа Compare называется <emphasis>сравнивающим объектом</emphasis> (<emphasis>comparison object</emphasis>) контейнера.</p>
     <p>В этом разделе, когда мы говорим о равенстве ключей, мы подразумеваем отношение эквивалентности, обусловленное сравнением и <emphasis>не</emphasis> (<emphasis>not</emphasis>) operator== для ключей. То есть считается, что два ключа k1 и k2 являются равными, если для сравнивающего объекта comp истинно comp(k1, k2)==false &amp;&amp; comp(k2, k1)==false.</p>
     <p>Ассоциативный контейнер поддерживает <emphasis>уникальные ключи</emphasis> (<emphasis>unique keys</emphasis>), если он может содержать, самое большее, один элемент для каждого значения ключа. Иначе он поддерживает <emphasis>равные ключи</emphasis> (<emphasis>equal keys</emphasis>). set и map поддерживают уникальные ключи. multiset и multimap поддерживают равные ключи.</p>
     <p>Для set и multiset значимый тип - тот же самый, что и тип ключа. Для map и multimap он равен pair‹const Key, T›.</p>
     <p>iterator ассоциативного контейнера относится к категории двунаправленного итератора. insert не влияет на действительность итераторов и ссылок контейнера, а erase делает недействительными только итераторы и ссылки на стёртые элементы.</p>
     <p>В следующей таблице обозначается: X - класс ассоциативного контейнера, a - значение X, a_uniq - значение X, когда X поддерживает уникальные ключи, a a_eq - значение X, когда X поддерживает многократные ключи, i и j удовлетворяют требованиям итераторов ввода и указывают на элементы value_type, [i, j) - допустимый диапазон, p - допустимый итератор для a, q - разыменовываемый итератор для a, [q1, q2) - допустимый диапазон в a, t - значение X::value_type и k - значение X::key_type.</p>
     <p><strong>Таблица 12. Требования ассоциативных контейнеров (в дополнение к контейнерам)</strong> </p>
     <table>
      <tr align="left">
       <th align="left" valign="top">выражение </th>
       <th align="left" valign="top">возвращаемый тип </th>
       <th align="left" valign="top">утверждение/примечание состояние до/после </th>
       <th align="left" valign="top">сложность </th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X::key_type </td>
       <td align="left" valign="top">Key</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">время компиляции</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X::key_compare </td>
       <td align="left" valign="top">Compare </td>
       <td align="left" valign="top">по умолчанию less‹key_type›. </td>
       <td align="left" valign="top">время компиляции </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X::value_compare </td>
       <td align="left" valign="top">тип бинарного предиката </td>
       <td align="left" valign="top">то же, что key_compare для set и multiset; отношение упорядочения пар, вызванное первым компонентом (т.е. Key), для map и multimap. </td>
       <td align="left" valign="top">время компиляции </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X(c); <emphasis>X a(c); </emphasis></td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">создает пустой контейнер; использует с как объект сравнения. </td>
       <td align="left" valign="top">постоянная </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X(); <emphasis>X a;</emphasis></td>
       <td align="left" valign="top"><emphasis>-</emphasis></td>
       <td align="left" valign="top">создает пустой контейнер; использует Compare() как объект сравнения. </td>
       <td align="left" valign="top">постоянная </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X(i,j,c); X a(i,j,c);</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">cоздает пустой контейнер и вставляет в него элементы из диапазона [i, j); использует с как объект сравнения. </td>
       <td align="left" valign="top">вообще NlogN (N - расстояние от i до j); линейная, если [i, j) отсортирован value_comp() </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">X(i,j); X a(i,j); </td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">то же, что выше, но использует Compare() как объект сравнения. </td>
       <td align="left" valign="top">то же, что выше </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.key_comp() </td>
       <td align="left" valign="top">X::key_compare </td>
       <td align="left" valign="top">возвращает объект сравнения, из которого а был создан. </td>
       <td align="left" valign="top">постоянная </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.value_comp() </td>
       <td align="left" valign="top">X::value_compare </td>
       <td align="left" valign="top">возвращает объект value_compare, созданный из объекта сравнения. </td>
       <td align="left" valign="top">постоянная</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a_uniq.insert(t) </td>
       <td align="left" valign="top">pair‹iterator, bool› </td>
       <td align="left" valign="top">вставляет t, если и только если в контейнере нет элемента с ключом, равным ключу t. Компонент bool возвращенной пары показывает, происходит ли вставка, а компонент пары iterator указывает на элемент с ключом, равным ключу t. </td>
       <td align="left" valign="top">логарифмическая </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a_eq.insert(t) </td>
       <td align="left" valign="top">iterator </td>
       <td align="left" valign="top">вставляет t и возвращает итератор, указывающий на вновь вставленный элемент. </td>
       <td align="left" valign="top">логарифмическая</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.insert(p, t) </td>
       <td align="left" valign="top">iterator </td>
       <td align="left" valign="top">вставляет t, если и только если в контейнерах с уникальными ключами нет элемента с ключом, равным ключу t; всегда вставляет t в контейнеры с дубликатами. всегда возвращает итератор, указывающий на элемент с ключом, равным ключу t. итератор p - подсказка, указывающая, где вставка должна начать поиск. </td>
       <td align="left" valign="top">вообще логарифмическая, но сводится к постоянной, если t вставлен прямо перед p. </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.insert(i, j) </td>
       <td align="left" valign="top">результат не используется </td>
       <td align="left" valign="top">вставляет в контейнер элементы из диапазона [i, j); </td>
       <td align="left" valign="top">вообще Nlog(size()+N) (N - расстояние от i до j); линейная, если [i, j) отсортирован согласно value_comp() </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.erase(k) </td>
       <td align="left" valign="top">size_type </td>
       <td align="left" valign="top">стирает все элементы в контейнере с ключом, равным k. возвращает число уничтоженных элементов. </td>
       <td align="left" valign="top">log(size()) + count(k) </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.erase(q) </td>
       <td align="left" valign="top">результат не используется </td>
       <td align="left" valign="top">стирает элемент, указанный q. </td>
       <td align="left" valign="top">сводится к постоянной </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.erase(ql, q2) </td>
       <td align="left" valign="top">результат не используется </td>
       <td align="left" valign="top">стирает все элементы в диапазоне [ql, q2). </td>
       <td align="left" valign="top">log(size())+ N, где N - расстояние от ql до q2. </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.find(k) </td>
       <td align="left" valign="top">iterator; const_iterator для константы a </td>
       <td align="left" valign="top">возвращает итератор, указывающий на элемент с ключом, равным k, или a.end(), если такой элемент не найден. </td>
       <td align="left" valign="top">логарифмическая</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.count(k) </td>
       <td align="left" valign="top">size_type </td>
       <td align="left" valign="top">возвращает число элементов с ключом, равным k. </td>
       <td align="left" valign="top">log(size()) + count(k) </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.lower_bound(k) </td>
       <td align="left" valign="top">iterator; const_iterator для константы a </td>
       <td align="left" valign="top">возвращает итератор, указывающий на первый элемент с ключом не меньше, чем k. </td>
       <td align="left" valign="top">логарифмическая </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.upper_bound(k) </td>
       <td align="left" valign="top">iterator; const_iterator для константы a </td>
       <td align="left" valign="top">возвращает итератор, указывающий на первый элемент с ключом больше, чем k. </td>
       <td align="left" valign="top">логарифмическая </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">a.equal_range(k) </td>
       <td align="left" valign="top">pair‹iterator, itеrator›; pair‹const_iterator, const_iterator› для константы a </td>
       <td align="left" valign="top">эквивалент make_pair(lower_bound(k), upper_bound(k)). </td>
       <td align="left" valign="top">логарифмическая </td>
      </tr>
     </table>
     <p>Основным свойством итераторов ассоциативных контейнеров является то, что они выполняют итерации через контейнеры в порядке неубывания ключей, где неубывание определено сравнением, которое использовалось для их создания. Для любых двух разыменованных итераторов i и j таких, что расстояние от i до j является положительным, value_comp (*j, *i)==false. Для ассоциативных контейнеров с уникальными ключами выдерживается более сильное условие value_comp(*i, *j)==true.</p>
    </section>
    <section>
     <title>
      <p>Множество (Set)</p>
     </title>
     <p>set - это ассоциативный контейнер, который поддерживает уникальные ключи (не содержит ключи с одинаковыми значениями) и обеспечивает быстрый поиск ключей.</p>
     <p><code>template ‹class Key, class Compare = less‹Key›, template ‹class U› class Allocator = allocator›</code></p>
     <p><code>class set {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code> // typedefs:</code></p>
     <p><code> typedef Key key_type;</code></p>
     <p><code> typedef Key value_type;</code></p>
     <p><code> typedef Allocator‹Key›::pointer pointer;</code></p>
     <p><code> typedef Allocator‹Key›::reference reference;</code></p>
     <p><code> typedef Allocator‹Key›::const_reference const_reference;</code></p>
     <p><code> typedef Compare key_compare;</code></p>
     <p><code> typedef Compare value_compare;</code></p>
     <p><code> typedef iterator;</code></p>
     <p><code> typedef iterator const_iterator;</code></p>
     <p><code> typedef size_type;</code></p>
     <p><code> typedef difference_type;</code></p>
     <p><code> typedef reverse_iterator;</code></p>
     <p><code> typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code> // allocation/deallocation:</code></p>
     <p><code> set(const Compare&amp; comp = Compare());</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> set(InputIterator first, InputIterator last, const Compare&amp; comp = Compare());</code></p>
     <p><code> set(const set‹Key, Compare, Allocator›&amp; x);</code></p>
     <p><code> ~set();</code></p>
     <p><code> set‹Key, Compare, Allocator›&amp; operator=(const set‹Key, Compare, Allocator›&amp; x);</code></p>
     <p><code> void swap(set‹Key, Compare, Allocator›&amp; x);</code></p>
     <empty-line/>
     <p><code> // accessors:</code></p>
     <p><code> key_compare key_comp() const;</code></p>
     <p><code> value_compare value_comp() const;</code></p>
     <p><code> iterator begin() const;</code></p>
     <p><code> iterator end() const;</code></p>
     <p><code> reverse_iterator rbegin() const;</code></p>
     <p><code> reverse_iterator rend() const;</code></p>
     <p><code> bool empty() const;</code></p>
     <p><code> size_type size() const;</code></p>
     <p><code> size_type max_size() const;</code></p>
     <empty-line/>
     <p><code> // insert/erase</code></p>
     <p><code> pair‹iterator, bool› insert(const value_type&amp; x);</code></p>
     <p><code> iterator insert(iterator position, const value_type&amp; x);</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> void insert(InputIterator first, InputIterator last);</code></p>
     <p><code> void erase(iterator position);</code></p>
     <p><code> size_type erase(const key_type&amp; x);</code></p>
     <p><code> void erase(iterator first, iterator last);</code></p>
     <empty-line/>
     <p><code> // set operations:</code></p>
     <p><code> iterator find(const key_type&amp; x) const;</code></p>
     <p><code> size_type count(const key_type&amp; x) const;</code></p>
     <p><code> iterator lower_bound(const key_type&amp; x) const;</code></p>
     <p><code> iterator upper_bound(const key_type&amp; x) const;</code></p>
     <p><code> pair‹iterator, iterator› equal_range(const key_type&amp; x) const;</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Key, class Compare, class Allocator›</code></p>
     <p><code>bool operator==(const set‹Key, Compare, Allocator›&amp; x, const set‹Key, Compare, Allocator›&amp; y);</code></p>
     <empty-line/>
     <p><code>template ‹class Key, class Compare, class Allocator›</code></p>
     <p><code>bool operator‹(const set‹Key, Compare, Allocator›&amp; x, const set‹Key, Compare, Allocator›&amp; y);</code></p>
     <p>iterator - постоянный двунаправленный итератор, указывающий на const value_type. Точный тип зависит от реализации и определяется в Allocator.</p>
     <p>сonst_iterator - тот же самый тип, что и iterator.</p>
     <p>size_type - целочисленный тип без знака. Точный тип зависит от реализации и определяется в Allocator.</p>
     <p>difference_type - целочисленный тип со знаком. Точный тип зависит от реализации и определяется в Allocator.</p>
    </section>
    <section>
     <title>
      <p>Множество с дубликатами (Multiset)</p>
     </title>
     <p>multiset - это ассоциативный контейнер, который поддерживает равные ключи (возможно, содержит множественные копии того же самого значения ключа) и обеспечивает быстрый поиск ключей.</p>
     <p><code>template ‹class Key, class Compare = less‹Key›, template ‹class U› class Allocator = allocator›</code></p>
     <p><code>class multiset {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code> // typedefs:</code></p>
     <p><code> typedef Key key_type;</code></p>
     <p><code> typedef Key value_type;</code></p>
     <p><code> typedef Allocator‹Key›::pointer pointer;</code></p>
     <p><code> typedef Aliocator‹Key›::reference reference;</code></p>
     <p><code> typedef Allocator‹Key›::const_reference const_reference;</code></p>
     <p><code> typedef Compare key_compare;</code></p>
     <p><code> typedef Compare value_compare;</code></p>
     <p><code> typedef iterator;</code></p>
     <p><code> typedef iterator const_iterator;</code></p>
     <p><code> typedef size_type;</code></p>
     <p><code> typedef difference_type;</code></p>
     <p><code> typedef reverse_iterator;</code></p>
     <p><code> typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code> // allocation/deallocation:</code></p>
     <p><code> multiset(const Compare&amp; comp = Compare());</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> multiset(InputIterator first, InputIterator last, const Compare&amp; comp = Compare());</code></p>
     <p><code> multiset(const multiset‹Key, Compare, Allocator›&amp; x);</code></p>
     <p><code> ~multiset();</code></p>
     <p><code> multiset‹Key, Compare, Allocator›&amp; operator=(const multiset‹Key, Compare, Allocator›&amp; x);</code></p>
     <p><code> void swap(multiset‹Key, Compare, Allocator›&amp; x);</code></p>
     <empty-line/>
     <p><code> // accessors:</code></p>
     <p><code> key_compare key_comp() const;</code></p>
     <p><code> value_compare value_comp() const;</code></p>
     <p><code> iterator begin() const;</code></p>
     <p><code> iterator end() const;</code></p>
     <p><code> reverse_iterator rbegin();</code></p>
     <p><code> reverse_iterator rend();</code></p>
     <p><code> bool empty() const;</code></p>
     <p><code> size_type size() const;</code></p>
     <p><code> size_type max_size() const;</code></p>
     <empty-line/>
     <p><code> // insert/erase:</code></p>
     <p><code> iterator insert(const value_type&amp; x);</code></p>
     <p><code> iterator insert(iterator position, const value_type&amp; x);</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> void insert(InputIterator first, InputIterator last);</code></p>
     <p><code> void erase(iterator position);</code></p>
     <p><code> size_type erase(const key_type&amp; x);</code></p>
     <p><code> void erase(iterator first, iterator last);</code></p>
     <empty-line/>
     <p><code> // multiset operations:</code></p>
     <p><code> iterator find(const key_type&amp; x) const;</code></p>
     <p><code> size_type count(const key_type&amp; x) const;</code></p>
     <p><code> iterator lower_bound(const key_type&amp; x) const;</code></p>
     <p><code> iterator upper_bound(const key_type&amp; x) const;</code></p>
     <p><code> pair‹iterator, iterator› equal_range(const key_type&amp; x) const;</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Key, class Compare, class Allocator›</code></p>
     <p><code>bool operator==(const multiset‹Key, Compare, Allocator›&amp; x, const multiset‹Key, Compare, Allocator›&amp; y);</code></p>
     <empty-line/>
     <p><code>template ‹class Key, class Compare, class Allocator›</code></p>
     <p><code>bool operator‹(const multiset‹Key, Compare, Allocator›&amp; x, const multiset‹Key, Compare, Allocator›&amp; y);</code></p>
     <p>iterator - постоянный двунаправленный итератор, указывающий на const value_type. Точный тип зависит от реализации и определяется в Allocator.</p>
     <p>сonst_iterator - тот же самый тип, что и iterator.</p>
     <p>size_type - целочисленный тип без знака. Точный тип зависит от реализации и определяется в Allocator.</p>
     <p>difference_type - целочисленный тип со знаком. Точный тип зависит от реализации и определяется в Allocator.</p>
    </section>
    <section>
     <title>
      <p>Словарь (Map)</p>
     </title>
     <p>map - ассоциативный контейнер, который поддерживает уникальные ключи (не содержит ключи с одинаковыми значениями) и обеспечивает быстрый поиск значений другого типа T, связанных с ключами.</p>
     <p><code>template ‹class Key, class T, class Compare = less‹Key›, template ‹class U› class Allocator = allocator›</code></p>
     <p><code>class map {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code> // typedefs:</code></p>
     <p><code> typedef Key key_type;</code></p>
     <p><code> typedef pair‹const Key, T› value_type;</code></p>
     <p><code> typedef Compare key_compare;</code></p>
     <p><code> class value_compare : public binary_function‹value_type, value_type, bool› {</code></p>
     <p><code>  friend class map;</code></p>
     <p><code> protected:</code></p>
     <p><code>  Compare comp;</code></p>
     <p><code>  value_compare(Compare c): comp(c) {}</code></p>
     <p><code> public:</code></p>
     <p><code>  bool operator()(const value_type&amp; x, const value_type&amp; y) {</code></p>
     <p><code>   return comp(x.first, y.first);</code></p>
     <p><code>  }</code></p>
     <p><code> };</code></p>
     <p><code> typedef iterator;</code></p>
     <p><code> typedef const_iterator;</code></p>
     <p><code> typedef Allocator‹value_type›::pointer pointer;</code></p>
     <p><code> typedef Allocator‹value_type›::reference reference;</code></p>
     <p><code> typedef Allocator‹value_type›::const_reference const_reference;</code></p>
     <p><code> typedef size_type;</code></p>
     <p><code> typedef difference_type;</code></p>
     <p><code> typedef reverse_iterator;</code></p>
     <p><code> typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code> // allocation/deallocation:</code></p>
     <p><code> map(const Compare&amp; comp = Compare());</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> map(InputIterator first, InputIterator last, const Compare&amp; comp = Compare());</code></p>
     <p><code> map(const map‹Key, T, Compare, Allocator›&amp; x);</code></p>
     <p><code> ~map();</code></p>
     <p><code> map‹Key, T, Compare, Allocator›&amp; operator=(const map‹Key, T, Compare, Allocator›&amp; x);</code></p>
     <p><code> void swap(map‹Key, T, Compare, Allocator›&amp; x);</code></p>
     <empty-line/>
     <p><code> // accessors:</code></p>
     <p><code> key_compare key_comp() const;</code></p>
     <p><code> value_compare value_comp() const;</code></p>
     <p><code> iterator begin();</code></p>
     <p><code> const_iterator begin() const;</code></p>
     <p><code> iterator end();</code></p>
     <p><code> const_iterator end() const;</code></p>
     <p><code> reverse_iterator rbegin();</code></p>
     <p><code> const_reverse_iterator rbegin();</code></p>
     <p><code> reverse_iterator rend();</code></p>
     <p><code> const_reverse_iterator rend();</code></p>
     <p><code> bool empty() const;</code></p>
     <p><code> size_type size() const;</code></p>
     <p><code> size_type max_size() const;</code></p>
     <p><code> Allocator‹T›::reference operator[](const key_type&amp; x);</code></p>
     <empty-line/>
     <p><code> // insert/erase:</code></p>
     <p><code> pair‹iterator, bool› insert(const value_type&amp; x);</code></p>
     <p><code> iterator insert(iterator position, const value_type&amp; x);</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> void insert(InputIterator first, InputIterator last);</code></p>
     <p><code> void erase(iterator position);</code></p>
     <p><code> size_type erase(const key_type&amp; x);</code></p>
     <p><code> void erase(iterator first, iterator last);</code></p>
     <empty-line/>
     <p><code> // map operations:</code></p>
     <p><code> iterator find(const key_type&amp; x);</code></p>
     <p><code> const_iterator find(const key_type&amp; x) const;</code></p>
     <p><code> size_type count(const key_type&amp; x) const;</code></p>
     <p><code> iterator lower_bound(const key_type&amp; x);</code></p>
     <p><code> const_iterator lower_bound(const key_type&amp; x) const;</code></p>
     <p><code> iterator upper_bound(const key_type&amp; x);</code></p>
     <p><code> const_iterator upper_bound(const key_type&amp; x) const;</code></p>
     <p><code> pair‹iterator, iterator› equal_range(const key_type&amp; x);</code></p>
     <p><code> pair‹const_iterator, const_iterator› equal_range(const key_type&amp; x)const;</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Key, class T, class Compare, class Allocator›</code></p>
     <p><code>bool operator==(const map‹Key, T, Compare, Allocator›&amp; x, const map‹Key, T, Compare, Allocator›&amp; y);</code></p>
     <empty-line/>
     <p><code>template ‹class Key, class T, class Compare, class Allocator›</code></p>
     <p><code>bool operator‹(const map‹Key, T, Compare, Allocator›&amp; x, const map‹Key, T, Compare, Allocator›&amp; y);</code></p>
     <p>iterator - двунаправленный итератор, указывающий на value_type. Точный тип зависит от реализации и определяется в Allocator.</p>
     <p>const_iterator - постоянный двунаправленный итератор, указывающий на const value_type. Точный тип зависит от реализации и определяется в Allocator. Гарантируется, что имеется конструктор для const_iterator из iterator.</p>
     <p>size_type - целочисленный тип без знака. Точный тип зависит от реализации и определяется в Allocator.</p>
     <p>difference_type - целочисленный тип со знаком. Точный тип зависит от реализации и определяется в Allocator.</p>
     <p>В дополнение к стандартному набору методов ассоциативных контейнеров, map обеспечивает операцию Allocator::reference operator[](const key_type&amp;). Для словаря m и ключа k запись m[k] семантически эквивалентна (*((m.insert(make_pair(k, T()))).first)).second.</p>
    </section>
    <section>
     <title>
      <p>Словарь с дубликатами (Multimар)</p>
     </title>
     <p>multimар - ассоциативный контейнер, который поддерживает равные ключи (возможно, содержит множественные копии того же самого значения ключа) и обеспечивает быстрый поиск значений другого типа T, связанных с ключами.</p>
     <p><code>template ‹class Key, class T, class Compare = less‹Key›, template ‹class U› class Allocator = allocator›</code></p>
     <p><code>class multimap {</code></p>
     <p><code>public:</code></p>
     <empty-line/>
     <p><code> // typedefs:</code></p>
     <p><code> typedef Key key_type;</code></p>
     <p><code> typedef pair‹const Key, T› value_type;</code></p>
     <p><code> typedef Compare key_compare;</code></p>
     <p><code> class value_compare : public binary_function‹value_type, value_type, bool› {</code></p>
     <p><code>  friend class multimap;</code></p>
     <p><code> protected:</code></p>
     <p><code>  Compare comp;</code></p>
     <p><code>  value_compare(Compare c): comp(c) {}</code></p>
     <p><code> public:</code></p>
     <p><code>  bool operator()(const value_type&amp; x, const value_type&amp; y) {</code></p>
     <p><code>   return comp(x.first, y.first);</code></p>
     <p><code>  }</code></p>
     <p><code> };</code></p>
     <p><code> typedef iterator;</code></p>
     <p><code> typedef const_iterator;</code></p>
     <p><code> typedef Allocator‹value_type›::pointer pointer;</code></p>
     <p><code> typedef Allocator‹value_type›::reference reference;</code></p>
     <p><code> typedef Allocator‹value_type›::const_reference const_reference;</code></p>
     <p><code> typedef size_type;</code></p>
     <p><code> typedef difference_type;</code></p>
     <p><code> typedef reverse_iterator;</code></p>
     <p><code> typedef const_reverse_iterator;</code></p>
     <empty-line/>
     <p><code> // allocation/deallocation:</code></p>
     <p><code> multimap(const Compare&amp; comp = Compare());</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> multimap(InputIterator first, InputIterator last, const Compare&amp; comp = Compare());</code></p>
     <p><code> multimap(const multimap‹Key, T, Compare, Allocator›&amp; x);</code></p>
     <p><code> ~multimap();</code></p>
     <p><code> multimap‹Key, T, Compare, Allocator›&amp; operator=(const multimap‹Key, T, Compare, Allocator›&amp; x);</code></p>
     <p><code> void swap(multimap‹Key, T, Compare, Allocator›&amp; x);</code></p>
     <empty-line/>
     <p><code> // accessors:</code></p>
     <p><code> key_compare key_comp() const;</code></p>
     <p><code> value_compare value_comp() const;</code></p>
     <p><code> iterator begin();</code></p>
     <p><code> const_iterator begin() const;</code></p>
     <p><code> iterator end();</code></p>
     <p><code> const_iterator end() const;</code></p>
     <p><code> reverse_iterator rbegin();</code></p>
     <p><code> const_reverse_iterator rbegin();</code></p>
     <p><code> reverse_iterator rend()</code></p>
     <p><code> const_reverse_iterator rend();</code></p>
     <p><code> bool empty() const;</code></p>
     <p><code> size_type size() const;</code></p>
     <p><code> size_type max_size() const;</code></p>
     <empty-line/>
     <p><code> // insert/erase:</code></p>
     <p><code> iterator insert(const value_type&amp; x);</code></p>
     <p><code> iterator insert(iterator position, const value_type&amp; x);</code></p>
     <p><code> template ‹class InputIterator› </code></p>
     <p><code> void insert(InputIterator first, InputIterator last);</code></p>
     <p><code> void erase(iterator position);</code></p>
     <p><code> size_type erase(const key_type&amp; x);</code></p>
     <p><code> void erase(iterator first, iterator last);</code></p>
     <empty-line/>
     <p><code> // multimap operations:</code></p>
     <p><code> iterator find(const key_type&amp; x);</code></p>
     <p><code> const_iterator find(const key_type&amp; x) const;</code></p>
     <p><code> size_type count(const key_type&amp; x) const;</code></p>
     <p><code> iterator lower_bound(const key_type&amp; x);</code></p>
     <p><code> const_iterator lower_bound(const key_type&amp; x) const;</code></p>
     <p><code> iterator upper_bound(const key_type&amp; x);</code></p>
     <p><code> const_iterator upper_bound(const key_type&amp; x) const;</code></p>
     <p><code> pair‹iterator, iterator› equal_range(const key_type&amp; x);</code></p>
     <p><code> pair‹const_iterator, const_iterator› equal_range(const key_type&amp; x) const;</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Key, class T, class Compare, class Allocator›</code></p>
     <p><code>bool operator==(const multimap‹Key, T, Compare, Allocator›&amp; x, const multimap‹Key, T, Compare, Allocator›&amp; y);</code></p>
     <empty-line/>
     <p><code>template ‹class Key, class T, class Compare, class Allocator›</code></p>
     <p><code>bool operator‹(const multimap‹Key, T, Compare, Allocator›&amp; x, const multimap‹Key, T, Compare, Allocator›&amp; y);</code></p>
     <p>iterator - двунаправленный итератор, указывающий на value_type. Точный тип зависит от реализации и определяется в Allocator.</p>
     <p>const_iterator - постоянный двунаправленный итератор, указывающий на value_type. Точный тип зависит от реализации и определяется в Allocator. Гарантируется, что имеется конструктор для const_iterator из iterator.</p>
     <p>size_type - целочисленный тип без знака. Точный тип зависит от реализации и определяется в Allocator.</p>
     <p>difference_type - целочисленный тип со знаком. Точный тип зависит от реализации и определяется в Allocator.</p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>ИТЕРАТОРЫ ПОТОКОВ</p>
   </title>
   <section>
    <p>Чтобы шаблоны алгоритмов могли работать непосредственно с потоками ввода-вывода, предусмотрены соответствующие шаблонные классы, подобные итераторам. Например,</p>
    <p><code>partial_sum_copy(istream_iterator‹double›(cin), istream_iterator‹double›(), ostream_iterator‹double›(cout, "\n"));</code></p>
    <p>читает файл, содержащий числа с плавающей запятой, из cin и печатает частичные суммы в cout.</p>
   </section>
   <section>
    <title>
     <p>Итератор входного потока (Istream Iterator)</p>
    </title>
    <p>istream_iterator‹T› читает (используя operator››) последовательные элементы из входного потока, для которого он был создан. После своего создания итератор каждый раз при использовании ++ читает и сохраняет значение T. Если достигнут конец потока (operator void* () в потоке возвращает false), итератор становится равным значению <emphasis>end-of-stream</emphasis> (<emphasis>конец-потока</emphasis>). Конструктор без параметров istream_iterator() всегда создаёт итераторный объект конца потокового ввода, являющийся единственым законным итератором, который следует использовать для конечного условия. Результат operator* для конца потока не определён, а для любого другого значения итератора возвращается const T&amp;.</p>
    <p>Невозможно записывать что-либо с использованием входных итераторов. Основная особенность входных итераторов - тот факт, что операторы ++ не сохраняют равенства, то есть i==j не гарантирует вообще, что ++i==++j. Каждый раз, когда ++ используется, читается новое значение. Практическое следствие этого факта - то, что входные итераторы могут использоваться только для однопроходных алгоритмов, что действительно имеет здравый смысл, так как многопроходным алгоритмам всегда более соответствует использование структур данных в оперативной памяти.</p>
    <p>Два итератора <emphasis>конец-потока</emphasis> всегда равны. Итератор <emphasis>конец-потока</emphasis> не равен <emphasis>не-конец-потока</emphasis> итератору. Два <emphasis>не-конец-потока</emphasis> итератора равны, когда они созданы из того же самого потока.</p>
    <p><code>template ‹class T, class Distance = ptrdiff_t›</code></p>
    <p><code>class istream_iterator: public input_iterator‹T, Distance› {</code></p>
    <p><code> friend bool operator==(const istream_iterator‹T, Distance›&amp; x, const istream_iterator‹T, Distance›&amp; y);</code></p>
    <p><code>public:</code></p>
    <p><code> istream_iterator();</code></p>
    <p><code> istream_iterator(istream&amp; s);</code></p>
    <p><code> istream_iterator(const istream_iterator‹T, Distance›&amp; x);</code></p>
    <p><code> ~istream_iterator();</code></p>
    <p><code> const T&amp; operator*() const;</code></p>
    <p><code> istream_iterator‹T, Distance›&amp; operator++();</code></p>
    <p><code> istream_iterator‹T, Distance› operator++(int);</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>template ‹class T, class Distance›</code></p>
    <p><code>bool operator==(const istream_iterator‹T, Distance›&amp; x, const istream_iterator‹T, Distance›&amp; y);</code></p>
   </section>
   <section>
    <title>
     <p>Итератор выходного потока (Ostream Iterator)</p>
    </title>
    <p>istream_iterator‹T› записывает (используя operator‹‹) последовательные элементы в выходной поток, из которого он был создан. Если он был создан с параметром конструктора char*, эта строка, называемая <emphasis>строкой разделителя</emphasis> (<emphasis>delimiter string</emphasis>), записывается в поток после того, как записывается каждое T. Невозможно с помощью выходного итератора получить значение. Его единственное использование - выходной итератор в ситуациях, подобных нижеследующему:</p>
    <p><code>while (first != last) *result++ = *first++;</code></p>
    <p>ostream_iterator определён как:</p>
    <p><code>template ‹class T›</code></p>
    <p><code>class ostream_iterator: public output_iterator {</code></p>
    <p><code>public:</code></p>
    <p><code> ostream_iterator(ostream&amp; s);</code></p>
    <p><code> ostream_iterator(ostream&amp; s, const char* delimiter);</code></p>
    <p><code> ostream_iterator(const ostream_iterator‹T›&amp; x);</code></p>
    <p><code> ~ostream_iterator();</code></p>
    <p><code> ostream_iterator‹T›&amp; operator=(const T&amp; value);</code></p>
    <p><code> ostream_iterator‹T›&amp; operator*();</code></p>
    <p><code> ostream_iterator‹T›&amp; operator++();</code></p>
    <p><code> ostream_iterator‹T›&amp; operator++(int);</code></p>
    <p><code>};</code></p>
   </section>
  </section>
  <section>
   <title>
    <p>АЛГОРИТМЫ</p>
   </title>
   <section>
    <p>Все алгоритмы отделены от деталей реализации структур данных и используют в качестве параметров типы итераторов. Поэтому они могут работать с определяемыми пользователем структурами данных, когда эти структуры данных имеют типы итераторов, удовлетворяющие предположениям в алгоритмах.</p>
    <p>Для некоторых алгоритмов предусмотрены и оперативные и копирующие версии. Решение, включать ли копирующую версию, было обычно основано на рассмотрении сложности. Когда стоимость выполнения операции доминирует над стоимостью копии, копирующая версия не включена. Например, sort_copy не включена, так как стоимость сортировки намного значительнее, и пользователи могли бы также делать copy перед sort. Когда такая версия предусмотрена для какого-то алгоритма <emphasis>algorithm</emphasis>, он называется <emphasis>algorithm _copy </emphasis>. Алгоритмы, которые берут предикаты, оканчиваются суффиксом _if (который следует за суффиксом _copy).</p>
    <p>Класс Predicate используется всякий раз, когда алгоритм ожидает функциональный объект, при применении которого к результату разыменования соответствующего итератора возвращается значение, обратимое в bool. Другими словами, если алгоритм берёт Predicate pred как свой параметр и first как свой параметр итератора, он должен работать правильно в конструкции if (pred(*first)) {…}. Предполагается, что функциональный объект pred не применяет какую-либо непостоянную функцию для разыменованного итератора.</p>
    <p>Класс BinaryPredicate используется всякий раз, когда алгоритм ожидает функциональный объект, который при его применении к результату разыменования двух соответствующих итераторов или к разыменованию итератора и типа T, когда T - часть сигнатуры, возвращает значение, обратимое в bool. Другими словами, если алгоритм берёт BinaryPredicate binary_pred как свой параметр и first1 и first2 как свои параметры итераторов, он должен работать правильно в конструкции if (binary_pred(*first, *first2)) {…}. BinaryPredicate всегда берёт тип первого итератора как свой первый параметр, то есть в тех случаях, когда T value - часть сигнатуры, он должен работать правильно в контексте if (binary_pred (*first, value)) {…}. Ожидается, что binary_pred не будет применять какую-либо непостоянную функцию для разыменованных итераторов.</p>
    <p>В описании алгоритмов операторы + и - используются для некоторых категорий итераторов, для которых они не должны быть определены. В этих случаях семантика a+n такая же, как семантика {X tmp = a; advance(tmp, n); return tmp;}, а семантика a-b такая же, как семантика {Distance n; distance(a, b, n); return n;}.</p>
   </section>
   <section>
    <title>
     <p>Не меняющие последовательность операции (Non-mutating sequence operations)</p>
    </title>
    <section>
     <title>
      <p>Операции с каждым элементом (For each)</p>
     </title>
     <p><code>template &lt;class InputIterator, class Function&gt; </code></p>
     <p><code>Function for_each(InputIterator first, InputIterator last, Function f);</code></p>
     <p>for_each применяет f к результату разыменования каждого итератора в диапазоне [first, last) и возвращает f. Принято, что f не применяет какую-то непостоянную функцию к разыменованному итератору. f применяется точно last-first раз. Если f возвращает результат, результат игнорируется.</p>
    </section>
    <section>
     <title>
      <p>Найти (Find)</p>
     </title>
     <p><code>template ‹class InputIterator, class T›</code></p>
     <p><code>InputIterator find(InputIterator first, InputIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator, class Predicate›</code></p>
     <p><code>InputIterator find_if(InputIterator first, InputIterator last, Predicate pred);</code></p>
     <p>find возвращает первый итератор i в диапазоне [first, last), для которого соблюдаются следующие соответствующие условия: *i==value, pred(*i)==true. Если такой итератор не найден, возвращается last. Соответствующий предикат применяется точно find(first, last, value) - first раз.</p>
    </section>
    <section>
     <title>
      <p>Найти рядом (Аdjacent find)</p>
     </title>
     <p><code>template ‹class ForwardIterator›</code></p>
     <p><code>ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class ForwardIterator, class BinaryPredicate›</code></p>
     <p><code>ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred);</code></p>
     <p>adjacent_find возвращает первый итератор i такой, что i и i+1 находятся в диапазоне [first, last) и для которого соблюдаются следующие соответствующие условия: *i==*(i+1), binary_pred(*i, *(i+1))==true. Если такой итератор i не найден, возвращается last. Соответствующий предикат применяется, самое большее, max((last - first) - 1, 0) раз.</p>
    </section>
    <section>
     <title>
      <p>Подсчет (Count)</p>
     </title>
     <p><code>template ‹class InputIterator, class T, class Size›</code></p>
     <p><code>void count(InputIterator first, InputIterator last, const T&amp; value, Size&amp; n);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator, class Predicate, class Size›</code></p>
     <p><code>void count_if(InputIterator first, InputIterator last, Predicate pred, Size&amp; n);</code></p>
     <p>count добавляет к n число итераторов i в диапазоне [first, last), для которых соблюдаются следующие соответствующие условия: *i==value, pred(*i)==true. Соответствующий предикат применяется точно last-first раз.</p>
     <p>count должен сохранять результат в параметре ссылки вместо того, чтобы возвращать его, потому что тип размера не может быть выведен из встроенных типов итераторов, как, например, int*.</p>
    </section>
    <section>
     <title>
      <p>Отличие (Mismatch)</p>
     </title>
     <p><code>template ‹class InputIterator1, class InputIterator2›</code></p>
     <p><code>pair‹InputIterator1, InputIterator2› mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator1, class InputIterator2, class BinaryPredicate›</code></p>
     <p><code>pair‹InputIterator1, InputIterator2› mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred);</code></p>
     <p>mismatch возвращает пару итераторов i и j таких, что j==first2 + (i - first1) и i является первым итератором в диапазоне [first1, last1), для которого следующие соответствующие условия выполнены: !(*i==*(first2 + (i - first1))), binary_pred (*i, *(first2 + (i - first1)))==false. Если такой итератор i не найден, пара last1 и first2 + (last1 - first1) возвращается. Соответствующий предикат применяется, самое большее, last1 - first1 раз.</p>
    </section>
    <section>
     <title>
      <p>Сравнение на равенство (Equal)</p>
     </title>
     <p><code>template ‹class InputIterator1, class InputIterator2›</code></p>
     <p><code>bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator1, class InputIterator2, class BinaryPredicate›</code></p>
     <p><code>bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred);</code></p>
     <p>equal возвращает true, если для каждого итератора i в диапазоне [first1, last1) выполнены следующие соответствующие условия: *i==*(first2 + (i-first1)), binary_pred(*i, *(first2 + (i - first1)))==true. Иначе equal возвращает false. Соответствующий предикат применяется, самое большее, last1 - first1 раз.</p>
    </section>
    <section>
     <title>
      <p>Поиск подпоследовательности (Search)</p>
     </title>
     <p><code>template ‹class ForwardIterator1, class ForwardIterator2›</code></p>
     <p><code>ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);</code></p>
     <empty-line/>
     <p><code>template ‹class ForwardIterator1, class ForwardIterator2, class BinaryPredicate›</code></p>
     <p><code>ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate binary_pred);</code></p>
     <p>search находит подпоследовательность равных значений в последовательности. search возвращает первый итератор i в диапазоне [first1, last1 - (last2 - first2)) такой, что для любого неотрицательного целого числа n, меньшего чем last2 - first2, выполнены следующие соответствующие условия: *(i+n)==*(first2+n), binary_pred(*(i+n), *(first2+n))==true. Если такой итератор не найден, возвращается last1. Соответствующий предикат применяется, самое большее, (last1 - first1) * (last2 - first2) раз. Квадратичное поведение, однако, является крайне маловероятным.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Меняющие последовательность операции (Mutating sequence operations)</p>
    </title>
    <section>
     <title>
      <p>Копировать (Copy)</p>
     </title>
     <p><code>template ‹class InputIterator, class OutputIterator›</code></p>
     <p><code>OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result);</code></p>
     <p>copy копирует элементы. Для каждого неотрицательного целого числа n ‹ (last - first) выполняется присваивание *(result + n) = *(first + n). Точно делается last - first присваиваний. Результат copy не определён, если result находится в диапазоне [first, last).</p>
     <p><code>template ‹class BidirectionalIterator1, class BidirectionalIterator2›</code></p>
     <p><code>BidirectionalIterator2 copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 result);</code></p>
     <p>copy_backward копирует элементы в диапазоне [first, last) в диапазон [result - (last - first), result), начиная от last-1 и продолжая до first. Его нужно использовать вместо copy, когда last находится в диапазоне [result - (last-first), result). Для каждого положительного целого числа n ‹= (last - first) выполняется присваивание *(result-n) = *(last-n). copy_backward возвращает result - (last-first). Точно делается last - first присваиваний. Результат copy_backward не определён, если result находится в диапазоне [first, last).</p>
    </section>
    <section>
     <title>
      <p>Обменять (Swap)</p>
     </title>
     <p><code>template ‹class T›</code></p>
     <p><code>void swap(T&amp; a, T&amp; b);</code></p>
     <p>swap обменивает значения, хранимые в двух местах.</p>
     <p><code>template ‹class ForwardIterator1, class ForwardIterator2›</code></p>
     <p><code>void iter_swap(ForwardIterator1 a, ForwardIterator2 b);</code></p>
     <p>iter_swap обменивает значения, указанные двумя итераторами a и b.</p>
     <p><code>tempate ‹class ForwardIterator1, class ForwardIterator2›</code></p>
     <p><code>ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);</code></p>
     <p>Для каждого неотрицательного целого числа n ‹ (last1 - first1) выполняется перестановка: swap(*(first1 + n), *(first2 + n)). swap_ranges возвращает first2 + (last1 - first1). Выполняется точно last1 - first1 перестановок. Результат swap_ranges не определён, если два диапазона [first1, last1) и [first2, first2 + (last1 - first1)) перекрываются.</p>
    </section>
    <section>
     <title>
      <p>Преобразовать (Transform)</p>
     </title>
     <p><code>template ‹class InputIterator, class OutputIterator, class UnaryOperation›</code></p>
     <p><code>OutputIterator transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator1, class InputIterator2, class OutputIterator, class Binary0peration›</code></p>
     <p><code>OutputIterator transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation binary_op);</code></p>
     <p>transform присваивает посредством каждого итератора i в диапазоне [result, result+(last1-first1)) новое соответствующее значение, равное op(*(first1+(i-result)) или binary_op(*(first1+(i-result), *(first2+(i-result))). transform возвращает result+(last1-first1). Применяются op или binary_op точно last1 - first1 раз. Ожидается, что op и binary_op не имеют каких-либо побочных эффектов. result может быть равен first в случае унарного преобразования или first1 либо first2 в случае бинарного.</p>
    </section>
    <section>
     <title>
      <p>Заменить (Replace)</p>
     </title>
     <p><code>template ‹class ForwardIterator, class T›</code></p>
     <p><code>void replace(ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value);</code></p>
     <empty-line/>
     <p><code>template ‹class ForwardIterator, class Predicate, class T›</code></p>
     <p><code>void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T&amp; new_value);</code></p>
     <p>replace заменяет элементы, указанные итератором i в диапазоне [first, last), значением new_value, когда выполняются следующие соответствующие условия: *i==old_value, pred(*i)==true. Соответствующий предикат применяется точно last - first раз.</p>
     <p><code>template ‹class InputIterator, class OutputIterator, class T›</code></p>
     <p><code>OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T&amp; old_value, const T&amp; new_value);</code></p>
     <empty-line/>
     <p><code>template ‹class Iterator, class OutputIterator, class Predicate, class T›</code></p>
     <p><code>OutputIterator replace_copy_if(Iterator first, Iterator last, OutputIterator result, Predicate pred, const T&amp; new_value);</code></p>
     <p>replace_copy присваивает каждому итератору i в диапазоне [result, result+(last-first)) значение new_value или *(first+(i-result)) в зависимости от выполнения следующих соответствующих условий: *(first+(i-result))==old_value, pred(*(first+(i-result)))==true. replace_copy возвращает result+(last-first). Соответствующий предикат применяется точно last - first раз.</p>
    </section>
    <section>
     <title>
      <p>Заполнить (Fill)</p>
     </title>
     <p><code>template ‹class ForwardIterator, class T›</code></p>
     <p><code>void fill(ForwardIterator first, ForwardIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template ‹class OutputIterator, class Size, class T›</code></p>
     <p><code>OutputIterator fill_n(Output Iterator first, Size n, const T&amp; value);</code></p>
     <p>fill присваивает значения через все итераторы в диапазоне [first, last) или [first, first+n). fill_n возвращает first+n. Точно делается last - first (или n) присваиваний.</p>
    </section>
    <section>
     <title>
      <p>Породить (Generate)</p>
     </title>
     <p><code>template ‹class ForwardIterator, class Generator›</code></p>
     <p><code>void generate(ForwardIterator first, ForwardIterator last, Generator gen);</code></p>
     <empty-line/>
     <p><code>template ‹class OutputIterator, class Size, class Generator›</code></p>
     <p><code>OutputIterator generate_n(OutputIterator first, Size n, Generator gen);</code></p>
     <p>generate вызывает функциональный объект gen и присваивает возвращаемое gen значение через все итераторы в диапазоне [first, last) или [first, first + n). gen не берёт никакие параметры. generate_n возвращает first + n. Точно выполняется last - first (или n) вызовов gen и присваиваний.</p>
    </section>
    <section>
     <title>
      <p>Удалить (Remove)</p>
     </title>
     <p><code>template ‹class ForwardIterator, class T›</code></p>
     <p><code>ForwardIterator remove(ForwardIterator first, ForwardIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template ‹class ForwardIterator, class Predicate›</code></p>
     <p><code>ForwardIterator remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);</code></p>
     <p>remove устраняет все элементы, указываемые итератором i в диапазоне [first, last), для которых выполнены следующие соответствующие условия: *i==value, pred(*i)==true. remove возвращает конец возникающего в результате своей работы диапазона. remove устойчив, то есть относительный порядок элементов, которые не удалены, такой же, как их относительный порядок в первоначальном диапазоне. Соответствующий предикат применяется точно last -first раз.</p>
     <p><code>template ‹class InputIterator, class OutputIterator, class T›</code></p>
     <p><code>OutputIterator remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator, class OutputIterator, class Predicate›</code></p>
     <p><code>OutputIterator remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);</code></p>
     <p>remove_copy копирует все элементы, указываемые итератором i в диапазоне [first, last), для которых не выполнены следующие соответствующие условия: *i==value, pred(*i)==true. remove_copy возвращает конец возникающего в результате своей работы диапазона. remove_copy устойчив, то есть относительный порядок элементов в результирующем диапазоне такой же, как их относительный порядок в первоначальном диапазоне. Соответствующий предикат применяется точно last-first раз.</p>
    </section>
    <section>
     <title>
      <p>Убрать повторы (Unique)</p>
     </title>
     <p><code>template ‹class ForwardIterator›</code></p>
     <p><code>ForwardIterator unique(ForwardIterator first, ForwardIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class ForwardIterator, class BinaryPredicate›</code></p>
     <p><code>ForwardIterator unique(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred);</code></p>
     <p>unique устраняет все, кроме первого, элементы из каждой последовательной группы равных элементов, указываемые итератором i в диапазоне [first, last), для которых выполнены следующие соответствующие условия: *i==*(i-1) или binary_pred(*i, *(i-1))==true. unique возвращает конец возникающего в результате диапазона. Соответствующий предикат применяется точно (last-first)-1 раз.</p>
     <p><code>template ‹class InputIterator, class OutputIterator›</code></p>
     <p><code>OutputIterator unique_copy(InputIterator first, InputIterator last, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator, class OutputIterator, class BinaryPredicate›</code></p>
     <p><code>OutputIterator unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate binary_pred);</code></p>
     <p>unique_copy копирует только первый элемент из каждой последовательной группы равных элементов, указываемых итератором i в диапазоне [first, last), для которых выполнены следующие соответствующие условия: *i==*(i-1) или binary_pied(*i, *(i-1))==true. unique_copy возвращает конец возникающего в результате диапазона. Соответствующий предикат применяется точно (last-first)-1 раз.</p>
    </section>
    <section>
     <title>
      <p>Расположить в обратном порядке (Reverse)</p>
     </title>
     <p><code>template ‹class BidirectionalIterator›</code></p>
     <p><code>void reverse(BidirectionalIterator first, BidirectionalIterator last);</code></p>
     <p>Для каждого неотрицательного целого числа i‹=(last-first)/2 функция reverse применяет перестановку ко всем парам итераторов first+i, (last-i)-1. Выполняется точно (last-first)/2 перестановок.</p>
     <p><code>template ‹class BidirectionalIterator, class OutputIterator›</code></p>
     <p><code>OutputIterator reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);</code></p>
     <p>reverse_copy копирует диапазон [first, last) в диапазон [result, result+(last-first)) такой, что для любого неотрицательного целого числа i ‹ (last-first) происходит следующее присваивание: *(result+(last-first)-i) = *(first+i). reverse_copy возвращает result+(last-first). Делается точно last-first присваиваний. Результат reverse_copy не определён, если [first, last) и [result, result +(last-first)) перекрываются.</p>
    </section>
    <section>
     <title>
      <p>Переместить по кругу (Rotate)</p>
     </title>
     <p><code>template ‹class ForwardIterator›</code></p>
     <p><code>void rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);</code></p>
     <p>Для каждого неотрицательного целого числа i ‹ (last-first) функция rotate помещает элемент из позиции first+i в позицию first+(i+(last-middle))%(last-first). [first, middle) и [middle, last) - допустимые диапазоны. Максимально выполняется last-first перестановок.</p>
     <p><code>template ‹class ForwardIterator, class OutputIterator›</code></p>
     <p><code>OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);</code></p>
     <p>rotate_copy копирует диапазон [first, last) в диапазон [result, result+(last-first)) такой, что для каждого неотрицательного целого числа i ‹ (last-first) происходит следующее присваивание: *(result+(i+(last-middle))%(last-first)) = *(first+i). rotate_copy возвращает result+(last-first). Делается точно last-first присваиваний. Результат rotate_copy не определён, если [first, last) и [result, result+(last-first)) перекрываются.</p>
    </section>
    <section>
     <title>
      <p>Перетасовать (Random shuffle)</p>
     </title>
     <p><code>template ‹class RandomAccessIterator›</code></p>
     <p><code>void random_shuffle(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class RandomNumberGenerator›</code></p>
     <p><code>void random_shuffie(RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator&amp; rand);</code></p>
     <p>random_shuffle переставляет элементы в диапазоне [first, last) с равномерным распределением. Выполняется точно last-first перестановок. random_shuffle может брать в качестве параметра особый генерирующий случайное число функциональный объект rand такой, что rand берёт положительный параметр n типа расстояния RandomAccessIterator и возвращает случайно выбранное значение между 0 и n-1.</p>
    </section>
    <section>
     <title>
      <p>Разделить (Partitions)</p>
     </title>
     <p><code>template ‹class BidirectionalIterator, class Predicate›</code></p>
     <p><code>BidirectionalIterator partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred);</code></p>
     <p>partition помещает все элементы в диапазоне [first, last), которые удовлетворяют pred, перед всеми элементами, которые не удовлетворяют. Возвращается итератор i такой, что для любого итератора j в диапазоне [first, i) будет pred(*j)==true, а для любого итератора k в диапазоне [i, last) будет pred(*k)==false. Делается максимально (last-first)/2 перестановок. Предикат применяется точно last-first раз.</p>
     <p><code>template ‹class BidirectionalIterator, class Predicate›</code></p>
     <p><code>BidirectionalIterator stable_partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred);</code></p>
     <p>stable_partition помещает все элементы в диапазоне [first, last), которые удовлетворяют pred, перед всеми элементами, которые не удовлетворяют. Возвращается итератор i такой, что для любого итератора j в диапазоне [first, i) будет pred(*j)==true, а для любого итератора k в диапазоне [i, last) будет pred(*k)==false. Относительный порядок элементов в обеих группах сохраняется. Делается максимально (last-first)*log(last-first) перестановок, но только линейное число перестановок, если имеется достаточная дополнительная память. Предикат применяется точно last-first раз.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Операции сортировки и отношения (Sorting and related operations)</p>
    </title>
    <section>
     <p>Все операции в этом разделе имеют две версии: одна берёт в качестве параметра функциональный объект типа Compare, а другая использует operator‹.</p>
     <p>Compare - функциональный объект, который возвращает значение, обратимое в bool. Compare comp используется полностью для алгоритмов, принимающих отношение упорядочения. comp удовлетворяет стандартным аксиомам для полного упорядочения и не применяет никакую непостоянную функцию к разыменованному итератору. Для всех алгоритмов, которые берут Compare, имеется версия, которая использует operator‹ взамен. То есть comp(*i, *j)==true по умолчанию для *i‹*j==true.</p>
     <p>Последовательность сортируется относительно компаратора comp, если для любого итератора i, указывающего на элемент в последовательности, и любого неотрицательного целого числе n такого, что i + n является допустимым итератором, указывающим на элемент той же самой последовательности, comp(*(i+n), *i)==false.</p>
     <p>В описаниях функций, которые имеют дело с упорядочивающими отношениями, мы часто используем представление равенства, чтобы описать такие понятия, как устойчивость. Равенство, к которому мы обращаемся, не обязательно operator==, а отношение равенства стимулируется полным упорядочением. То есть два элементa a и b считаются равными, если и только если !(a ‹ b)&amp;&amp;!(b ‹ a).</p>
    </section>
    <section>
     <title>
      <p>Сортировка (Sort)</p>
     </title>
     <p><code>template ‹class RandomAccessIterator›</code></p>
     <p><code>void sort(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class Compare›</code></p>
     <p><code>void sort(RandomAccessIterator first, RandomAccessIterator last, Compare соmр);</code></p>
     <p>sort сортирует элементы в диапазоне [first, last). Делается приблизительно NIogN (где N равняется last-first) сравнений в среднем. Если режим наихудшего случая важен, должны использоваться stable_sort или partial_sort.</p>
     <p><code>template ‹class RandomAccessIterator›</code></p>
     <p><code>void stable_sort(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class Compare›</code></p>
     <p><code>void stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
     <p>stable_sort сортирует элементы в диапазоне [first, last). Он устойчив, то есть относительный порядок равных элементов сохраняется. Делается максимум N(logN)<sup>2</sup> (где N равняется last-first) сравнений; если доступна достаточная дополнительная память, тогда это - NlogN.</p>
     <p><code>template ‹class RandomAccessIterator›</code></p>
     <p><code>void partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class Compare›</code></p>
     <p><code>void partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);</code></p>
     <p>partial_sort помещает первые middle - first сортированных элементов из диапазона [first, last) в диапазон [first, middle). Остальная часть элементов в диапазоне [middle, last) помещена в неопределённом порядке. Берётся приблизительно (last-first)*log(middle-first) сравнений.</p>
     <p><code>template ‹class InputIterator, class RandomAccessIterator›</code></p>
     <p><code>RandomAccessIterator partial_sort_copy(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator, class RandomAccessIterator, class Compare›</code></p>
     <p><code>RandomAccessIterator partial_sort_copy(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);</code></p>
     <p>partial_sort_copy помещает первые min(last-first, result_last-result_first) сортированных элементов в диапазон [result_first, result_first+min(last-first, result_last-result_first)). Возвращается или result_last, или result_first+(last-first), какой меньше. Берётся приблизительно (last-first)*log(min(last-first, result_last-result_first)) сравнений.</p>
    </section>
    <section>
     <title>
      <p>N-й элемент (Nth element)</p>
     </title>
     <p><code>template ‹class RandomAccessIterator›</code></p>
     <p><code>void nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class Compare›</code></p>
     <p><code>void nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);</code></p>
     <p>После операции nth_element элемент в позиции, указанной nth, является элементом, который был бы в той позиции, если бы сортировался целый диапазон. Также для любого итератора i в диапазоне [first, nth) и любого итератора j в диапазоне [nth, last) считается, что !(*i › *j) или comp(*i, *j)==false. Операция линейна в среднем.</p>
    </section>
    <section>
     <title>
      <p>Двоичный поиск (Binary search)</p>
     </title>
     <p>Все алгоритмы в этом разделе - версии двоичного поиска. Они работают с итераторами не произвольного доступа, уменьшая число сравнений, которое будет логарифмическим для всех типов итераторов. Они особенно подходят для итераторов произвольного доступа, так как эти алгоритмы делают логарифмическое число шагов в структуре данных. Для итераторов не произвольного доступа они выполняют линейное число шагов.</p>
     <p><code>template ‹class ForwardIterator, class T›</code></p>
     <p><code>ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template ‹class ForwardIterator, class T, class Compare›</code></p>
     <p><code>ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);</code></p>
     <p>lower_bound находит первую позицию, в которую value может быть вставлено без нарушения упорядочения. lower_bound возвращает самый дальний итератор i в диапазоне [first, last) такой, что для любого итератора j в диапазоне [first, i) выполняются следующие соответствующие условия: *j‹value или comp(*j, value)==true. Делается максимум log(last-first)+1 сравнений.</p>
     <p><code>template ‹class ForwardIterator, class T›</code></p>
     <p><code>ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template ‹class ForwardIterator, class T, class Compare›</code></p>
     <p><code>ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);</code></p>
     <p>upper_bound находит самую дальнюю позицию, в которую value может быть вставлено без нарушения упорядочения. upper_bound возвращает самый дальний итератор i в диапазоне [first, last) такой, что для любого итератора j в диапазоне [first, i) выполняются следующие соответствующие условия: !(value‹*j) или comp(value, *j)==false. Делается максимум log(last-first)+1 сравнений.</p>
     <p><code>template ‹class ForwardIterator, class T›</code></p>
     <p><code>ForwardIterator equal_range(ForwardIterator first, ForwardIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template ‹class ForwardIterator, class T, class Compare›</code></p>
     <p><code>ForwardIterator equal_range(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);</code></p>
     <p>equal_range находит самый большой поддиапазон [i, j) такой, что значение может быть вставлено по любому итератору k в нём. k удовлетворяет соответствующим условиям: !(*k ‹ value)&amp;&amp;!(value ‹ *k) или comp(*k, value)==false&amp;&amp; comp(value, *k)==false. Делается максимум 2*log(last-first)+1 сравнений.</p>
     <p><code>template ‹class ForwardIterator, class T›</code></p>
     <p><code>ForwardIterator binary_search(ForwardIterator first, ForwardIterator last, const T&amp; value);</code></p>
     <empty-line/>
     <p><code>template ‹class ForwardIterator, class T, class Compare›</code></p>
     <p><code>ForwardIterator binary_search(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);</code></p>
     <p>binary_search возвращает истину, если в диапазоне [first, last) имеется итератор i, который удовлетворяет соответствующим условиям: !(*i ‹ value)&amp;&amp;!(value ‹ *i) или comp(*i, value)==false&amp;&amp;comp(value, *i)==false. Делается максимум log(last-first)+2 сравнений.</p>
    </section>
    <section>
     <title>
      <p>Объединение (Merge)</p>
     </title>
     <p><code>template ‹class InputIterator1, class Input Iterator2, class OutputIterator›</code></p>
     <p><code>OutputIterator merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator1, class InputIterator2, class OutputIterator, class Compare›</code></p>
     <p><code>OutputIterator merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);</code></p>
     <p>merge объединяет два сортированных диапазона [first1, last1) и [first2, last2) в диапазон [result, result+(last1-first1)+(last2-first2)). Объединение устойчиво, то есть для равных элементов в двух диапазонах элементы из первого диапазона всегда предшествуют элементам из второго. merge возвращает result+(last1-first1)+(last2-first2). Выполняется максимально (last1-first1)+(last2-first2)-1 сравнений. Результат merge не определён, если возникающий в результате диапазон перекрывается с любым из первоначальных диапазонов.</p>
     <p><code>template ‹class BidirectionalIterator›</code></p>
     <p><code>void inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class BidirectionalIterator, class Compare›</code></p>
     <p><code>void inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);</code></p>
     <p>inplace_merge объединяет два сортированных последовательных диапазона [first, middle) и [middle, last), помещая результат объединения в диапазон [first, last). Объединение устойчиво, то есть для равных элементов в двух диапазонах элементы из первого диапазона всегда предшествуют элементам из второго. Когда доступно достаточно дополнительной памяти, выполняется максимально (last-first)-1 сравнений. Если никакая дополнительная память не доступна, может использоваться алгоритм со сложностью O(NlogN).</p>
    </section>
    <section>
     <title>
      <p>Операции над множеством для сортированных структур (Set operations on sorted structures)</p>
     </title>
     <p>Этот раздел определяет все основные операции над множеством для сортированных структур. Они даже работают с множествами с дубликатами, содержащими множественные копии равных элементов. Семантика операций над множеством обобщена на множества с дубликатами стандартным способом, определяя объединение, содержащее максимальное число местонахождений каждого элемента, пересечение, содержащее минимум, и так далее.</p>
     <p><code>template ‹class InputIterator1, class InputIterator2›</code></p>
     <p><code>bool includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator1, class InputIterator2, class Compare›</code></p>
     <p><code>bool includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);</code></p>
     <p>includes возвращает true, если каждый элемент в диапазоне [first2, last2) содержится в диапазоне [first1, last1). Иначе возвращается false. Выполняется максимально ((last1-first1)+(last2-first2))*2-1 сравнений.</p>
     <p><code>template ‹class InputIterator1, class InputIterator2, class OutputIterator›</code></p>
     <p><code>OutputIterator set_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator1, class InputIterator2, class OutputIterator, class Compare›</code></p>
     <p><code>OutputIterator set_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);</code></p>
     <p>set_union создаёт сортированное объединение элементов из двух диапазонов. Он возвращает конец созданного диапазона. set_union устойчив, то есть, если элемент присутствует в обоих диапазонах, он копируется из первого диапазона. Выполняется максимально ((last1-first1)+(last2-first2))*2-1 сравнений. Результат set_union не определён, если возникающий в результате диапазон перекрывается с любым из первоначальных диапазонов.</p>
     <p><code>template ‹class InputIterator1, class InputIterator2, class OutputIterator›</code></p>
     <p><code>OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator1, class InputIterator2, class OutputIterator, class Compare›</code></p>
     <p><code>OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);</code></p>
     <p>set_intersection создаёт сортированное пересечение элементов из двух диапазонов. Он возвращает конец созданного диапазона. Гарантируется, что set_intersection устойчив, то есть, если элемент присутствует в обоих диапазонах, он копируется из первого диапазона. Выполняется максимально ((last1-first1)+(last2-first2))*2-1 сравнений. Результат set_union не определён, если возникающий в результате диапазон перекрывается с любым из первоначальных диапазонов.</p>
     <p><code>template ‹class InputIterator1, class InputIterator2, class OutputIterator›</code></p>
     <p><code>OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator1, class InputIterator2, class OutputIterator, class Compare›</code></p>
     <p><code>OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);</code></p>
     <p>set_difference создаёт сортированную разность элементов из двух диапазонов. Он возвращает конец созданного диапазона. Выполняется максимально ((last1-first1)+(last2-first2))*2-  сравнений. Результат set_difference не определён, если возникающий в результате диапазон перекрывается с любым из первоначальных диапазонов.</p>
     <p><code>template ‹class InputIterator1, class InputIterator2, class OutputIterator›</code></p>
     <p><code>OutputIterator set_symmetric_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator1, class InputIterator2, class OutputIterator, class Compare›</code></p>
     <p><code>OutputIterator set_symmetric_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);</code></p>
     <p>set_symmetric_difference создаёт сортированную симметричную разность элементов из двух диапазонов. Он возвращает конец созданного диапазона. Выполняется максимально ((last1-first1)+(last2-first2))*2-1 сравнений. Результат set_symmetric_difference не определён, если возникающий в результате диапазон перекрывается с любым из первоначальных диапазонов.</p>
    </section>
    <section>
     <title>
      <p>Операции над пирамидами (Heap operations)</p>
     </title>
     <p>Пирамида - специфическая организация элементов в диапазоне между двумя итераторами произвольного доступа [a, b). Два её ключевые свойства: (1) *a - самый большой элемент в диапазоне, (2) *a может быть удалён с помощью pop_heap или новый элемент добавлен с помощью push_heap за O(logN) время. Эти свойства делают пирамиды полезными для приоритетных очередей. make_heap преобразовывает диапазон в пирамиду, a sort_heap превращает пирамиду в сортированную последовательность.</p>
     <p><code>template ‹class RandomAccessIterator›</code></p>
     <p><code>void push_heap(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class Compare›</code></p>
     <p><code>void push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
     <p>push_heap полагает, что диапазон [first, last-1) является соответствующей пирамидой, и надлежащим образом помещает значение с позиции last-1 в результирующую пирамиду [first, last). Выполняется максимально log(last-first) сравнений.</p>
     <p><code>template ‹class RandomAccessIterator›</code></p>
     <p><code>void pop_heap(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class Compare›</code></p>
     <p><code>void pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
     <p>pop_heap полагает, что диапазон [first, last) является соответствующей пирамидой, затем обменивает значения в позициях first и last-1 и превращает [first, last-1) в пирамиду. Выполняется максимально 2*log(last-first) сравнений.</p>
     <p><code>template ‹class RandomAccessIterator›</code></p>
     <p><code>void make_heap(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class Compare›</code></p>
     <p><code>void make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
     <p>make_heap создает пирамиду из диапазона [first, last). Выполняется максимально 3*(last-first) сравнений.</p>
     <p><code>template ‹class RandomAccessIterator›</code></p>
     <p><code>void sort_heap(RandomAccessIterator first, RandomAccessIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class Compare›</code></p>
     <p><code>void sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
     <p>sort_heap сортирует элементы в пирамиде [first, last). Выполняется максимально NlogN сравнений, где N равно last-first. sort_heap не устойчив.</p>
    </section>
    <section>
     <title>
      <p>Минимум и максимум (Minimum and maximum)</p>
     </title>
     <p><code>template ‹class T›</code></p>
     <p><code>const T&amp; min(const T&amp; a, const T&amp; b);</code></p>
     <empty-line/>
     <p><code>template ‹class T, class Compare›</code></p>
     <p><code>const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);</code></p>
     <empty-line/>
     <p><code>template ‹class T›</code></p>
     <p><code>const T&amp; max(const T&amp; a, const T&amp; b);</code></p>
     <empty-line/>
     <p><code>template ‹class T, class Compare›</code></p>
     <p><code>const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);</code></p>
     <p>min возвращает меньшее, а max большее. min и max возвращают первый параметр, когда их параметры равны.</p>
     <p><code>template ‹class ForwardIterator›</code></p>
     <p><code>ForwardIterator max_element(ForwardIterator first, ForwardIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class ForwardIterator, class Compare›</code></p>
     <p><code>ForwardIterator max_element(ForwardIterator first, ForwardIterator last, Compare comp);</code></p>
     <p>max_element возвращает первый такой итератор i в диапазоне [first, last), что для любого итератора j в диапазоне [first, last) выполняются следующие соответствующие условия: !(*i‹*j) или comp(*i, *j)==false. Выполняется точно max((last-first)-1, 0) соответствующих сравнений.</p>
     <p><code>template ‹class ForwardIterator›</code></p>
     <p><code>ForwardIterator min_element(ForwardIterator first, ForwardIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class ForwardIterator, class Compare›</code></p>
     <p><code>ForwardIterator min_element(ForwardIterator first, ForwardIterator last, Compare comp);</code></p>
     <p>min_element возвращает первый такой итератор i в диапазоне [first, last), что для любого итератора j в диапазоне [first, last) выполняются следующие соответствующие условия: !(*j‹*i) или comp(*j, *i)==false. Выполняется точно max((last-first)-1, 0) соответствующих сравнений.</p>
    </section>
    <section>
     <title>
      <p>Лексикографическое сравнение (Lexicographical comparison)</p>
     </title>
     <p><code>template ‹class InputIterator1, class InputIterator2›</code></p>
     <p><code>bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator1, class InputIterator2, class Compare›</code></p>
     <p><code>bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);</code></p>
     <p>lexicographical_compare возвращает true, если последовательность элементов, определённых диапазоном [first1, last1), лексикографически меньше, чем последовательность элементов, определённых диапазоном [first2, last2). Иначе он возвращает ложь. Выполняется максимально 2*min((last1-first1), (last2-first2)) сравнений.</p>
    </section>
    <section>
     <title>
      <p>Генераторы перестановок (Permutation generators)</p>
     </title>
     <p><code>template ‹class BidirectionalIterator›</code></p>
     <p><code>bool next_permutation(BidirectionalIterator first, BidirectionalIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class BidirectionalIterator, class Compare›</code></p>
     <p><code>bool next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);</code></p>
     <p>next_permutation берёт последовательность, определённую диапазоном [first, last), и трансформирует её в следующую перестановку. Следующая перестановка находится, полагая, что множество всех перестановок лексикографически сортировано относительно operator‹ или comp. Если такая перестановка существует, возвращается true. Иначе он трансформирует последовательность в самую маленькую перестановку, то есть сортированную по возрастанию, и возвращает false. Максимально выполняется (last-first)/2 перестановок.</p>
     <p><code>template ‹class BidirectionalIterator›</code></p>
     <p><code>bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last);</code></p>
     <empty-line/>
     <p><code>template ‹class BidirectionalIterator, class Compare›</code></p>
     <p><code>bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);</code></p>
     <p>prev_permutation берёт последовательность, определённую диапазоном [first, last), и трансформирует её в предыдущую перестановку. Предыдущая перестановка находится, полагая, что множество всех перестановок лексикографически сортировано относительно operator‹ или comp. Если такая перестановка существует, возвращается true. Иначе он трансформирует последовательность в самую большую перестановку, то есть сортированную по убыванию, и возвращает false. Максимально выполняется (last - first)/2 перестановок.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Обобщённые численные операции (Generalized numeric operations)</p>
    </title>
    <section>
     <title>
      <p>Накопление (Accumulate)</p>
     </title>
     <p><code>template ‹class InputIterator, class T›</code></p>
     <p><code>T accumulate(InputIterator first, InputIterator last, T init);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator, class T, class BinaryOperation›</code></p>
     <p><code>T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);</code></p>
     <p>accumulate подобен оператору APL <emphasis>reduction</emphasis> и функции Common Lisp <emphasis>reduce</emphasis>, но он избегает трудности определения результата уменьшения для пустой последовательности, всегда требуя начальное значение. Накопление выполняется инициализацией сумматора acc начальным значением init и последующим изменением его acc = acc+*i или acc = binary_op(acc, *i) для каждого итератора i в диапазоне [first, last) по порядку. Предполагается, что binary_op не вызывает побочных эффектов.</p>
    </section>
    <section>
     <title>
      <p>Скалярное произведение (Inner product)</p>
     </title>
     <p><code>template ‹class InputIterator1, class InputIterator2, class T›</code></p>
     <p><code>T inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator1, class InputIterator2, class T, class BinaryOperation1, class BinaryOperation2›</code></p>
     <p><code>T inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);</code></p>
     <p>inner_product вычисляет свой результат, инициализируя сумматор acc начальным значением init и затем изменяя его acc = acc+(*i1)*(*i2) или acc = binary_op1(acc, binary_op2(*i1, *i2)) для каждого итератора i1 в диапазоне [first, last) и итератора i2 в диапазоне [first2, first2+(last-first)) по порядку. Предполагается, что binary_op1 и binary_op2 не вызывают побочных эффектов.</p>
    </section>
    <section>
     <title>
      <p>Частичная сумма (Partial sum)</p>
     </title>
     <p><code>template ‹class InputIterator, class OutputIterator›</code></p>
     <p><code>OutputIterator partial_sum(InputIterator first, InputIterator last, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator, class OutputIterator, class BinaryOperation›</code></p>
     <p><code>OutputIterator partial_sum(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op);</code></p>
     <p>partial_sum присваивает каждому итератору i в диапазоне [result, result+(last-first)) значение, соответственно равное ((…(*first+*(first+1))+…)+*(first+(i-result))) или binary_op(binary_op(…, binary_op(*first, *(first+1)),…), *(first+(i-result))). Функция partial_sum возвращает result+(last-first). Выполняется binary_op точно (last-first)-1 раз. Ожидается, что binary_op не имеет каких-либо побочных эффектов. result может быть равен first.</p>
    </section>
    <section>
     <title>
      <p>Смежная разность (Adjacent difference)</p>
     </title>
     <p><code>template ‹class InputIterator, class OutputIterator›</code></p>
     <p><code>OutputIterator adjacent_difference(InputIterator first, InputIterator last, OutputIterator result);</code></p>
     <empty-line/>
     <p><code>template ‹class InputIterator, class OutputIterator, class BinaryOperation›</code></p>
     <p><code>OutputIterator adjacent_difference(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op);</code></p>
     <p>adjacent_difference присваивает каждому элементу, указываемому итератором i в диапазоне [result+1, result+(last-first)) значение, соответственно равное *(first+(i-result))-*(first+(i-result)-1) или binary_op(*(first+(i-result)), *(first+(i-result)-1)). Элемент, указываемый result, получает значение *first. Функция adjacent_difference возвращает result+(last-first). Применяется binary_op точно (last-first)-1 раз. Ожидается, что binary_op не имеет каких-либо побочных эффектов. result может быть равен first.</p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>АДАПТЕРЫ</p>
   </title>
   <section>
    <p>Адаптеры - шаблонные классы, которые обеспечивают отображения интерфейса. Например, insert_iterator обеспечивает контейнер интерфейсом итератора вывода.</p>
   </section>
   <section>
    <title>
     <p>Адаптеры контейнеров (Container adaptors)</p>
    </title>
    <section>
     <p>Часто бывает полезно обеспечить ограниченные интерфейсы контейнеров. Библиотека предоставляет stack, queue и priority_queue через адаптеры, которые могут работать с различными типами последовательностей.</p>
    </section>
    <section>
     <title>
      <p>Стек (Stack)</p>
     </title>
     <p>Любая последовательность, поддерживающая операции back, push_back и pop_back, может использоваться для модификации stack. В частности, могут использоваться vector, list и deque.</p>
     <p><code>template ‹class Container›</code></p>
     <p><code>class stack {</code></p>
     <p><code> friend bool operator==(const stack‹Container›&amp; х, const stack‹Container›&amp; y);</code></p>
     <p><code> friend bool operator‹(const stack‹Container›&amp; х, const stack‹Container›&amp; y);</code></p>
     <p><code>public:</code></p>
     <p><code> typedef Container::value_type value_type;</code></p>
     <p><code> typedef Container::size_type size_type;</code></p>
     <p><code>protected:</code></p>
     <p><code> Container c;</code></p>
     <p><code>public:</code></p>
     <p><code> bool empty() const {return c.empty();}</code></p>
     <p><code> size_type size() const {return c.size();}</code></p>
     <p><code> value_type&amp; top() {return c.back();}</code></p>
     <p><code> const value_type&amp; top() const {return c.back();}</code></p>
     <p><code> void push(const value_type&amp; х) {с.push_back(х);}</code></p>
     <p><code> void pop() {c.pop_back();}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Container›</code></p>
     <p><code>bool operator==(const stack ‹Container›&amp; х, const stack‹Container›&amp; y) {return х.с == у.с;}</code></p>
     <empty-line/>
     <p><code>template ‹class Container›</code></p>
     <p><code>bool operator‹(const stack‹Container›&amp; х, const stack‹Container›&amp; y) {return х.с ‹ у.с;}</code></p>
     <p>Например, stack‹vector‹int› › - целочисленный стек, сделанный из vector, а stack‹deque‹char› › - символьный стек, сделанный из deque.</p>
    </section>
    <section>
     <title>
      <p>Очередь (Queue)</p>
     </title>
     <p>Любая последовательность, поддерживающая операции front, push_back и pop_front, может использоваться для модификации queue. В частности, могут использоваться list и deque.</p>
     <p><code>template ‹class Container›</code></p>
     <p><code>class queue {</code></p>
     <p><code> friend bool operator==(const queue‹Container›&amp; х, const queue‹Container›&amp; y);</code></p>
     <p><code> friend bool operator‹(const queue‹Container›&amp; х, const queue‹Container›&amp; y);</code></p>
     <p><code>public:</code></p>
     <p><code> typedef Container::value_type value_type;</code></p>
     <p><code> typedef Container::size_type size_type;</code></p>
     <p><code>protected:</code></p>
     <p><code> Container c;</code></p>
     <p><code>public:</code></p>
     <p><code> bool empty() const {return c.empty();}</code></p>
     <p><code> size_type size() const {return c.size();}</code></p>
     <p><code> value_type&amp; front() {return c.front();}</code></p>
     <p><code> const value_type&amp; front() const {return c.front();}</code></p>
     <p><code> value_type&amp; back() {return c.back();}</code></p>
     <p><code> const value_type&amp; back() const {return c.back();}</code></p>
     <p><code> void push(const value_type&amp; х) {с.push_back(х);}</code></p>
     <p><code> void pop() {с.pop_front();}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Container›</code></p>
     <p><code>bool operator==(const queue‹Container›&amp; х, const queue‹Container›&amp; y) {return х.с == у.с;}</code></p>
     <empty-line/>
     <p><code>template ‹class Container›</code></p>
     <p><code>bool operator‹(const queue‹Container›&amp; х, const queue‹Container›&amp; y) {return х.с ‹ у.с;}</code></p>
    </section>
    <section>
     <title>
      <p>Очередь с приоритетами (Priority queue)</p>
     </title>
     <p>Любая последовательность, с итератором произвольного доступа и поддерживающая операции front, push_back и pop_front, может использоваться для модификации priority_queue. В частности, могут использоваться vector и deque.</p>
     <p><code>template ‹class Container, class Compare = less‹Container::value_type› ›</code></p>
     <p><code>class priority_queue {</code></p>
     <p><code>public:</code></p>
     <p><code> typedef Container::value_type value_type;</code></p>
     <p><code> typedef Container::size_type size_type;</code></p>
     <p><code>protected:</code></p>
     <p><code> Container c;</code></p>
     <p><code> Compare comp;</code></p>
     <p><code>public:</code></p>
     <p><code> priority_queue(const Compare&amp; х = Compare()): c(), comp(х) {}</code></p>
     <p><code> template ‹class InputIterator›</code></p>
     <p><code> priority_queue(InputIterator first, InputIterator last,</code></p>
     <p><code> const Compare&amp; х = Compare()): c(first, last), comp(x) {make_heap(c.begin(), с.end(), comp);}</code></p>
     <p><code> bool empty() const {return c.empty();}</code></p>
     <p><code> size_type size() const {return c.size();}</code></p>
     <p><code> const value_type&amp; top() const {return c.front();}</code></p>
     <p><code> void push(const value_type&amp; х) {</code></p>
     <p><code>  c.push_back(х);</code></p>
     <p><code>  push_heap(c.begin(), c.end(), comp);</code></p>
     <p><code> }</code></p>
     <p><code> void pop() {</code></p>
     <p><code>  pop_heap(c.begin(), c.end(), comp);</code></p>
     <p><code>  с.рор_bасk();</code></p>
     <p><code> }</code></p>
     <p><code>}; // Никакое равенство не обеспечивается</code></p>
    </section>
   </section>
   <section>
    <title>
     <p>Адаптеры итераторов (Iterator adaptors)</p>
    </title>
    <section>
     <title>
      <p>Обратные итераторы (Reverse iterators)</p>
     </title>
     <p>Двунаправленные итераторы и итераторы произвольного доступа имеют соответствующие адаптеры обратных итераторов, которые выполняют итерации через структуру данных в противоположном направлении.Они имеют те же самые сигнатуры, как и соответствующие итераторы. Фундаментальное соотношение между обратным итератором и его соответствующим итератором i установлено тождеством &amp;*(reverse_iterator(i))==&amp;*(i - 1). Это отображение продиктовано тем, что, в то время как после конца массива всегда есть указатель, может не быть допустимого указателя перед началом массива.</p>
     <p><code>template ‹class BidirectionalIterator, class T, class Reference = T&amp;, class Distance = ptrdiff_t›</code></p>
     <p><code>class reverse_bidirectionaiIterator : public bidirectional_iterator‹T, Distance› {</code></p>
     <p><code> typedef reverse_bidirectional_iterator‹BidirectionalIterator, T, Reference, Distance› self;</code></p>
     <p><code> friend bool operator==(const self&amp; х, const self&amp; y);</code></p>
     <p><code>protected:</code></p>
     <p><code> BidirectionalIterator current;</code></p>
     <p><code>public:</code></p>
     <p><code> reverse_bidirectional_iterator() {}</code></p>
     <p><code> reverse_bidirectional_iterator(BidirectionalIterator х) : current(х) {}</code></p>
     <p><code> BidirectionalIterator base() {return current;}</code></p>
     <p><code> Reference operator*() const {</code></p>
     <p><code>  BidirectionalIterator tmp = current;</code></p>
     <p><code>  return *--tmp;</code></p>
     <p><code> }</code></p>
     <p><code> self&amp; operator++() {</code></p>
     <p><code>  --current;</code></p>
     <p><code>  return *this;</code></p>
     <p><code> }</code></p>
     <p><code> self operator++(int) {</code></p>
     <p><code>  self tmp = *this;</code></p>
     <p><code>  --current;</code></p>
     <p><code>  return tmp;</code></p>
     <p><code> }</code></p>
     <p><code> self&amp; operator--() {</code></p>
     <p><code>  ++current;</code></p>
     <p><code>  return *this;</code></p>
     <p><code> }</code></p>
     <p><code> self operator--(int) {</code></p>
     <p><code>  self tmp = *this;</code></p>
     <p><code>  ++current;</code></p>
     <p><code>  return tmp;</code></p>
     <p><code> }</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class BidirectionalIterator, class T, class Reference, class Distance›</code></p>
     <p><code>inline bool operator==(const reverse_bidirectional_iterator‹BidirectionalIterator, T, Reference, Distance›&amp; x, const reverse_bidirectional_iterator‹BidirectionalIterator,</code></p>
     <p><code>T, Reference, Distance›&amp; y) {</code></p>
     <p><code> return x.current==y.current;</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class T, class Reference = T&amp;, class Distance = ptrdiff_t›</code></p>
     <p><code>class reverse_iterator: public random_access_iterator‹T, Distance› {</code></p>
     <p><code> typedef reverse_iterator‹RandomAccessIterator, T, Reference, Distance› self;</code></p>
     <p><code> friend bool operator==(const self&amp; x, const self&amp; y);</code></p>
     <p><code> friend bool operator‹(const self&amp; x, const self&amp; y);</code></p>
     <p><code> friend Distance operator-(const self&amp; x, const self&amp; y);</code></p>
     <p><code> friend self operator+(Distance n, const self&amp; x);</code></p>
     <p><code>protected:</code></p>
     <p><code> RandomAccessIterator current;</code></p>
     <p><code>public:</code></p>
     <p><code> reverse_iterator() {}</code></p>
     <p><code> reverse_iterator(RandomAccessIterator x): current (x) {}</code></p>
     <p><code> RandomAccessIterator base() {return current;}</code></p>
     <p><code> Reference operator*() const {</code></p>
     <p><code>  RandomAccessIterator tmp = current;</code></p>
     <p><code>  return *--tmp;</code></p>
     <p><code> }</code></p>
     <p><code> self&amp; operator++() {</code></p>
     <p><code>  --current;</code></p>
     <p><code>  return *this;</code></p>
     <p><code> }</code></p>
     <p><code> self operator++(int) {</code></p>
     <p><code>  self tmp = *this;</code></p>
     <p><code>  --current;</code></p>
     <p><code>  return tmp; </code></p>
     <p><code> }</code></p>
     <p><code> self&amp; operator--() {</code></p>
     <p><code>  ++current;</code></p>
     <p><code>  return *this;</code></p>
     <p><code> }</code></p>
     <p><code> self operator--(int) {</code></p>
     <p><code>  self tmp = *this;</code></p>
     <p><code>  ++current;</code></p>
     <p><code>  return tmp;</code></p>
     <p><code> }</code></p>
     <p><code> self operator+(Distance n) const {</code></p>
     <p><code>  return self(current - n);</code></p>
     <p><code> }</code></p>
     <p><code> self&amp; operator+=(Distance n) {</code></p>
     <p><code>  current -= n;</code></p>
     <p><code>  return *this;</code></p>
     <p><code> }</code></p>
     <p><code> self operator-(Distance n) const {</code></p>
     <p><code>  return self(current + n);</code></p>
     <p><code> }</code></p>
     <p><code> self operator-=(Distance n) {</code></p>
     <p><code>  current += n;</code></p>
     <p><code>  return *this;</code></p>
     <p><code> }</code></p>
     <p><code> Reference operator[](Distance n) {return *(*this + n);}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class T, class Reference, class Distance›</code></p>
     <p><code>inline bool operator==(const reverse_iterator‹RandomAccessIterator, T, Reference, Distance›&amp; x, const reverse_iterator‹RandomAccessIterator, T, Reference, Distance›&amp; y) {</code></p>
     <p><code> return x.current == y.current;</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class T, class Reference, class Distance›</code></p>
     <p><code>inline bool operator‹(const reverse_iterator‹RandomAccessIterator, T, Reference, Distance›&amp; x, const reverse_iterator‹RandomAccessIterator, T, Reference, Distance›&amp; y) {</code></p>
     <p><code> return y.current ‹ x.current;</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class T, class Reference, class Distance›</code></p>
     <p><code>inline Distance operator-(const reverse_iterator‹RandomAccessIterator, T, Reference, Distance›&amp; х, const reverse_iterator‹RandomAccessIterator, T, Reference, Distance›&amp; y) {</code></p>
     <p><code> return y.current - x.current;</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template ‹class RandomAccessIterator, class T, class Reference, class Distance›</code></p>
     <p><code>inline reverse_iterator‹RandomAccessIterator, T, Reference, Distance› operator+(Distance n, const reverse_iterator‹RandomAccessIterator, T, Reference, Distance›&amp; x) {</code></p>
     <p><code> return reverse_iterator‹RandomAccessIterator, T, Reference, Distance›(x.current - n);</code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>Итераторы вставки (Insert iterators)</p>
     </title>
     <p>Чтобы было возможно иметь дело с вставкой таким же образом, как с записью в массив, в библиотеке обеспечивается специальный вид адаптеров итераторов, называемых <emphasis>итераторами вставки</emphasis> (<emphasis>insert iterators</emphasis>). С обычными классами итераторов</p>
     <p><code>while (first!= last) *result++ = *first++;</code></p>
     <p>вызывает копирование диапазона [first, last) в диапазон, начинающийся с result. Тот же самый код с result, являющимся итератором вставки, вставит соответствующие элементы в контейнер. Такой механизм позволяет всем алгоритмам копирования в библиотеке работать в <emphasis>режиме вставки</emphasis> (<emphasis>insert mode</emphasis>) вместо обычного режима наложения записей.</p>
     <p>Итератор вставки создаётся из контейнера и, возможно, одного из его итераторов, указывающих, где вставка происходит, если это ни в начале, ни в конце контейнера. Итераторы вставки удовлетворяют требованиям итераторов вывода. operator* возвращает непосредственно сам итератор вставки. Присваивание operator=(const T&amp; х) определено для итераторов вставки, чтобы разрешить запись в них, оно вставляет х прямо перед позицией, куда итератор вставки указывает. Другими словами, итератор вставки подобен курсору, указывающему в контейнер, где происходит вставка. back_insert_iterator вставляет элементы в конце контейнера, front_insert_iterator вставляет элементы в начале контейнера, а insert_iterator вставляет элементы, куда итератор указывает в контейнере. back_inserter, front_inserter и inserter - три функции, создающие итераторы вставки из контейнера.</p>
     <p><code>template ‹class Container›</code></p>
     <p><code>class back_insert_iterator: public output_iterator {</code></p>
     <p><code>protected:</code></p>
     <p><code> Container&amp; container;</code></p>
     <p><code>public:</code></p>
     <p><code> back_insert_iterator(Container&amp; x): container(x) {}</code></p>
     <p><code> back_insert_iterator ‹Container›&amp;  operator=(const Container::value_type&amp; value) {</code></p>
     <p><code>  container.push_back(value);</code></p>
     <p><code>  return *this;</code></p>
     <p><code> }</code></p>
     <p><code> back_insert_iterator‹Container›&amp; operator*() {return *this;}</code></p>
     <p><code> back_insert_iterator‹Container›&amp; operator++() {return *this;}</code></p>
     <p><code> back_insert_iterator‹Container›&amp; operator++(int) {return *this;}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Container›</code></p>
     <p><code>back_insert_iterator‹Container› back_inserter(Container&amp; x) {</code></p>
     <p><code> return back_insert_iterator‹Container›(x);</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template ‹class Container›</code></p>
     <p><code>class front_insert_iterator: public output_iterator {</code></p>
     <p><code>protected:</code></p>
     <p><code> Container&amp; container;</code></p>
     <p><code>public:</code></p>
     <p><code> front_insert_iterator(Container&amp; x): container (x) {}</code></p>
     <p><code> front_insert_iterator‹Container›&amp; operator=(const Container::value_type&amp; value) {</code></p>
     <p><code>  container.push_front(value);</code></p>
     <p><code>  return *this;</code></p>
     <p><code> }</code></p>
     <p><code> front_insert_iterator‹Container›&amp; operator*() {return *this;}</code></p>
     <p><code> front_insert_iterator‹Container›&amp; operator++() {return *this;}</code></p>
     <p><code> front_insert_iterator‹Container›&amp; operator++(int) {return *this;}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Container›</code></p>
     <p><code>front_insert_iterator‹Container› front_inserter(Container&amp; x) {</code></p>
     <p><code> return front_insert_iterator‹Container›(х);</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template ‹class Container›</code></p>
     <p><code>class insert_iterator: public output_iterator {</code></p>
     <p><code>protected:</code></p>
     <p><code> Container&amp; container;</code></p>
     <p><code> Container::iterator iter;</code></p>
     <p><code>public:</code></p>
     <p><code> insert_iterator(Container&amp; x, Container::iterator i) : container (x), iter(i) {}</code></p>
     <p><code> insert_iterator‹Container›&amp; operator=(const Container::value_type&amp; value) {</code></p>
     <p><code>  iter = container.insert(iter, value);</code></p>
     <p><code>  ++iter;</code></p>
     <p><code>  return *this;</code></p>
     <p><code> }</code></p>
     <p><code> insert_iterator‹Container›&amp; operator*() {return *this;}</code></p>
     <p><code> insert_iterator‹Container›&amp; operator++() {return *this;}</code></p>
     <p><code> insert_iterator‹Container›&amp; operator++(int) {return *this;}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Container, class Iterator›</code></p>
     <p><code>insert_iterator&lt;Container› inserter(Container&amp; x, Iterator i) {</code></p>
     <p><code> return insert_iterator‹Container›(x, Container::iterator(i));</code></p>
     <p><code>}</code></p>
    </section>
   </section>
   <section>
    <title>
     <p>Адаптеры функций (Function adaptors)</p>
    </title>
    <section>
     <p>Функциональные адаптеры работают только с классами функциональных объектов с определёнными типами параметров и типом результата.</p>
    </section>
    <section>
     <title>
      <p>Отрицатели (Negators)</p>
     </title>
     <p>Отрицатели not1 и not2 берут унарный и бинарный предикаты соответственно и возвращают их дополнения.</p>
     <p><code>template ‹class Predicate›</code></p>
     <p><code>class unary_negate: public unary_function‹Predicate::argument_type, bool› {</code></p>
     <p><code>protected:</code></p>
     <p><code> Predicate pred;</code></p>
     <p><code>public:</code></p>
     <p><code> unary_negate(const Predicate&amp; x): pred(x) {}</code></p>
     <p><code> bool operator()(const argument_type&amp; x) const {return !pred(x);}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Predicate›</code></p>
     <p><code>unary_negate‹Predicate› not1(const Predicate&amp; pred) {</code></p>
     <p><code> return unary_negate‹Predicate›(pred);</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template ‹class Predicate›</code></p>
     <p><code>class binary_negate: public binary_function‹Predicate::first_argument_type, Predicate::second_argument_type, bool› {</code></p>
     <p><code>protected:</code></p>
     <p><code> Predicate pred;</code></p>
     <p><code>public:</code></p>
     <p><code> binary_negate(const Predicate&amp; x): pred(x) {}</code></p>
     <p><code> bool operator()(const first_argument_type&amp; x, const second_argument_type&amp; y) const {</code></p>
     <p><code>  return !pred(x, y);</code></p>
     <p><code> }</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Predicate›</code></p>
     <p><code>binary_negate‹Predicate› not2(const Predicate&amp; pred) {</code></p>
     <p><code> return binary_negate‹Predicate›(pred);</code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>Привязки (Binders)</p>
     </title>
     <p>Привязки bind1st и bind2nd берут функциональный объект f двух параметров и значение x и возвращают функциональный объект одного параметра, созданный из f с первым или вторым параметром соответственно, связанным с х.</p>
     <p><code>template ‹class Predicate›</code></p>
     <p><code>class binder1st: public unary_function {</code></p>
     <p><code>protected:</code></p>
     <p><code> Operation op;</code></p>
     <p><code> Operation::first_argument_type value;</code></p>
     <p><code>public:</code></p>
     <p><code> binder1st(const Operation&amp; x, const Operation::first_argument_type&amp; y) : op(x), value(y) {}</code></p>
     <p><code> result_type operator()(const argument_type&amp; x) const {</code></p>
     <p><code>  return op(value, x);</code></p>
     <p><code> }</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Operation, class T›</code></p>
     <p><code>binder1st‹Operation› bind1st(const Operation&amp; op, const T&amp; x) {</code></p>
     <p><code> return binder1st‹Operation›(op, Operation::first_argument_type(x));</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template ‹class Operation›</code></p>
     <p><code>class binder2nd: public unary_function‹0peration::first_argument_type, Operation::result_type› {</code></p>
     <p><code>protected:</code></p>
     <p><code> Operation op;</code></p>
     <p><code> Operation::second_argument_type value;</code></p>
     <p><code>public:</code></p>
     <p><code> binder2nd(const Operation&amp; x, const Operation::second_argument_type&amp; y) : op(x), value(y) {}</code></p>
     <p><code> result_type operator()(const argument_type&amp; x) const {</code></p>
     <p><code>  return op(x, value);</code></p>
     <p><code> }</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Operation, class T›</code></p>
     <p><code>binder2nd‹Operation› bind2nd(const Operation&amp; op, const T&amp; x) {</code></p>
     <p><code> return binder2nd‹0peration›(op, Operation::second_argument_type(x));</code></p>
     <p><code>}</code></p>
     <p>Например, find_if(v.begin(), v.end(), bind2nd(greater‹int›(), 5)) находит первое целое число в векторе v большее, чем 5; find_if(v.begin(), v.end(), bind1st(greater‹int›(), 5)) находит первое целое число в v меньшее, чем 5.</p>
    </section>
    <section>
     <title>
      <p>Адаптеры указателей на функции (Adaptors for pointers to functions)</p>
     </title>
     <p>Чтобы позволить указателям на (унарные и бинарные) функции работать с функциональными адаптерами, библиотека обеспечивает следующее:</p>
     <p><code>template ‹class Arg, class Result›</code></p>
     <p><code>class pointer_to_unary_function: public unary_function‹Arg, Result› {</code></p>
     <p><code>protected:</code></p>
     <p><code> Result (*ptr)(Arg);</code></p>
     <p><code>public:</code></p>
     <p><code> pointer_to_unary_function() {}</code></p>
     <p><code> pointer_to_unary_function(Result (*x)(Arg)): ptr(x) {}</code></p>
     <p><code> Result operator()(Arg x) const {return ptr(x);}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Arg, class Result›</code></p>
     <p><code>pointer_to_unary_function‹Arg, Result› ptr_fun(Result (*x)(Arg)) {</code></p>
     <p><code> return pointer_to_unary_function‹Arg, Result›(x);</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>template</code></p>
     <p><code>class pointer_to_binary_function: public binary_function {</code></p>
     <p><code>protected:</code></p>
     <p><code> Result (*ptr)(Arg1, Arg2);</code></p>
     <p><code>public:</code></p>
     <p><code> pointer_to_binary_function() {}</code></p>
     <p><code> pointer_to_binary_function(Result (*x)(Arg1, Arg2)): ptr(х) {}</code></p>
     <p><code> Result operator()(Arg1 x, Arg2 y) const {return ptr(x, y);}</code></p>
     <p><code>};</code></p>
     <empty-line/>
     <p><code>template ‹class Arg1, class Arg2, class Result›</code></p>
     <p><code>pointer_to_binary_function‹Arg1, Arg2, Result› ptr_fun(Result (*x)(Arg1, Arg2)) {</code></p>
     <p><code> return pointer_to_binary_function‹Argl, Arg2, Result›(x);</code></p>
     <p><code>}</code></p>
     <p>Например, replace_if(v.begin(), v.end(), not1(bind2nd(ptr_fun(strcmp), "C")), "C++") заменяет все "С" на "C++" в последовательности v.</p>
     <p>Системы трансляции, которые имеют множественный указатель на типы функций, должны обеспечить дополнительные шаблоны функций ptr_fun.</p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>Примитивы управления памятью (Memory Handling Primitives)</p>
   </title>
   <p>Чтобы получать типичный указатель на неинициализированный буфер памяти данного размера, определена следующая функция:</p>
   <p><code>template ‹class T›</code></p>
   <p><code>inline T* allocate(ptrdiff_t n, Т*); // n ›= 0</code></p>
   <p>Размер (в байтах) распределённого буфера - не меньше n*sizeof(T).</p>
   <p>Для каждой модели памяти имеется соответствующий шаблон функции allocate, определённый с типом первого параметра, являющимся типом расстояния указателей в модели памяти.</p>
   <p>Например, если система трансляции поддерживает _huge указатели с типом расстояния long long, обеспечивается следующая шаблонная функция:</p>
   <p><code>template ‹class T›</code></p>
   <p><code>inline T _huge* allocate(long long n, T _huge *);</code></p>
   <p>Также обеспечиваются следующие функции:</p>
   <p><code>template ‹class T›</code></p>
   <p><code>inline void deallocate(T* buffer);</code></p>
   <empty-line/>
   <p><code>template ‹class T1, class T2›</code></p>
   <p><code>inline void construct(T1* p, const T2&amp; value) {new (p) T1(value);}</code></p>
   <empty-line/>
   <p><code>template ‹class T›</code></p>
   <p><code>inline void destroy(T* pointer) {pointer-›~T();}</code></p>
   <p>deallocate освобождает буфер, выделенный allocate. Для каждой модели памяти имеются соответствующие шаблоны функций deallocate, construct и destroy, определённые с типом первого параметра, являющимся типом указателя в модели памяти.</p>
   <p><code>template ‹class T›</code></p>
   <p><code>pair‹T*, ptrdiff_t› get_temporary_buffer(ptrdiff_t n, T*);</code></p>
   <empty-line/>
   <p><code>template ‹class T›</code></p>
   <p><code>void return_temporary_buffer(T* p);</code></p>
   <p>get_temporary_buffer ищет наибольший буфер, не больше чем n*sizeof(T), и возвращает пару, состоящую из адреса и размера (в единицах sizeof(T)) буфера. return_temporary_buffer возвращает буфер, выделенный get_temporary_buffer.</p>
  </section>
  <section>
   <title>
    <p>ПРИМЕРЫ ПРОГРАММ С ШАБЛОНАМИ</p>
   </title>
   <section>
    <p>Эти примеры демонстрируют использование нового продукта STL ‹ToolKit› от компании ObjectSpace. STL ‹ToolKit› - это самый простой способ использования STL, который работает на большинстве комбинаций платформ/компиляторов, включая cfront, Borland, Visual C++, Set C++, ObjectCenter и последние компиляторы от Sun&amp;HP.</p>
   </section>
   <section>
    <title>
     <p>accum1.cpp</p>
    </title>
    <p><code>#include ‹ospace/stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(5);</code></p>
    <p><code> for (int i = 0; i ‹ v.size(); i++) v[i] = i + 1;</code></p>
    <p><code> int sum = accumulate(v.begin(), v.end(), 0);</code></p>
    <p><code> cout ‹‹ "sum = " ‹‹ sum ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>accum2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int mult(int initial_, int element_) {</code></p>
    <p><code> return initial_ * element_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(5);</code></p>
    <p><code> for (int i = 0; i ‹ v.size(); i++) v[i] = i + 1;</code></p>
    <p><code> int prod = accumulate(v.begin(), v.end(), 1, mult);</code></p>
    <p><code> cout ‹‹ "prod = " ‹‹ prod ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>search2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool str_equal(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) == 0 ? 1:0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* grades[] = {"A", "B", "C", "D", "F"};</code></p>
    <p><code>char* letters[] = {"Q", "E", "D"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned gradeCount = sizeof(grades) / sizeof(grades[0]);</code></p>
    <p><code> const unsigned letterCount = sizeof(letters) / sizeof(letters[0]);</code></p>
    <p><code> ostream_iterator ‹char*› iter(cout, " ");</code></p>
    <p><code> cout ‹‹ "grades: ";</code></p>
    <p><code> copy(grades, grades + gradeCount, iter);</code></p>
    <p><code> cout ‹‹ "\nletters:";</code></p>
    <p><code> copy(letters, letters + letterCount, iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <empty-line/>
    <p><code> char** location = search(grades, grades + gradeCount, letters, letters + letterCount, str_equal);</code></p>
    <empty-line/>
    <p><code> if (location == grades + gradeCount) cout ‹‹ "letters not found in grades" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "letters found in grades at offset: " ‹‹ location - grades ‹‹ endl;</code></p>
    <p><code> copy(grades + 1, grades + 1 + letterCount, letters);</code></p>
    <empty-line/>
    <p><code> cout ‹‹ "grades: ";</code></p>
    <p><code> copy(grades, grades + gradeCount, iter);</code></p>
    <p><code> cout ‹‹ "\nletters:";</code></p>
    <p><code> copy(letters, letters + letterCount, iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <empty-line/>
    <p><code> location = search(grades, grades + gradeCount, letters, letters + letterCount, str_equal);</code></p>
    <empty-line/>
    <p><code> if (location == grades + gradeCount) cout ‹‹ "letters not found in grades" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "letters found in grades at offset: " ‹‹ location - grades ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>incl2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool compare_strings(const char* s1_, const char* s2_) {</code></p>
    <p><code> return ::strcmp(s1_, s2_) ‹ 0 ? 1: 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* names[] = {"Todd", "Mike", "Graham", "Jack", "Brett"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned nameSize = sizeof(names)/sizeof(names[0]);</code></p>
    <p><code> vector‹char*› v1(nameSize);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) {</code></p>
    <p><code>  v1[i] = names[i];</code></p>
    <p><code> }</code></p>
    <p><code> vector‹char*› v2(2);</code></p>
    <p><code> v2[0] = "foo";</code></p>
    <p><code> v2[1] = "bar";</code></p>
    <p><code> sort(v1.begin(), v1.end(), compare_strings);</code></p>
    <p><code> sort(v2.begin(), v2.end(), compare_strings);</code></p>
    <empty-line/>
    <p><code> bool inc = includes(v1.begin(), v1.end(), v2.begin(), v2.end(), compare_strings);</code></p>
    <p><code> if (inc) cout ‹‹ "v1 includes v2" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "v1 does not include v2" ‹‹ endl;</code></p>
    <p><code> v2[0] = "Brett";</code></p>
    <p><code> v2[1] = "Todd";</code></p>
    <p><code> inc = includes(v1.begin(), v1.end(), v2.begin(), v2.end(), compare_strings);</code></p>
    <p><code> if (inc) cout ‹‹ "v1 includes v2" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "v1 does not include v2" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>search1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> typedef vector‹int› IntVec;</code></p>
    <p><code> IntVec v1(10);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> IntVec v2(3);</code></p>
    <p><code> iota(v2.begin(), v2.end(), 50);</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <empty-line/>
    <p><code> cout ‹‹ "v1: ";</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "v2: ";</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <empty-line/>
    <p><code> IntVec::iterator location;</code></p>
    <p><code> location = search(v1.begin(), v1.end(), v2.begin(), v2.end());</code></p>
    <p><code> if (location == v1.end()) cout ‹‹ "v2 not contained in v1" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "Found v2 in v1 at offset: " ‹‹ location - v1.begin() ‹‹ endl;</code></p>
    <empty-line/>
    <p><code> iota(v2.begin(), v2.end(), 4);</code></p>
    <p><code> cout ‹‹ "v1: ";</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "v2: ";</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <empty-line/>
    <p><code> location = search(v1.begin(), v1.end(), v2.begin(), v2.end());</code></p>
    <p><code> if (location == v1.end()) cout ‹‹ "v2 not contained in v1" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "Found v2 in v1 at offset: " ‹‹ location - v1.begin() ‹‹ endl;</code></p>
    <empty-line/>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>istmit2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹fstream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>typedef vector‹char› Line;</code></p>
    <p><code>void printLine(const Line* line_)  {</code></p>
    <p><code> vector‹char›::const_iterator i;</code></p>
    <p><code> for (i = line_-›begin(); i!= line_-›end(); i++) cout ‹‹ *i;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> Line buffer;</code></p>
    <p><code> vector‹Line*› lines;</code></p>
    <p><code> ifstream s("data.txt");</code></p>
    <p><code> s.unsetf(ios::skipws); // Disable white-space skipping.</code></p>
    <p><code> istream_iterator‹char, ptrdiff_t› it1(s); // Position at start of file.</code></p>
    <p><code> istream_iterator‹char, ptrdiff_t› it2; // Serves as "past-the-end" marker.</code></p>
    <p><code> copy(it1, it2, back_inserter(buffer));</code></p>
    <p><code> Line::iterator i = buffer.begin();</code></p>
    <p><code> Line::iterator p;</code></p>
    <p><code> while (i != buffer.end()) {</code></p>
    <p><code>  p = find(i, buffer.end(), '\n');</code></p>
    <p><code>  lines.push_back(new Line(i, p));</code></p>
    <p><code>  i = ++p;</code></p>
    <p><code> }</code></p>
    <p><code> sort(lines.begin(), lines.end(), less_p‹Line*›());</code></p>
    <p><code> cout ‹‹ "Read " ‹‹ lines.size() ‹‹ " lines" ‹‹ endl;</code></p>
    <p><code> vector‹Line*›::iterator j;</code></p>
    <p><code> for(j = lines.begin(); j!= lines.end(); j++) printLine(*j);</code></p>
    <p><code> release(lines.begin(), lines.end()); // Release memory.</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>alloc1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹ospace/stl/examples/myaloc.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> {</code></p>
    <p><code>  cout ‹‹ "vectors:" ‹‹ endl;</code></p>
    <p><code>  os_my_allocator‹int› alloc;</code></p>
    <p><code>  vector‹int› v3(alloc);</code></p>
    <p><code>  v3.push_back(42);</code></p>
    <p><code>  vector‹int› v4(alloc);</code></p>
    <p><code>  v4.push_back(42);</code></p>
    <p><code> }</code></p>
    <p><code> {</code></p>
    <p><code>  cout ‹‹ "bit_vectors:" ‹‹ endl;</code></p>
    <p><code>  os_my_allocator‹unsigned int› alloc;</code></p>
    <p><code>  bit_vector v1(alloc);</code></p>
    <p><code>  v1.push_back(1);</code></p>
    <p><code> }</code></p>
    <p><code> {</code></p>
    <p><code>  cout ‹‹ "deques:" ‹‹ endl;</code></p>
    <p><code>  os_my_allocator‹int› alloc;</code></p>
    <p><code>  deque‹int› d(alloc);</code></p>
    <p><code>  d.push_back(42);</code></p>
    <p><code> }</code></p>
    <p><code> {</code></p>
    <p><code>  cout ‹‹ "lists:" ‹‹ endl;</code></p>
    <p><code>  os_my_allocator‹os_list_node‹int› › alloc;</code></p>
    <p><code>  list‹int› l(alloc);</code></p>
    <p><code>  l.push_back(42);</code></p>
    <p><code> }</code></p>
    <p><code> {</code></p>
    <p><code>  cout ‹‹ "sets:" ‹‹ endl;</code></p>
    <p><code>  os_my_allocator‹os_value_node‹int› › alloc;</code></p>
    <p><code>  set‹int, less‹int› › s(alloc);</code></p>
    <p><code>  s.insert(42);</code></p>
    <p><code> }</code></p>
    <p><code> {</code></p>
    <p><code>  cout ‹‹ "maps" ‹‹ endl;</code></p>
    <p><code>  os_my_allocator‹os_value_node‹os_pair‹const int, float› › › alloc;</code></p>
    <p><code>  map‹int, float, less‹int› › m(alloc);</code></p>
    <p><code>  m[4] = 2.0;</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>release2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>class X {</code></p>
    <p><code>public:</code></p>
    <p><code> X(int i_): i (i_) {}</code></p>
    <p><code> ~X() {cout ‹‹ "Delete X(" ‹‹ i ‹‹ ")" ‹‹ endl;}</code></p>
    <p><code> int i;</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>ostream&amp; operator ‹‹ (ostream&amp; stream_, const X&amp; x_) {</code></p>
    <p><code> return stream_ ‹‹ "X(" ‹‹ x_.i ‹‹ ")";</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹X*› v;</code></p>
    <p><code> v.push_back(new X(2));</code></p>
    <p><code> v.push_back(new X(1));</code></p>
    <p><code> v.push_back(new X(4));</code></p>
    <p><code> vector‹X*›::iterator i;</code></p>
    <p><code> cout ‹‹ "Initial contents:" ‹‹ endl;</code></p>
    <p><code> for (i = v.begin(); i!= v.end(); i++) cout ‹‹ " " ‹‹ *(*i) ‹‹ endl;</code></p>
    <p><code> release(v.begin()); // Delete the first heap-based object.</code></p>
    <p><code> v.erase(v.begin()); // Erase the first element.</code></p>
    <p><code> cout ‹‹ "Remaining contents:" ‹‹ endl;</code></p>
    <p><code> for (i = v.begin(); i != v.end(); i++) cout ‹‹ " " ‹‹ *(*i) ‹‹ endl;</code></p>
    <p><code> release(v.begin(), v.end()); // Delete remaining heap-based objects.</code></p>
    <p><code> v.erase(v.begin(), v.end()); // Erase remaining elements.</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>map1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> typedef map‹char, int, less‹char› › maptype;</code></p>
    <p><code> maptype m;</code></p>
    <p><code> // Store mappings between roman numerals and decimals.</code></p>
    <p><code> m['l'] = 50;</code></p>
    <p><code> m['x'] = 20; // Deliberate mistake.</code></p>
    <p><code> m['v'] = 5;</code></p>
    <p><code> m['i'] = 1;</code></p>
    <p><code> cout ‹‹ "m['x'] = " ‹‹ m['x'] ‹‹ endl;</code></p>
    <p><code> m['x'] = 10; // Correct mistake.</code></p>
    <p><code> cout ‹‹ "m['x'] = " ‹‹ m['x'] ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "m['z'] = " ‹‹ m['z'] ‹‹ endl; // Note default value is added.</code></p>
    <p><code> cout ‹‹ "m.count('z') = " ‹‹ m.count('z') ‹‹ endl;</code></p>
    <p><code> pair‹maptype::iterator, bool› p;</code></p>
    <p><code> p = m.insert(pair‹const char, int›('c', 100));</code></p>
    <p><code> if (p.second) cout ‹‹ "First insertion successful" ‹‹ endl;</code></p>
    <p><code> p = m.insert(pair‹const char, int› ('c', 100));</code></p>
    <p><code> if (p.second) cout ‹‹ "Second insertion successful" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "Existing pair " ‹‹ (*(p.first)).first ‹‹ " -› " ‹‹ (*(p.first)).second ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mismtch2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool str_equal(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) == 0 ? 1: 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>const unsigned size = 5;</code></p>
    <p><code>char* n1[size] = {"Brett", "Graham", "Jack", "Mike", "Todd"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> char* n2[size];</code></p>
    <p><code> copy(n1, n1 + 5, n2);</code></p>
    <p><code> pair‹char**, char**› result;</code></p>
    <p><code> result = mismatch(n1, n1+ size, n2, str_equal);</code></p>
    <p><code> if (result.first == n1 + size &amp;&amp; result.second == n2 + size)</code></p>
    <p><code>  cout ‹‹ "n1 and n2 are the same" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "mismatch at index: " ‹‹ (result.first - n1) ‹‹ endl;</code></p>
    <p><code> n2[2] = "QED";</code></p>
    <p><code> result = mismatch(n1, n1 + size, n2, str_equal);</code></p>
    <p><code> if (result.first == n2 + size &amp;&amp; result.second == n2 + size)</code></p>
    <p><code>  cout ‹‹ "n1 and n2 are the same" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "mismatch at index: " ‹‹ (result.first - n1) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mismtch1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> typedef vector‹int› IntVec;</code></p>
    <p><code> IntVec v1(10);</code></p>
    <p><code> IntVec v2(v1.size());</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> iota(v2.begin(), v2.end(), 0);</code></p>
    <p><code> pair ‹IntVec::iterator, IntVec::iterator› result;</code></p>
    <p><code> result = mismatch(v1.begin(), v1.end(), v2.begin());</code></p>
    <p><code> if (result.first = v1.end() &amp;&amp; result.second == v2.end())</code></p>
    <p><code>  cout ‹‹ "v1 and v2 are the same" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "mismatch at index: " ‹‹ (result.first - v1.begin()) ‹‹ endl;</code></p>
    <p><code> v2[v2.size()/2] = 42;</code></p>
    <p><code> result = mismatch(v1.begin(), v1.end(), v2.begin());</code></p>
    <p><code> if (result.first == v1.end() &amp;&amp; result.second == v2.end())</code></p>
    <p><code>  cout ‹‹ "v1 and v2 are the same" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "mismatch at index: " ‹‹ (result.first - v1.begin()) ‹‹ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mmap2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>typedef multimap‹int, char, less‹int› › mmap;</code></p>
    <p><code>typedef pair‹const int, char› pair_type;</code></p>
    <empty-line/>
    <p><code>pair_type p1(3, 'c');</code></p>
    <p><code>pair_type p2(6, 'f');</code></p>
    <p><code>pair_type p3(1, 'a');</code></p>
    <p><code>pair_type p4(2, 'b');</code></p>
    <p><code>pair_type p5(3, 'x');</code></p>
    <p><code>pair_type p6(6, 'f');</code></p>
    <empty-line/>
    <p><code>pair_type array[] = { p1, p2, p3, p4, p5, p6 };</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> mmap m(array, array + 7);</code></p>
    <p><code> mmap::iterator i;</code></p>
    <p><code> // Return location of first element that is not less than 3</code></p>
    <p><code> i = m.lower_bound(3);</code></p>
    <p><code> cout ‹‹ "lower bound:" ‹‹ endl;</code></p>
    <p><code> cout ‹‹ (*i).first ‹‹ " -› " ‹‹ (*i).second ‹‹ endl;</code></p>
    <p><code> // Return location of first element that is greater than 3</code></p>
    <p><code> i = m.upper_bound(3);</code></p>
    <p><code> cout ‹‹ "upper bound:" ‹‹ endl;</code></p>
    <p><code> cout ‹‹ (*i).first ‹‹ " -› " ‹‹ (*i).second ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>adjfind2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>typedef vector‹char*› CStrVector;</code></p>
    <empty-line/>
    <p><code>int equal_length(const char* v1_, const char* v2_) {</code></p>
    <p><code> return ::strlen(v1_) == ::strlen(v2_);</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* names[] = {"Brett", "Graham", "Jack", "Mike", "Todd"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const int nameCount = sizeof(names)/sizeof(names[0]);</code></p>
    <p><code> CStrVector v(nameCount);</code></p>
    <p><code> for (int i = 0; i ‹ nameCount; i++) v[i] = names[i];</code></p>
    <p><code> CStrVector::iterator location;</code></p>
    <p><code> location = adjacent_find(v.begin(), v.end(), equal_length);</code></p>
    <p><code> if (location!= v.end())</code></p>
    <p><code>  cout ‹‹ "Found two adjacent strings of equal length: " ‹‹ *location </code></p>
    <p><code>       ‹‹ " -and- " ‹‹ *(location + 1) ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "Didn't find two adjacent strings of equal length.";</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>list3.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>char array[] = {'x', 'l', 'x', 't', 's', 's'};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> list‹char› str(array, array + 6);</code></p>
    <p><code> list‹char›::iterator i;</code></p>
    <p><code> cout ‹‹ "original: ";</code></p>
    <p><code> for (i = str.begin(); i != str.end(); i++) cout ‹‹ *i;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "reversed: ";</code></p>
    <p><code> str.reverse();</code></p>
    <p><code> for (i = str.begin(); i != str.end(); i++) cout ‹‹ *i;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "removed: ";</code></p>
    <p><code> str.remove('x');</code></p>
    <p><code> for (i = str.begin(); i != str.end(); i++) cout ‹‹ *i;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "uniqued: ";</code></p>
    <p><code> str.unique();</code></p>
    <p><code> for (i = str.begin(); i != str.end(); i++) cout ‹‹ *i;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "sorted: ";</code></p>
    <p><code> str.sort();</code></p>
    <p><code> for (i = str.begin(); i != str.end(); i++) cout ‹‹ *i;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>parsrtc2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) ‹ 0 ? 1: 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* names[] = {"aa", "ff", "dd", "ee", "cc", "bb"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned nameSize = sizeof(names) / sizeof(names[0]);</code></p>
    <p><code> vector‹char*› v1(nameSize);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = names[i];</code></p>
    <p><code> ostream_iterator‹char*› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> vector‹char*› result(5);</code></p>
    <p><code> partial_sort_copy(v1.begin(), v1.end(), result.begin(), result.end(), str_compare);</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec6.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 4, 9, 16, 25, 36};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(array, array + 6);</code></p>
    <p><code> for (int i = 0; i ‹ v.size(); i++) cout ‹‹ "v[" ‹‹ i ‹‹ "] = " ‹‹ v[i] ‹‹ endl;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> v.erase(v.begin()); // Erase first element.</code></p>
    <p><code> for (i = 0; i ‹ v.size(); i++) cout ‹‹ "v[" ‹‹ i ‹‹ "] = " ‹‹ v[i] ‹‹ endl;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> v.erase(v.end() - 1); // Erase last element.</code></p>
    <p><code> for (i = 0; i ‹ v.size(); i++) cout ‹‹ "v[" ‹‹ i ‹‹ "] = " ‹‹ v[i] ‹‹ endl;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> v.erase(v.begin() + 1, v.end() - 1); // Erase all but first and last.</code></p>
    <p><code> for (i = 0; i ‹ v.size(); i++)</code></p>
    <p><code> cout ‹‹ "v[" ‹‹ i ‹‹ "] = " ‹‹ v[i] ‹‹ endl;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> v.erase(); // Erase all.</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>inrprod2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>int add(int a_, int b_) {</code></p>
    <p><code> return a_ + b_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int mult(int a_, int b_) {</code></p>
    <p><code> return a_ * b_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(3);</code></p>
    <p><code> vector‹int› v2(v1.size());</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) {</code></p>
    <p><code>  v1[i] = i + 1;</code></p>
    <p><code>  v2[i] = v1.size() - i;</code></p>
    <p><code> }</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> cout ‹‹ "Inner product(product of sums):\n\t";</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ "\n\t";</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> int result = inner_product(v1.begin(), v1.end(), v2.begin(), 1, mult, add);</code></p>
    <p><code> cout ‹‹ "\nis: " ‹‹ result ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mmap1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> typedef multimap‹char, int, less‹char› › mmap;</code></p>
    <p><code> mmap m;</code></p>
    <p><code> cout ‹‹ "count('X') = " ‹‹ m.count('X') ‹‹ endl;</code></p>
    <p><code> m.insert(pair‹const char, int›('X', 10)); // Standard way.</code></p>
    <p><code> cout ‹‹ "count('X') = " ‹‹ m.count('X') ‹‹ endl;</code></p>
    <p><code> m.insert('X', 20); // Non-standard, but very convenient!</code></p>
    <p><code> cout ‹‹ "count('X') = " ‹‹ m.count('X') ‹‹ endl;</code></p>
    <p><code> m.insert('Y', 32);</code></p>
    <p><code> mmap::iterator i = m.find('X'); // Find first match.</code></p>
    <p><code> while (i != m.end()) { // Loop until end is reached.</code></p>
    <p><code>  cout ‹‹ (*i).first ‹‹ " -› " ‹‹ (*i).second ‹‹ endl;</code></p>
    <p><code>  i++;</code></p>
    <p><code> }</code></p>
    <p><code> int count = m.erase('X');</code></p>
    <p><code> cout ‹‹ "Erased " ‹‹ count ‹‹ " items" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>adjfind0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers1[5] = {1, 2, 4, 8, 16};</code></p>
    <p><code>int numbers2[5] = {5, 3, 2, 1, 1};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int* location = adjacent_find(numbers1, numbers1 + 5);</code></p>
    <empty-line/>
    <p><code> if (location != numbers1 + 5)</code></p>
    <p><code>  cout ‹‹ "Found adjacent pair of: " ‹‹ *location ‹‹ " at offset " ‹‹ (location - numbers1) ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "No adjacent pairs" ‹‹ endl;</code></p>
    <p><code> location = adjacent_find(numbers2, numbers2 + 5);</code></p>
    <p><code> if (location != numbers2 + 5)</code></p>
    <p><code>  cout ‹‹ "Found adjacent pair of: " ‹‹ *location ‹‹ " at offset " ‹‹ (location - numbers2) ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "No adjacent pairs" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>parsrt2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) ‹ 0 ? 1: 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* names[] = {"aa", "ff", "dd", "ee", "cc", "bb"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned nameSize = sizeof(names) / sizeof(names[0]);</code></p>
    <p><code> vector‹char*› v1(nameSize);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = names[i];</code></p>
    <p><code> ostream_iterator‹char*› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> partial_sort(v1.begin(), v1.begin() + nameSize/2, v1.end(), str_compare);</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mset5.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>bool less_than(int a_, int b_) {</code></p>
    <p><code> return a_ ‹ b_;</code></p>
    <p><code>}</code></p>
    <p><code>bool greater_than(int a_, int b_) {</code></p>
    <p><code> return a_ › b_;</code></p>
    <p><code>}</code></p>
    <p><code>int array[] = {3, 6, 1, 9};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> typedef pointer_to_binary_function‹int, int, bool› fn_type;</code></p>
    <p><code> typedef multiset‹int, fn_type› mset;</code></p>
    <p><code> fn_type f(less_than);</code></p>
    <p><code> mset s1(array, array + 4, f);</code></p>
    <p><code> mset::const_iterator i = s1.begin();</code></p>
    <p><code> cout ‹‹ "Using less_than: " ‹‹ endl;</code></p>
    <p><code> while (i != s1.end()) cout ‹‹ *i++ ‹‹ endl;</code></p>
    <p><code> fn_type g(greater_than);</code></p>
    <p><code> mset s2(array, array + 4, g);</code></p>
    <p><code> i = s2.begin();</code></p>
    <p><code> cout ‹‹ "Using greater_than: " ‹‹ endl;</code></p>
    <p><code> while (i != s2.end()) cout ‹‹ *i++ ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mset1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> typedef multiset‹int, less‹int› › mset;</code></p>
    <p><code> mset s;</code></p>
    <p><code> cout ‹‹ "count(42) = " ‹‹ s.count(42) ‹‹ endl;</code></p>
    <p><code> s.insert(42);</code></p>
    <p><code> cout ‹‹ "count(42) = " ‹‹ s.count(42) ‹‹ endl;</code></p>
    <p><code> s.insert(42);</code></p>
    <p><code> cout ‹‹ "count(42) = " ‹‹ s.count(42) ‹‹ endl;</code></p>
    <p><code> set‹int, less‹int› ›::iterator i = s.find(40);</code></p>
    <p><code> if (i == s.end()) cout ‹‹ "40 Not found" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "Found " ‹‹ *i ‹‹ endl;</code></p>
    <p><code> i = s.find(42);</code></p>
    <p><code> if (i == s.end()) cout ‹‹ "Not found" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "Found " ‹‹ *i ‹‹ endl;</code></p>
    <p><code> int count = s.erase(42);</code></p>
    <p><code> cout ‹‹ "Erased " ‹‹ count ‹‹ " instances" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>void print(vector‹double›&amp; vector_) {</code></p>
    <p><code> for (int i = 0; i ‹ vector_.size(); i++)</code></p>
    <p><code> cout ‹‹ vector_[i] ‹‹ " ";</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹double› v1; // Empty vector of doubles.</code></p>
    <p><code> v1.push_back(32.1);</code></p>
    <p><code> v1.push_back(40.5);</code></p>
    <p><code> vector‹double› v2; // Another empty vector of doubles.</code></p>
    <p><code> v2.push_back(3.56);</code></p>
    <p><code> cout ‹‹ "v1 = ";</code></p>
    <p><code> print(v1);</code></p>
    <p><code> cout ‹‹ "v2 = ";</code></p>
    <p><code> print(v2);</code></p>
    <p><code> v1.swap(v2); // Swap the vector's contents.</code></p>
    <p><code> cout ‹‹ "v1 = ";</code></p>
    <p><code> print(v1);</code></p>
    <p><code> cout ‹‹ "v2 = ";</code></p>
    <p><code> print(v2);</code></p>
    <p><code> v2 = v1; // Assign one vector to another.</code></p>
    <p><code> cout ‹‹ "v2 = ";</code></p>
    <p><code> print(v2);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>uniqcpy2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool str_equal(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) - 0 ? 1: 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* labels[] = {"Q","Q","W","W","E","E","R","T","T","Y","Y"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned count = sizeof(labels) / sizeof(labels[0]);</code></p>
    <p><code> ostream_iterator ‹char*› iter(cout);</code></p>
    <p><code> copy(labels, labels + count, iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> char* uCopy[count];</code></p>
    <p><code> fill(uCopy, uCopy + count, ");</code></p>
    <p><code> unique_copy(labels, labels + count, uCopy, str_equal);</code></p>
    <p><code> copy(labels, labels + count, iter);</code></p>
    <p><code>cout ‹‹ endl;</code></p>
    <p><code>copy(uCopy, uCopy + count, iter);</code></p>
    <p><code>cout ‹‹ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mismtch0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int n1[5] = {1, 2, 3, 4, 5};</code></p>
    <p><code>int n2[5] = {1, 2, 3, 4, 5};</code></p>
    <p><code>int n3[5] = {1, 2, 3, 2, 1};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> pair ‹int*, int*› result;</code></p>
    <p><code> result = mismatch(n1, n1 + 5, n2);</code></p>
    <p><code> if (result.first == (n1 + 5) &amp;&amp; result.second == (n2 + 5))</code></p>
    <p><code>  cout ‹‹ "n1 and n2 are the same" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "Mismatch at offset: " ‹‹ (result.first - n1) ‹‹ endl;</code></p>
    <p><code> result = mismatch(n1, n1 + 5, n3);</code></p>
    <p><code> if (result.first == (n1 + 5) &amp;&amp; result.second == (n3 + 5))</code></p>
    <p><code>  cout ‹‹ "n1 and n3 are the same" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "Mismatch at offset: " ‹‹ (result.first - n1) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rndshuf2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹stdlib.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>class MyRandomGenerator {</code></p>
    <p><code>public:</code></p>
    <p><code> nsigned long operator()(unsigned long n_);</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>unsigned long MyRandomGenerator::operator()(unsigned long n_) {</code></p>
    <p><code> return rand() % n_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> ostream_iterator ‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> MyRandomGenerator r;</code></p>
    <p><code> for (int i = 0; i ‹ 3; i++) {</code></p>
    <p><code>  random_shuffle(v1.begin(), v1.end(), r);</code></p>
    <p><code>  copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>  cout ‹‹ endl;</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>merge2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(5);</code></p>
    <p><code> vector‹int› v2(v1.size());</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) {</code></p>
    <p><code>  v1[i] = 10 - i;</code></p>
    <p><code>  v2[i] = 7 - i;</code></p>
    <p><code> }</code></p>
    <p><code> vector‹int› result(v1.size() + v2.size());</code></p>
    <p><code> merge(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin(), greater‹int›());</code></p>
    <p><code> ostream_iterator ‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> copy(result.begin(), result.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>adjfind1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> typedef vector‹int› IntVector;</code></p>
    <p><code> IntVector v(10);</code></p>
    <p><code> for (int i = 0; i ‹ v.size(); i++) v[i] = i;</code></p>
    <p><code> IntVector::iterator location;</code></p>
    <p><code> location = adjacent_find(v.begin(), v.end());</code></p>
    <p><code> if (location != v.end()) cout ‹‹ "Found adjacent pair of: " ‹‹ *location ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "No adjacent pairs" ‹‹ endl;</code></p>
    <p><code> v[6] = 7;</code></p>
    <p><code> location = adjacent_find(v.begin(), v.end());</code></p>
    <p><code> if (location!= v.end())  cout ‹‹ "Found adjacent pair of: " ‹‹ *location ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "No adjacent pairs" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec7.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array1[] = {1, 4, 25};</code></p>
    <p><code>int array2[] = {9, 16};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(array1, array1 + 3);</code></p>
    <p><code> v.insert(v.begin(), 0); // Insert before first element.</code></p>
    <p><code> v.insert(v.end(), 36); // Insert after last element.</code></p>
    <p><code> for (int i = 0; i ‹ v.size(); i++) cout ‹‹ "v[" ‹‹ i ‹‹ "] = " ‹‹ v[i] ‹‹ endl;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> // Insert contents of array2 before fourth element.</code></p>
    <p><code> v.insert(v.begin() + 3, array2, array2 + 2);</code></p>
    <p><code> for (i = 0; i ‹ v.size(); i++)</code></p>
    <p><code> cout ‹‹ "v[" ‹‹ i ‹‹ "] = " ‹‹ v[i] ‹‹ endl;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bcompos1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>struct odd: public unary_function‹int, bool› {</code></p>
    <p><code> odd() {}</code></p>
    <p><code> bool operator() (int n_) const {return (n_ % 2) - 1;}</code></p>
    <p><code>};</code></p>
    <p><code>struct positive: public unary_function‹int, bool› {</code></p>
    <p><code> positive() {}</code></p>
    <p><code> bool operator() (int n_) const {return n_ ›= 0;}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int array[6] = {-2, -1, 0, 1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> binary_compose‹logical_and‹bool›, odd, positive› b(logical_and‹bool›(), odd(), positive());</code></p>
    <p><code> int* p = find_if(array, array + 6, b);</code></p>
    <p><code> if (p != array + 6) cout ‹‹ *p ‹‹ " is odd and positive" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setsymd2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>char* word1 = "ABCDEFGHIJKLMNO";</code></p>
    <p><code>char* word2 = "LMNOPQRSTUVWXYZ";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> ostream_iterator‹char› iter(cout, " ");</code></p>
    <p><code> cout ‹‹ "word1: ";</code></p>
    <p><code> copy(word1, word1 + ::strlen(word1), iter);</code></p>
    <p><code> cout ‹‹ "\nword2: ";</code></p>
    <p><code> copy(word2, word2 + ::strlen(word2), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> set_symmetric_difference(word1, word1 + ::strlen(word1), word2, word2 + ::strlen(word2), iter, less‹char›());</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>search0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int v1[6] = {1, 1, 2, 3, 5, 8};</code></p>
    <p><code>int v2[6] = {0, 1, 2, 3, 4, 5};</code></p>
    <p><code>int v3[2] = {3, 4};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int* location;</code></p>
    <p><code> location = search(v1, v1 + 6, v3, v3 + 2);</code></p>
    <p><code> if (location == v1 + 6) cout ‹‹ "v3 not contained in v1" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "Found v3 in v1 at offset: " ‹‹ location - v1 ‹‹ endl;</code></p>
    <p><code> location = search(v2, v2 + 6, v3, v3 + 2);</code></p>
    <p><code> if (location == v2 + 6) cout ‹‹ "v3 not contained in v2" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "Found v3 in v2 at offset: " ‹‹ location - v2 ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>eqlrnge1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> typedef vector‹int› IntVec;</code></p>
    <p><code> IntVec v(10);</code></p>
    <p><code> for (int i = 0; i ‹ v.size(); i++) v[i] = i / 3;  ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> cout ‹‹ "Within the collection:\n\t";</code></p>
    <p><code> copy(v.begin(), v.end(), iter);</code></p>
    <p><code> pair‹IntVec::iterator, IntVec::iterator› range;</code></p>
    <p><code> range = equal_range(v.begin(), v.end(), 2);</code></p>
    <p><code> cout ‹‹ "\n2 can be inserted from before index " ‹‹ (range.first - v.begin())</code></p>
    <p><code>      ‹‹ " to before index " ‹‹ (range.second - v.begin()) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rotcopy1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code>vector‹int› v1(10);</code></p>
    <p><code>iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code>ostream_iterator ‹int› iter(cout, " ");</code></p>
    <p><code>copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>cout ‹‹ endl;</code></p>
    <p><code>vector‹int› v2(v1.size());</code></p>
    <p><code>for (int i = 0; i ‹ v1.size(); i++) {</code></p>
    <p><code> rotate_copy(v1.begin(), v1.begin() + i, v1.end(), v2.begin());</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code>}</code></p>
    <p><code>cout ‹‹ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>eqlrnge2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>char chars[] = "aabbccddggghhklllmqqqqssyyzz";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned count = sizeof(chars) - 1;</code></p>
    <p><code> ostream_iterator‹char› iter(cout);</code></p>
    <p><code> cout ‹‹ "Within the collection:\n\t";</code></p>
    <p><code> copy(chars, chars + count, iter);</code></p>
    <p><code> pair‹char*, char*› range;</code></p>
    <p><code> range = equal_range(chars, chars + count, 'q', less‹char›());</code></p>
    <p><code> cout ‹‹ "\nq can be inserted from before index " ‹‹ (range.first - chars) ‹‹ " to before index "</code></p>
    <p><code>      ‹‹ (range.second - chars) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>release1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>class X {</code></p>
    <p><code>public:</code></p>
    <p><code> X(int i_): i(i_) {}</code></p>
    <p><code> ~X() {cout ‹‹ "Delete X(" ‹‹ i ‹‹ ")" ‹‹ endl;}</code></p>
    <p><code> int i;</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>ostream&amp; operator ‹‹ (ostream&amp; stream_, const X&amp; x_) {</code></p>
    <p><code> return stream_ ‹‹ "X(" ‹‹ x_.i ‹‹ ")";</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹X*› v;</code></p>
    <p><code> v.push_back(new X(2));</code></p>
    <p><code> v.push_back(new X(1));</code></p>
    <p><code> v.push_back(new X(4));</code></p>
    <p><code> vector‹X*›::iterator i;</code></p>
    <p><code> for (i = v.begin(); i!= v.end(); i++) cout ‹‹ *(*i) ‹‹ endl;</code></p>
    <p><code> release(v.begin(), v.end()); // Delete heap-based objects.</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>incl1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> vector‹int› v2(3);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) {</code></p>
    <p><code>  v1[i] = i;</code></p>
    <p><code> }</code></p>
    <p><code> if (includes(v1.begin(), v1.end(), v2.begin(), v2.end())) cout ‹‹ "v1 includes v2" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "v1 does not include v2" ‹‹ endl;</code></p>
    <p><code> for (i = 0; i ‹ v2.size(); i++) v2[i] = i + 3;</code></p>
    <p><code> if (includes(v1.begin(), v1.end(), v2.begin(), v2.end())) cout ‹‹ "v1 includes v2" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "v1 does not include v2" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setintr2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>char* word1 = "ABCDEFGHIJKLMNO";</code></p>
    <p><code>char* word2 = "LMNOPQRSTUVWXYZ";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> ostream_iterator ‹char› iter(cout, " ");</code></p>
    <p><code> cout ‹‹ "word1: ";</code></p>
    <p><code> copy(word1, word1 + ::strlen(word1), iter);</code></p>
    <p><code> cout ‹‹ "\nword2: ";</code></p>
    <p><code> copy(word2, word2 + ::strlen(word2), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> set_intersection(word1, word1 + ::strlen(word1), word2, word2 + ::strlen(word2), iter, less‹char›());</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>inrprod1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(3);</code></p>
    <p><code> vector‹int› v2(v1.size());</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) {</code></p>
    <p><code>  v1[i] = i + 1;</code></p>
    <p><code>  v2[i] = v1.size() - i;</code></p>
    <p><code> }</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> cout ‹‹ "Inner product(sum of products) of:\n\t";</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ "\n\t";</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> int result = inner_product(v1.begin(), v1.end(), v2.begin(), 0);</code></p>
    <p><code>cout ‹‹ "\nis: " ‹‹ result ‹‹ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>merge1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(5);</code></p>
    <p><code> vector‹int› v2(v1.size());</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> iota(v2.begin(), v2.end(), 3);</code></p>
    <p><code> vector‹int› result(v1.size() + v2.size());</code></p>
    <p><code> merge(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> copy(result.begin(), result.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bcompos2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>struct odd: public unary_function‹int, bool› {</code></p>
    <p><code> odd() {}</code></p>
    <p><code> bool operator() (int n_) const  {return (n_ % 2) - 1;}</code></p>
    <p><code>};</code></p>
    <p><code>struct positive: public unary_function‹int, bool› {</code></p>
    <p><code> positive() {}</code></p>
    <p><code> bool operator() (int n_) const  {return n_ ›= 0;}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int array[6] = {-2, -1, 0, 1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int* p = find_if(array, array + 6, compose2(logical_and‹bool›(), odd(), positive()));</code></p>
    <p><code> if (p != array + 6) cout ‹‹ *p ‹‹ " is odd and positive" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>error3.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>// Compile this code without defining OS_USE_EXCEPTIONS.</code></p>
    <p><code>void my_handler(int code_, const char* str_) {</code></p>
    <p><code> cout ‹‹ "Caught " ‹‹ str_ ‹‹ "[code " ‹‹ code_ ‹‹ "]" ‹‹ endl;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> os_handler_function_t old_h = os_set_error_handler(my_handler);</code></p>
    <p><code> vector‹int› v;</code></p>
    <p><code> v.pop_back(); // Generates an empty object error.</code></p>
    <p><code> cout ‹‹ "returned from pop_back()" ‹‹ endl;</code></p>
    <p><code> os_set_error_handler(old_h);</code></p>
    <p><code> v.pop_back(); // Generates an empty object error.</code></p>
    <p><code> cout ‹‹ "successful termination" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>incl0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers1[5] = {1, 2, 3, 4, 5};</code></p>
    <p><code>int numbers2[5] = {1, 2, 4, 8, 16};</code></p>
    <p><code>int numbers3[2] = {4, 8};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> if (includes(numbers1, numbers1 + 5, numbers3, numbers3 + 2))</code></p>
    <p><code>  cout ‹‹ "numbers1 includes numbers3" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "numbers1 does not include numbers3" ‹‹ endl;</code></p>
    <p><code> if (includes(numbers2, numbers2 + 5, numbers3, numbers3 + 2))</code></p>
    <p><code>  cout ‹‹ "numbers2 includes numbers3" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "numbers2 does not include numbers3" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setdiff2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>char* word1 = "ABCDEFGHIJKLMNO";</code></p>
    <p><code>char* word2 = "LMNOPQRSTUVWXYZ";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> ostream_iterator‹char› iter(cout, " ");</code></p>
    <p><code> cout ‹‹ "word1: ";</code></p>
    <p><code> copy(word1, word1 + ::strlen(word1), iter);</code></p>
    <p><code> cout ‹‹ "\nword2: ";</code></p>
    <p><code> copy(word2, word2 + ::strlen(word2), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> set_difference(word1, word1 + ::strlen(word1),  word2, word2 + ::strlen(word2), iter, less‹char›());</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setunon2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>char* word1 = "ABCDEFGHIJKLMNO";</code></p>
    <p><code>char* word2 = "LMNOPQRSTUVWXYZ";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> ostream_iterator‹char› iter(cout, " ");</code></p>
    <p><code> cout ‹‹ "word1: ";</code></p>
    <p><code> copy(word1, word1 + ::strlen(word1), iter);</code></p>
    <p><code> cout ‹‹ "\nword2: ";</code></p>
    <p><code> copy(word2, word2 + ::strlen(word2), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> set_union(word1, word1 + ::strlen(word1),  word2, word2 + ::strlen(word2), iter, less‹char›());</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>unique2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool str_equal(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) == 0 ? 1: 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* labels[] = {"Q","Q","W","W","E","E","R","T","T","Y","Y"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned count = sizeof(labels) / sizeof(labels[0]);</code></p>
    <p><code> ostream_iterator‹char*› iter(cout);</code></p>
    <p><code> copy(labels, labels + count, iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> unique(labels, labels + count, str_equal);</code></p>
    <p><code> copy(labels, labels + count, iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>parsrtc1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹stdlib.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = rand() % 10;</code></p>
    <p><code> vector‹int› result(5);</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> partial_sort_copy(v1.begin(), v1.end(), result.begin(), result.end());</code></p>
    <p><code> copy(result.begin(), result.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>equal1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = i;</code></p>
    <p><code> vector‹int› v2(10);</code></p>
    <p><code> if (equal(v1.begin(), v1.end(), v2.begin())) cout ‹‹ "v1 is equal to v2" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "v1 is not equal to v2" ‹‹ endl;</code></p>
    <p><code> copy(v1.begin(), v1.end(), v2.begin());</code></p>
    <p><code> if (equal(v1.begin(), v1.end(), v2.begin())) cout ‹‹ "v1 is equal to v2" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "v1 is not equal to v2" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>equal0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers1[5] = {1, 2, 3, 4, 5};</code></p>
    <p><code>int numbers2[5] = {1, 2, 4, 8, 16};</code></p>
    <p><code>int numbers3[2] = {1, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> if (equal(numbers1, numbers1 + 5, numbers2)) </code></p>
    <p><code>  cout ‹‹ "numbers1 is equal to numbers2" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "numbers1 is not equal to numbers2" ‹‹ endl;</code></p>
    <p><code> if (equal(numbers3, numbers3 + 2, numbers1))</code></p>
    <p><code>  cout ‹‹ "numbers3 is equal to numbers1" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "numbers3 is not equal to numbers1" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>genern2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stdlib.h›</code></p>
    <empty-line/>
    <p><code>class Fibonacci {</code></p>
    <p><code>public:</code></p>
    <p><code> Fibonacci(): v1(0), v2(1) {}</code></p>
    <p><code> int operator() ();</code></p>
    <p><code>private:</code></p>
    <p><code> int v1;</code></p>
    <p><code> int v2;</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int Fibonacci::operator() () {</code></p>
    <p><code> int r = v1 + v2;</code></p>
    <p><code> v1 = v2;</code></p>
    <p><code> v2 = r;</code></p>
    <p><code> return v1;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> Fibonacci generator;</code></p>
    <p><code> generate_n(v1.begin(), v1.size(), generator);</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>gener2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stdlib.h›</code></p>
    <empty-line/>
    <p><code>class Fibonacci {</code></p>
    <p><code>public:</code></p>
    <p><code> Fibonacci(): v1(0), v2(1) {}</code></p>
    <p><code> int operator() ();</code></p>
    <p><code> private:</code></p>
    <p><code> int v1;</code></p>
    <p><code> int v2;</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int Fibonacci::operator() () {</code></p>
    <p><code> int r = v1 + v2;</code></p>
    <p><code> v1 = v2;</code></p>
    <p><code> v2 = r;</code></p>
    <p><code> return v1;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> Fibonacci generator;</code></p>
    <p><code> generate(v1.begin(), v1.end(), generator);</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>repcpif1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>bool odd(int a_) {</code></p>
    <p><code> return a_ % 2;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = i % 5;</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> vector‹int› v2(v1.size());</code></p>
    <p><code> replace_copy_if(v1.begin(), v1.end(), v2.begin(), odd, 42);</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setsymd.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int v1[3] = {13, 18, 23};</code></p>
    <p><code>int v2[4] = {10, 13, 17, 23};</code></p>
    <p><code>int result[4] = {0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> set_symmetric_difference(v1, v1 + 3, v2, v2 + 4, result);</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>deque1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> deque‹int› d;</code></p>
    <p><code> d.push_back(4); // Add after end.</code></p>
    <p><code> d.push_back(9);</code></p>
    <p><code> d.push_back(16);</code></p>
    <p><code> d.push_front(1); // Insert at beginning.</code></p>
    <p><code> for (int i = 0; i ‹ d.size(); i++) cout ‹‹ "d[" ‹‹ i ‹‹ "] = " ‹‹ d[i] ‹‹ endl;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> d.pop_front(); // Erase first element.</code></p>
    <p><code> d[2] = 25; // Replace last element.</code></p>
    <p><code> for (i = 0; i ‹ d.size(); i++)</code></p>
    <p><code> cout ‹‹ "d[" ‹‹ i ‹‹ "] = " ‹‹ d[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>findif1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>bool div_3(int a_) {</code></p>
    <p><code> return a_ % 3 ? 0 : 1;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> typedef vector‹int› IntVec;</code></p>
    <p><code> IntVec v(10);</code></p>
    <p><code> for (int i = 0; i ‹ v.size(); i++) v[i] = (i + 1) * (i + 1);</code></p>
    <p><code> IntVec::iterator iter;</code></p>
    <p><code> iter = find_if(v.begin(), v.end(), div_3);</code></p>
    <p><code> if (iter!= v.end())</code></p>
    <p><code>  cout ‹‹ "Value " ‹‹ *iter ‹‹ " at offset " ‹‹ (iter - v.begin()) ‹‹ " is divisible by 3" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ucompos1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹math.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>struct square_root: public unary_function‹double, double› {</code></p>
    <p><code> square_root() {}</code></p>
    <p><code> double operator() (double x_) const {return sqrt(x_);}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int input[3] = {-1, -4, -16};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int output[3];</code></p>
    <p><code> transform(input, input + 3, output, unary_compose‹square_root, negate‹int› ›(square_root(), negate‹int›()));</code></p>
    <p><code> for (int i = 0; i ‹ 3; i++) cout ‹‹ output[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rawiter.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>class X {</code></p>
    <p><code>public:</code></p>
    <p><code> X(int i_ = 0): i (i_) {}</code></p>
    <p><code> operator int() const {return i;}</code></p>
    <p><code>private:</code></p>
    <p><code> int i;</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> os_heap_allocator‹X› a;</code></p>
    <p><code> // Allocate (but do not construct) storage for 5 elements.</code></p>
    <p><code>  os_heap_allocator‹X›::pointer p = a.allocate(5);</code></p>
    <p><code> raw_storage_iterator‹X*, X› r(p);</code></p>
    <p><code> for (int i = 0; i ‹ 5; i++) *r++ = X(i);</code></p>
    <p><code> for (i = 0; i ‹ 5; i++) cout ‹‹ *p++ ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>set2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> set‹int, less‹int› › s;</code></p>
    <p><code> pair‹set‹int, less‹int› ›::const_iterator, bool› p;</code></p>
    <p><code> p = s.insert(42);</code></p>
    <p><code> if (p.second) cout ‹‹ "Inserted new element " ‹‹ *(p.first) ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "Existing element = " ‹‹ *(p.first) ‹‹ endl;</code></p>
    <p><code> p = s.insert(42);</code></p>
    <p><code> if (p.second) cout ‹‹ "Inserted new element " ‹‹ *(p.first) ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "Existing element = " ‹‹ *(p.first) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mset3.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[] = {3, 6, 1, 2, 3, 2, 6, 7, 9};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> multiset‹int, less‹int› › s(array, array + 9);</code></p>
    <p><code> multiset‹int, less‹int› ›::iterator i;</code></p>
    <p><code> // Return location of first element that is not less than 3</code></p>
    <p><code> i = s.lower_bound(3);</code></p>
    <p><code> cout ‹‹ "lower bound = " ‹‹ *i ‹‹ endl;</code></p>
    <p><code> // Return location of first element that is greater than 3</code></p>
    <p><code> i = s.upper_bound(3);</code></p>
    <p><code> cout ‹‹ "upper bound = " ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>binsrch2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) ‹  0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* labels[] = {"aa", "dd", "ff", "jj", "ss", "zz"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned count = sizeof(labels) / sizeof(labels[0]);</code></p>
    <p><code> if (binary_search(labels, labels + count, "ff", str_compare)) cout ‹‹ "ff is in labels." ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "ff is not in labels." ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>nthelem2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹stdlib.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = rand() % 10;</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> nth_element(v1.begin(), v1.begin() + v1.size() / 2, v1.end(), greater‹int›());</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setintr1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> vector‹int› v2(10);</code></p>
    <p><code> iota(v2.begin(), v2.end(), 7);</code></p>
    <p><code> ostream_iterator ‹int› iter(cout, " ");</code></p>
    <p><code> cout ‹‹ "v1: ";</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ "\nv2: ";</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setdiff1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> vector‹int› v2(10);</code></p>
    <p><code> iota(v2.begin(), v2.end(), 7);</code></p>
    <p><code> ostream_iterator ‹int› iter(cout, " ");</code></p>
    <p><code> cout ‹‹ "v1: ";</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ "\nv2: ";</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>adjdiff2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int mult(int a_, int b_) {</code></p>
    <p><code> return a_ * b_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(10);</code></p>
    <p><code> for (int i = 0; i ‹ v.size(); i++) v[i] = i + 1;</code></p>
    <p><code> vector‹int› rslt(v.size()); </code></p>
    <p><code> adjacent_difference(v.begin(), v.end(), rslt.begin(), mult);</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v.begin(), v.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> copy(rslt.begin(), rslt.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rotate1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) {</code></p>
    <p><code>  rotate(v1.begin(), v1.begin() + i, v1.end());</code></p>
    <p><code> ostream_iterator ‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code>}</code></p>
    <p><code>cout ‹‹ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setunon1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> vector‹int› v2(10);</code></p>
    <p><code> iota(v2.begin(), v2.end(), 7);</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> cout ‹‹ "v1: ";</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ "\nv2: ";</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>insert1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>char* array1[] = {"laurie", "jennifer", "leisa"};</code></p>
    <p><code>char* array2[] = {"amanda", "saskia", "carrie"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> deque‹char*› names(array1, array1 + 3);</code></p>
    <p><code> deque‹char*›::iterator i = names.begin() + 2;</code></p>
    <p><code> copy(array2, array2 + 3, insert_iterator‹deque ‹char*› ›(names, i));</code></p>
    <p><code> deque‹char*›::iterator j;</code></p>
    <p><code> for (j = names.begin(); j!= names.end(); j++) cout ‹‹ *j ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ucompos2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹math.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>struct square_root: public unary_function‹double, double› {</code></p>
    <p><code> square_root() {}</code></p>
    <p><code> double operator() (double x_) const {return sqrt(x_);}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int input[3] = {-1, -4, -16};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int output[3];</code></p>
    <p><code> transform(input, input + 3, output, compose1(square_root(), negate‹int›()));</code></p>
    <p><code> for (int i = 0; i ‹ 3; i++) cout ‹‹ output[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>parsrt1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹stdlib.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++)</code></p>
    <p><code> v1[i] = rand() % 10;</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> partial_sort(v1.begin(), v1.begin() + v1.size() / 2, v1.end());</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>equal2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>bool values_squared(int a_, int b_) {</code></p>
    <p><code> return (a_ * a_ == b_);</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> vector‹int› v2(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) {</code></p>
    <p><code>  v1[i] = i;</code></p>
    <p><code>  v2[i] = i * i;</code></p>
    <p><code> }</code></p>
    <p><code> if (equal(v1.begin(), v1.end(), v2.begin(), values_squared))</code></p>
    <p><code>  cout ‹‹ "v2[i] == v1[i] * v1[i]" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "v2[i] != v1[i] * v1[i]" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>inplmrg2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = (v1.size() - i - 1) % 5;</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> inplace_merge(v1.begin(), v1.begin() + 5, v1.end(), greater‹int›());</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>nthelem1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹stdlib.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = rand() % 10;</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> nth_element(v1.begin(), v1.begin() + v1.size() / 2, v1.end());</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec4.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(4);</code></p>
    <p><code> v[0] = 1;</code></p>
    <p><code> v[1] = 4;</code></p>
    <p><code> v[2] = 9;</code></p>
    <p><code> v[3] = 16;</code></p>
    <p><code> cout ‹‹ "front = " ‹‹ v.front() ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "back = " ‹‹ v.back() ‹‹ ", size = " ‹‹ v.size() ‹‹ endl;</code></p>
    <p><code> v.push_back(25);</code></p>
    <p><code> cout ‹‹ "back = " ‹‹ v.back() ‹‹ ", size = " ‹‹ v.size() ‹‹ endl;</code></p>
    <p><code> v.pop_back();</code></p>
    <p><code> cout ‹‹ "back = " ‹‹ v.back() ‹‹ ", size = " ‹‹ v.size() ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>lwrbnd2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool char_str_less(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) ‹ 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* str[] = {"a", "a", "b", "b", "q", "w", "z"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned strCt = sizeof(str)/sizeof(str[0]);</code></p>
    <p><code> cout ‹‹ "d can be inserted at index: "</code></p>
    <p><code>  ‹‹ (lower_bound(str, str + strCt, "d", char_str_less) - str) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pheap2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v;</code></p>
    <empty-line/>
    <p><code> v.push_back(1);</code></p>
    <p><code> v.push_back(20);</code></p>
    <p><code> v.push_back(4);</code></p>
    <p><code> make_heap(v.begin(), v.end(), greater‹int›());</code></p>
    <empty-line/>
    <p><code> v.push_back(7);</code></p>
    <p><code> push_heap(v.begin(), v.end(), greater‹int›());</code></p>
    <empty-line/>
    <p><code> sort_heap(v.begin(), v.end(), greater‹int›());</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v.begin(), v.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <empty-line/>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>insert2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>char* array1[] = {"laurie", "jennifer", "leisa"};</code></p>
    <p><code>char* array2[] = {"amanda", "saskia", "carrie"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> deque‹char*› names(array1, array1 + 3);</code></p>
    <p><code> deque‹char*›::iterator i = names.begin() + 2;</code></p>
    <p><code> copy(array2, array2 + 3, inserter(names, i));</code></p>
    <p><code> deque‹char*›::iterator j;</code></p>
    <p><code> for (j = names.begin(); j!= names.end(); j++) cout ‹‹ *j ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>} </code></p>
   </section>
   <section>
    <title>
     <p>uprbnd2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool char_str_less(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) ‹ 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* str[] = {"a", "a", "b", "b", "q", "w", "z"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned strCt = sizeof(str)/sizeof(str[0]);</code></p>
    <p><code> cout ‹‹ "d can be inserted at index: "</code></p>
    <p><code>  ‹‹ upper_bound(str, str + strCt, "d", char_str_less) - str ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec3.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹char› v1; // Empty vector of characters.</code></p>
    <p><code> v1.push_back('h');</code></p>
    <p><code> v1.push_back('i');</code></p>
    <p><code> cout ‹‹ "v1 = " ‹‹ v1[0] ‹‹ v1[1] ‹‹ endl;</code></p>
    <p><code> vector‹char› v2(v1);</code></p>
    <p><code> v2[1] = 'o'; // Replace second character.</code></p>
    <p><code> cout ‹‹ "v2 = " ‹‹ v2[0] ‹‹ v2[1] ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "(v1 == v2) = " ‹‹ (v1 == v2) ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "(v1 ‹ v2) = " ‹‹ (v1 ‹ v2) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iter4.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v; // Empty vector of integers.</code></p>
    <p><code> v.push_back(1);</code></p>
    <p><code> v.push_back(2);</code></p>
    <p><code> v.push_back(3);</code></p>
    <p><code> // Position immediately after last item.</code></p>
    <p><code> vector‹int›::iterator i = v.end();</code></p>
    <p><code> // Move back one and then access.</code></p>
    <p><code>  cout ‹‹ "last element is " ‹‹ *--i ‹‹ endl;</code></p>
    <p><code> i -= 2; // Jump back two items.</code></p>
    <p><code> cout ‹‹ "first element is " ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setdiff0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int v1[3] = {13, 18, 23};</code></p>
    <p><code>int v2[4] = {10, 13, 17, 23};</code></p>
    <p><code>int result[4] = {0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> set_difference(v1, v1 + 3, v2, v2 + 4, result);</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> set_difference(v2, v2 + 4, v1, v1 + 2, result);</code></p>
    <p><code> for (i = 0; i ‹ 4; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>lexcmp2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>const unsigned size = 6;</code></p>
    <p><code>char n1[size] = "shoe";</code></p>
    <p><code>char n2[size] = "shine";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> bool before = lexicographical_compare(n1, n1 + size, n2, n2 + size, greater‹char›());</code></p>
    <p><code> if (before) cout ‹‹ n1 ‹‹ " is after " ‹‹ n2 ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ n2 ‹‹ " is after " ‹‹ n1 ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>adjdiff1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(10);</code></p>
    <p><code> for (int i = 0; i ‹ v.size(); i++) v[i] = i * i;</code></p>
    <p><code> vector‹int› result(v.size());</code></p>
    <p><code> adjacent_difference(v.begin(), v.end(), result.begin());</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v.begin(), v.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> copy(result.begin(), result.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>stblptn1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹stdlib.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = rand() % 20;</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> stable_partition(v1.begin(), v1.end(), bind2nd(less‹int›(), 11));</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ptition1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹stdlib.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = rand() % 20;</code></p>
    <p><code> ostream_iterator ‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> partition(v1.begin(), v1.end(), bind2nd(less‹int›(), 11));</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1; // Empty vector of integers.</code></p>
    <p><code> cout ‹‹ "empty = " ‹‹ v1.empty() ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "size = " ‹‹ v1.size() ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "max_size = " ‹‹ v1.max_size() ‹‹ endl;</code></p>
    <p><code> v1.push_back(42); // Add an integer to the vector.</code></p>
    <p><code> cout ‹‹ "size = " ‹‹ v1.size() ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "v1[0] = " ‹‹ v1[0] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>sort2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 50, -10, 11, 42, 19};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int count = sizeof(array) / sizeof(array[0]);</code></p>
    <p><code> ostream_iterator ‹int› iter(cout, " ");</code></p>
    <p><code> cout ‹‹ "before: ";</code></p>
    <p><code> copy(array, array + count, iter);</code></p>
    <p><code> cout ‹‹ "\nafter: ";</code></p>
    <p><code> sort(array, array + count, greater‹int›());</code></p>
    <p><code> copy(array, array + count, iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>copy4.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> typedef vector‹int› IVec;</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int loc = 0; loc ‹ v1.size(); loc++) v1[loc] = loc;</code></p>
    <p><code> vector‹int› v2;</code></p>
    <p><code> insert_iterator‹IVec› i (v2, v2.begin());</code></p>
    <p><code> copy(v1.begin(), v1.end(), i);</code></p>
    <p><code> ostream_iterator‹int› outiter(cout, " ");</code></p>
    <p><code> copy(v2.begin(), v2.end(), outIter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>prevprm2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(3);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> for (int i = 0; i ‹ 9; i++) {</code></p>
    <p><code>  prev_permutation(v1.begin(), v1.end(), greater‹int›());</code></p>
    <p><code>  copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>  cout ‹‹ endl;</code></p>
    <p><code> }</code></p>
    <p><code>return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>trnsfrm2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>char map_char(char a_, int b_) {</code></p>
    <p><code> return char(a_ + b_);</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int trans[] = {-4, 4, -6, -6, -10, 0, 10, -6, 6, 0, -1, -77};</code></p>
    <p><code>char n[] = "Larry Mullen";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned count  = ::strlen(n);</code></p>
    <p><code> ostream_iterator ‹char› iter(cout);</code></p>
    <p><code> transform(n, n + count, trans, iter, map_char);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iter1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹const char*› v; // Vector of character strings.</code></p>
    <p><code> v.push_back((char*) "zippy"); // First element.</code></p>
    <p><code> v.push_back((char*) "motorboy"); // Second element.</code></p>
    <p><code> vector‹const char*›::iterator i = v.begin(); // Position at end.</code></p>
    <p><code> for (i = v.begin(); i != v.end(); i++) cout ‹‹ *i ‹‹ endl; // Display item.</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>maxelem2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) ‹ 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* names[] = {"Brett", "Graham", "Jack", "Mike", "Todd"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned namesCt = sizeof(names)/sizeof(names[0]);</code></p>
    <p><code> cout ‹‹ *max_element(names, names + namesCt, str_compare) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>minelem2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) ‹ 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* names[] = {"Brett", "Graham", "Jack", "Mike", "Todd"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned namesCt = sizeof(names)/sizeof(names[0]);</code></p>
    <p><code> cout ‹‹ *min_element(names, names + namesCt, str_compare) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>partsum2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(5);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 1);</code></p>
    <p><code> vector‹int› v2(v1.size());</code></p>
    <p><code> partial_sum(v1.begin(), v1.end(), v2.begin(), times‹int›());</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>istmit1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> char buffer[100];</code></p>
    <p><code> int i = 0;</code></p>
    <p><code> cin.unsetf(ios::skipws); // Disable white-space skipping.</code></p>
    <p><code> cout ‹‹ "Please enter a string: ";</code></p>
    <p><code> istream_iterator‹char, ptrdiff_t› s(cin);</code></p>
    <p><code> while (*s!= '\n') buffer[i++] = *s++;</code></p>
    <p><code> buffer[i] = '\0'; // Null terminate buffer.</code></p>
    <p><code> cout ‹‹ "read " ‹‹ buffer ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>findif0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>bool odd(int a_) {</code></p>
    <p><code> return a_ % 2;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {2, 4, 8, 15, 32, 64};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int* location = find_if(numbers, numbers + 6, odd);</code></p>
    <p><code> if (location != numbers + 6)</code></p>
    <p><code>  cout ‹‹ "Value " ‹‹ *location ‹‹ " at offset " ‹‹ (location - numbers) ‹‹ " is odd" ‹‹ endl; </code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pheap1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v;</code></p>
    <empty-line/>
    <p><code> v.push_back(1);</code></p>
    <p><code> v.push_back(20);</code></p>
    <p><code> v.push_back(4);</code></p>
    <p><code> make_heap(v.begin(), v.end());</code></p>
    <empty-line/>
    <p><code> v.push_back(7);</code></p>
    <p><code> push_heap(v.begin(), v.end());</code></p>
    <empty-line/>
    <p><code> sort_heap(v.begin(), v.end());</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v.begin(), v.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <empty-line/>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>stblsrt2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool string_less(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) ‹ 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>char* letters[6] = {"bb", "aa", "ll", "dd", "qq", "cc"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> stable_sort(letters, letters + 6, string_less);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ letters[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>nextprm1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(3);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> for (int i = 0; i ‹ 9; i++) {</code></p>
    <p><code>  next_permutation(v1.begin(), v1.end());</code></p>
    <p><code>  copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>  cout ‹‹ endl;</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>prevprm1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(3);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> for (int i = 0; i ‹ 9; i++) {</code></p>
    <p><code>  prev_permutation(v1.begin(), v1.end());</code></p>
    <p><code>  copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>  cout ‹‹ endl;</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rndshuf1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> for (int i = 0; i ‹ 3; i++) {</code></p>
    <p><code>  random_shuffle(v1.begin(), v1.end());</code></p>
    <p><code>  copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code>  cout ‹‹ endl;</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ptrbinf1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int sum(int x_, int y_) {</code></p>
    <p><code> return x_ + y_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int input1[4] = {7, 2, 3, 5};</code></p>
    <p><code>int input2[4] = {1, 5, 5, 8};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int output[4];</code></p>
    <p><code> transform(input1, input1 + 4, input2, output, pointer_to_binary_function‹int, int, int›(sum));</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ output[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iter2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>void print (const vector‹const char*›&amp; v_) {</code></p>
    <p><code> vector‹const char*›::const_iterator i;</code></p>
    <p><code> for (i = v_.begin(); i != v_.end(); i++) cout ‹‹ *i ‹‹ endl;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹const char*› v; // Vector of character strings.</code></p>
    <p><code> v.push_back((char*) "zippy");</code></p>
    <p><code> v.push_back((char*) "motorboy");</code></p>
    <p><code> print (v);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>partsum1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> vector‹int› v2(v1.size());</code></p>
    <p><code> partial_sum(v1.begin(), v1.end(), v2.begin());</code></p>
    <p><code> ostream_iterator ‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>replif1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>bool odd(int a_) {</code></p>
    <p><code> return a_ % 2;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) {</code></p>
    <p><code>  v1[i] = i % 5;</code></p>
    <p><code>  cout ‹‹ v1[i] ‹‹ ' ';</code></p>
    <p><code> }</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> replace_if(v1.begin(), v1.end(), odd, 42);</code></p>
    <p><code> for (i = 0; i ‹ v1.size(); i++) cout ‹‹ v1[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mset4.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[] = {3, 6, 1, 2, 3, 2, 6, 7, 9};</code></p>
    <empty-line/>
    <p><code>int main() </code><code>{</code></p>
    <p><code> typedef multiset‹int, less‹int› › mset;</code></p>
    <p><code> mset s(array, array + 9);</code></p>
    <p><code> pair‹mset::const_iterator, mset::const_iterator› p = s.equal_range(3);</code></p>
    <p><code> cout ‹‹ "lower bound = " ‹‹ *(p.first) ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "upper bound = " ‹‹ *(p.second) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iter3.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹const char*› v; // Vector of character strings.</code></p>
    <p><code> v.push_back((char*) "zippy"); // First element.</code></p>
    <p><code> v.push_back((char*) "motorboy"); // Second element.</code></p>
    <p><code> vector‹const char*›::reverse_iterator i;</code></p>
    <p><code> for (i = v.rbegin(); i!= v.rend(); i++) cout ‹‹ *i ‹‹ endl; // Display item.</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>list2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array1[] = {1, 16};</code></p>
    <p><code>int array2[] = {4, 9};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> list‹int› l1(array1, array1 + 2);</code></p>
    <p><code> list‹int› l2(array2, array2 + 2);</code></p>
    <p><code> list‹int›::iterator i = l1.begin();</code></p>
    <p><code> i++;</code></p>
    <p><code> l1.splice(i, l2, l2.begin(), l2.end());</code></p>
    <p><code> i = l1.begin();</code></p>
    <p><code> while (i != l1.end()) cout ‹‹ *i++ ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>set1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> set‹int, less‹int› › s;</code></p>
    <p><code> cout ‹‹ "count(42) = " ‹‹ s.count(42) ‹‹ endl;</code></p>
    <p><code> s.insert(42);</code></p>
    <p><code> cout ‹‹ "count(42) = " ‹‹ s.count(42) ‹‹ endl;</code></p>
    <p><code> s.insert(42);</code></p>
    <p><code> cout ‹‹ "count(42) = " ‹‹ s.count(42) ‹‹ endl;</code></p>
    <p><code> int count = s.erase(42);</code></p>
    <p><code> cout ‹‹ count ‹‹ " elements erased" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>list1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array1[] = {9, 16, 36};</code></p>
    <p><code>int array2[] = {1, 4};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> list‹int› l1(array1, array1 + 3);</code></p>
    <p><code> list‹int› l2(array2, array2 + 2);</code></p>
    <p><code> list‹int›::iterator i1 = l1.begin();</code></p>
    <p><code> l1.splice(i1, l2);</code></p>
    <p><code> list‹int›::iterator i2 = l1.begin();</code></p>
    <p><code> while (i2!= l1.end()) cout ‹‹ *i2++ ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>alg5.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> list‹int› years;</code></p>
    <p><code> years.push_back(1962);</code></p>
    <p><code> years.push_back(1992);</code></p>
    <p><code> years.push_back(2001);</code></p>
    <p><code> years.push_back(1999);</code></p>
    <p><code> sort(years.begin(), years.end()); // Causes linker error.</code></p>
    <p><code> list‹int›::iterator i;</code></p>
    <p><code> for (i = years.begin(); i != years.end(); i++) cout ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>eqlrnge0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[10] = {0, 0, 1, 1, 2, 2, 2, 2, 3, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> pair ‹int*, int*› range;</code></p>
    <p><code> range = equal_range(numbers, numbers + 10, 2);</code></p>
    <p><code> cout ‹‹ "2 can be inserted from before index " ‹‹ (range.first - numbers)</code></p>
    <p><code>  ‹‹ " to before index " ‹‹ (range.second - numbers) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>advance.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> typedef vector‹int› IntVector;</code></p>
    <p><code> IntVector v(10);</code></p>
    <p><code> for (int i = 0; i ‹ v.size(); i++) v[i] = i;</code></p>
    <p><code> IntVector::iterator location = v.begin();</code></p>
    <p><code> cout ‹‹ "At Beginning: " ‹‹ *location ‹‹ endl;</code></p>
    <p><code> advance(location, 5);</code></p>
    <p><code> cout ‹‹ "At Beginning + 5: " ‹‹ *location ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>replace1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = i % 5;</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> replace(v1.begin(), v1.end(), 2, 42);</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>alg3.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› i;</code></p>
    <p><code> i.push_back(1);</code></p>
    <p><code> i.push_back(4);</code></p>
    <p><code> i.push_back(2);</code></p>
    <p><code> i.push_back(8);</code></p>
    <p><code> i.push_back(2);</code></p>
    <p><code> i.push_back(2);</code></p>
    <p><code> int n = 0; // Must be initialized, as count increments n.</code></p>
    <p><code> count(i.begin(), i.end(), 2, n);</code></p>
    <p><code> cout ‹‹ "Count of 2s = " ‹‹ n ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>func2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>bool bigger_than(int x_, int y_) {</code></p>
    <p><code> return x_ › y_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int›v;</code></p>
    <p><code> v.push_back(4);</code></p>
    <p><code> v.push_back(1);</code></p>
    <p><code> v.push_back(5);</code></p>
    <p><code> sort(v.begin(), v.end(), bigger_than);</code></p>
    <p><code> vector‹int›::iterator i;</code></p>
    <p><code> for (i = v.begin(); i != v.end(); i++) cout ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>unegate1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>struct odd: public unary_function‹int, bool› {</code></p>
    <p><code> odd() {}</code></p>
    <p><code> bool operator() (int n_) const {return (n_ % 2) - 1;}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int* p = find_if(array, array + 3, unary_negate‹odd›(odd()));</code></p>
    <p><code> if (p != array + 3)</code></p>
    <p><code> cout ‹‹ *p ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>alg4.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› years;</code></p>
    <p><code> years.push_back(1962);</code></p>
    <p><code> years.push_back(1992);</code></p>
    <p><code> years.push_back(2001);</code></p>
    <p><code> years.push_back(1999);</code></p>
    <p><code> sort(years.begin(), years.end());</code></p>
    <p><code> vector‹int›::iterator i;</code></p>
    <p><code> for (i = years.begin(); i!= years.end(); i++)</code></p>
    <p><code> cout ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>countif1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int odd(int a_) {</code></p>
    <p><code> return a_ % 2;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› numbers(100);</code></p>
    <p><code> for (int i = 0; i ‹ 100; i++) numbers[i] = i % 3;</code></p>
    <p><code> int elements = 0;</code></p>
    <p><code> count_if(numbers.begin(), numbers.end(), odd, elements);</code></p>
    <p><code> cout ‹‹ "Found " ‹‹ elements ‹‹ " odd elements." ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>lwrbnd1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(20);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) {</code></p>
    <p><code>  v1[i] = i/4;</code></p>
    <p><code>  cout ‹‹ v1[i] ‹‹ ' ';</code></p>
    <p><code> }</code></p>
    <p><code> int* location = lower_bound(v1.begin(), v1.end(), 3);</code></p>
    <p><code> cout ‹‹ "\n3 can be inserted at index: " ‹‹ (location - v1.begin()) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>lexcmp1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>const unsigned size = 6;</code></p>
    <p><code>char n1[size] = "shoe";</code></p>
    <p><code>char n2[size] = "shine";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> bool before = lexicographical_compare(n1, n1 + size, n2, n2 + size);</code></p>
    <p><code> if (before) cout ‹‹ n1 ‹‹ " is before " ‹‹ n2 ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ n2 ‹‹ " is before " ‹‹ n1 ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>copyb.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = i;</code></p>
    <p><code> vector‹int› v2(v1.size());</code></p>
    <p><code> copy_backward(v1.begin(), v1.end(), v2.end());</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ptrbinf2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int sum(int x_, int y_) {</code></p>
    <p><code> return x_ + y_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int input1[4] = {7, 2, 3, 5};</code></p>
    <p><code>int input2[4] = {1, 5, 5, 8};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int output[4];</code></p>
    <p><code> transform(input1, input1 + 4, input2, output, ptr_fun(sum));</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ output[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>copyb0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[5] = {1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int result[5];</code></p>
    <p><code> copy_backward(numbers, numbers + 5, result + 5);</code></p>
    <p><code> for (int i = 0; i ‹ 5; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> for (i = 0; i ‹ 5; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>binsert1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>char* array[] = {"laurie", "jennifer", "leisa"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹char*› names;</code></p>
    <p><code> copy(array, array + 3, back_insert_iterator‹vector‹char*› ›(names));</code></p>
    <p><code> vector‹char*›::iterator i;</code></p>
    <p><code> for (i = names.begin(); i!= names.end(); i++) cout ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>unegate2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>struct odd: public unary_function‹int, bool› {</code></p>
    <p><code> odd() {}</code></p>
    <p><code> bool operator() (int n_) const {return (n_ % 2) - 1;}</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int* p = find_if(array, array + 3, not1 (odd()));</code></p>
    <p><code> if (p != array + 3) cout ‹‹ *p ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>revcopy1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int result[6];</code></p>
    <p><code> reverse_copy(numbers, numbers + 6, result);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> for (i = 0; i ‹ 6; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>finsert1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>char* array[] = {"laurie", "jennifer", "leisa"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> deque‹char*› names;</code></p>
    <p><code> copy(array, array + 3, front_insert_iterator‹deque ‹char*› ›(names));</code></p>
    <p><code> deque‹char*›::iterator i;</code></p>
    <p><code> for (i = names.begin(); i!= names.end(); i++) cout ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>remcpif1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>bool odd(int a_) {</code></p>
    <p><code> return a_ % 2;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {1, 2, 3, 1, 2, 3};</code></p>
    <p><code>int result[6] = {0, 0, 0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> remove_copy_if(numbers, numbers + 6, result, odd);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>inplmrg1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {1, 10, 42, 3, 16, 32};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> inplace_merge(numbers, numbers + 3, numbers + 6);</code></p>
    <p><code> for (i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>list4.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array1[] = {1, 3, 6, 7};</code></p>
    <p><code>int array2[] = {2, 4};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> list‹int› l1(array1, array1 + 4);</code></p>
    <p><code> list‹int› l2(array2, array2 + 2);</code></p>
    <p><code> l1.merge(l2);</code></p>
    <p><code> for (list‹int›::iterator i = l1.begin(); i != l1.end(); i++) cout ‹‹ *i;</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>revbit1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 5, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> list‹int› v(array, array + 4);</code></p>
    <p><code> reverse_bidirectional_iterator‹list‹int›::iterator, int, list‹int›::reference, list‹int›::difference_type› r(v.end());</code></p>
    <p><code> while (r != v.begin())</code></p>
    <p><code> cout ‹‹ *r++ ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>copy3.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = i;</code></p>
    <p><code> vector‹int› v2(10);</code></p>
    <p><code> copy(v1.begin(), v1.end(), v2.begin());</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v2.begin(), v2.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>merge0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers1[5] = {1, 6, 13, 25, 101};</code></p>
    <p><code>int numbers2[5] = {-5, 26, 36, 46, 99};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int result[10];</code></p>
    <p><code> merge(numbers1, numbers1 + 5, numbers2, numbers2 + 5, result);</code></p>
    <p><code> for (int i = 0; i ‹ 10; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>reviter1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 5, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(array, array + 4);</code></p>
    <p><code> stl_reverse_iterator‹vector‹int›::iterator, int, vector‹int›::reference, vector‹int›::difference_type› r (v.end());</code></p>
    <p><code> while (r!= v.begin()) cout ‹‹ *r++ ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>find1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int years[] = {1942, 1952, 1962, 1972, 1982, 1992};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> const unsigned yearCount = sizeof(years) / sizeof(years[0]);</code></p>
    <p><code> int* location = find(years, years + yearCount, 1972);</code></p>
    <p><code> cout ‹‹ "Found 1972 at offset " ‹‹ (location - years) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>trnsfrm1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int negate_int(int a_) {</code></p>
    <p><code> return -a_;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {-5, -1, 0, 1, 6, 11};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int result[6];</code></p>
    <p><code> transform(numbers, numbers + 6, result, negate_int);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>binsert2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>char* array[] = {"laurie", "jennifer", "leisa"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹char*› names;</code></p>
    <p><code> copy(array, array + 3, back_inserter(names));</code></p>
    <p><code> vector‹char*›::iterator i;</code></p>
    <p><code> for (i = names.begin(); i!= names.end(); i++) cout ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>finsert2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>char* array[] = {"laurie", "jennifer", "leisa"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> deque‹char*› names;</code></p>
    <p><code> copy(array, array + 3, front_inserter(names));</code></p>
    <p><code> deque‹char*›::iterator i;</code></p>
    <p><code> for (i = names.begin(); i!= names.end(); i++) cout ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mset2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>char* names[] = {"dave", "alf", "chas", "bob", "ed", "chas"};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> typedef multiset‹char*, less_s› mset;</code></p>
    <p><code> mset s;</code></p>
    <p><code> s.insert(names, names + 6);</code></p>
    <p><code> for (mset::iterator i = s.begin(); i!= s.end(); i++) cout ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ostmit.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 5, 2, 4};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> char* string = "hello";</code></p>
    <p><code> ostream_iterator‹char› it1(cout);</code></p>
    <p><code> copy(string, string + 5, it1);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> ostream_iterator‹int› it2(cout);</code></p>
    <p><code> copy(array, array + 4, it2);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ptrunf1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>bool even(int n_) {</code></p>
    <p><code> return (n_ % 2) == 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int* p = find_if(array, array + 3, pointer_to_unary_function‹int, bool›(even));</code></p>
    <p><code> if (p != array + 3) cout ‹‹ *p ‹‹ " is even" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>func1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>bool bigger(int i_) {</code></p>
    <p><code> return i_ › 3;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v;</code></p>
    <p><code> v.push_back(4);</code></p>
    <p><code> v.push_back(1);</code></p>
    <p><code> v.push_back(5);</code></p>
    <p><code> int n = 0;</code></p>
    <p><code> count_if(v.begin(), v.end(), bigger, n);</code></p>
    <p><code> cout ‹‹ "Number greater than 3 = " ‹‹ n ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>stblptn0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>bool less_10(int a_) {</code></p>
    <p><code> return a_ ‹ 10 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {10, 5, 11, 20, 6, -2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> stable_partition(numbers, numbers + 6, less_10);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setunon0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int v1[3] = {13, 18, 23};</code></p>
    <p><code>int v2[4] = {10, 13, 17, 23};</code></p>
    <p><code>int result[7] = {0, 0, 0, 0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> set_union(v1, v1 + 3, v2, v2 + 4, result);</code></p>
    <p><code> for (int i = 0; i ‹ 7; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mkheap1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {5, 10, 4, 13, 11, 19};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> make_heap(numbers, numbers + 6, greater‹int›());</code></p>
    <p><code> for (int i = 6; i ›= 1; i--) {</code></p>
    <p><code>  cout ‹‹ numbers[0] ‹‹ endl;</code></p>
    <p><code>  pop_heap(numbers, numbers + i, greater‹int›());</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>setintr0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int v1[3] = {13, 18, 23};</code></p>
    <p><code>int v2[4] = {10, 13, 17, 23};</code></p>
    <p><code>int result[4] = {0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> set_intersection(v1, v1 + 3, v2, v2 + 4, result);</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>logicand.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>bool input1[4] = {1, 1, 0, 1};</code></p>
    <p><code>bool input2[4] = {0, 1, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int output[4];</code></p>
    <p><code> transform(input1, input1 + 4, input2, output, logical_and‹bool›());</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ output[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>logicor.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>bool input1[4] = {1, 1, 0, 1};</code></p>
    <p><code>bool input2[4] = {0, 1, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int output[4];</code></p>
    <p><code> transform(input1, input1 + 4, input2, output, logical_or‹bool›());</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ output[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>nequal.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int input1[4] = {1, 7, 2, 2};</code></p>
    <p><code>int input2[4] = {1, 6, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int output[4];</code></p>
    <p><code> transform(input1, input1 + 4, input2, output, not_equal_to‹int›());</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ output[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ptition0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int less_10(int a_) {</code></p>
    <p><code> return a_ ‹ 10 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {6, 12, 3, 10, 1, 20};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> partition(numbers, numbers + 6, less_10);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>inrprod0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>int vector1[5] = {1, 2, 3, 4, 5};</code></p>
    <p><code>int vector2[5] = {1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int result;</code></p>
    <p><code> result = inner_product(vector1, vector1 + 5, vector2, 0);</code></p>
    <p><code> cout ‹‹ "Inner product = " ‹‹ result ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>func3.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int›v;</code></p>
    <p><code> v.push_back(4);</code></p>
    <p><code> v.push_back(1);</code></p>
    <p><code> v.push_back(5);</code></p>
    <p><code> sort(v.begin(), v.end(), greater‹int›());</code></p>
    <p><code> vector‹int›::iterator i;</code></p>
    <p><code> for (i = v.begin(); i != v.end(); i++)  cout ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>modulus.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int input1[4] = {6, 8, 10, 2};</code></p>
    <p><code>int input2[4] = {4, 2, 11, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int output[4];</code></p>
    <p><code> transform(input1, input1 + 4, input2, output, modulus‹int›());</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ output[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>uprbnd1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int array[20];</code></p>
    <p><code> for (int i = 0; i ‹ 20; i++) {</code></p>
    <p><code>  array[i] = i/4;</code></p>
    <p><code>  cout ‹‹ array[i] ‹‹ ' ';</code></p>
    <p><code> }</code></p>
    <p><code> cout ‹‹ "\n3 can be inserted at index: "</code></p>
    <p><code>  ‹‹ upper_bound(array, array + 20, 3) - array ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>equalto.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int input1[4] = {1, 7, 2, 2};</code></p>
    <p><code>int input2[4] = {1, 6, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int output[4];</code></p>
    <p><code> transform(input1, input1 + 4, input2, output, equal_to‹int›());</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ output[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>count1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› numbers(100);</code></p>
    <p><code> for (int i = 0; i ‹ 100; i++) numbers[i] = i % 3;</code></p>
    <p><code> int elements = 0;</code></p>
    <p><code> count(numbers.begin(), numbers.end(), 2, elements);</code></p>
    <p><code> cout ‹‹ "Found " ‹‹ elements ‹‹ " 2's." ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>uniqcpy1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[8] = {0, 1, 1, 2, 2, 2, 3, 4};</code></p>
    <p><code>int result[8] = {0, 0, 0, 0, 0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> unique_copy(numbers, numbers + 8, result);</code></p>
    <p><code> for (int i = 0; i ‹ 8; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>minus.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int input1[4] = {1, 5, 7, 8};</code></p>
    <p><code>int input2[4] = {1, 4, 8, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int output[4];</code></p>
    <p><code> transform(input1, input1 + 4, input2, output, minus‹int›());</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ output[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>replcpy1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 0, 1, 2};</code></p>
    <p><code>int result[6] = {0, 0, 0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> replace_copy(numbers, numbers + 6, result, 2, 42);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>swprnge1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> char* word1 = "World";</code></p>
    <p><code> char* word2 = "Hello";</code></p>
    <p><code> cout ‹‹ word1 ‹‹ " " ‹‹ word2 ‹‹ endl;</code></p>
    <p><code> swap_ranges(word1, word1 + ::strlen(word1), word2);</code></p>
    <p><code> cout ‹‹ word1 ‹‹ " " ‹‹ word2 ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec8.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v;</code></p>
    <p><code> cout ‹‹ "capacity = " ‹‹ v.capacity() ‹‹ endl;</code></p>
    <p><code> v.push_back(42);</code></p>
    <p><code> cout ‹‹ "capacity = " ‹‹ v.capacity() ‹‹ endl;</code></p>
    <p><code> v.reserve (5000);</code></p>
    <p><code> cout ‹‹ "capacity = " ‹‹ v.capacity() ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>plus.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int input1[4] = {1, 6, 11, 8};</code></p>
    <p><code>int input2[4] = {1, 5, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int total = inner_product(input1, input1 + 4, input2, 0, plus‹int›(), times‹int›());</code></p>
    <p><code> cout ‹‹ "total = " ‹‹ total ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>remcopy1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {1, 2, 3, 1, 2, 3};</code></p>
    <p><code>int result[6] = {0, 0, 0, 0, 0, 0};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> remove_copy(numbers, numbers + 6, result, 2);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>error2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>// Compile this code with the symbol OS_USE_EXCEPTIONS defined.</code></p>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v;</code></p>
    <p><code> try {</code></p>
    <p><code>  v.pop_back(); // Generates an exception.</code></p>
    <p><code> } catch (const char* str) {</code></p>
    <p><code>  cout ‹‹ "Caught exception " ‹‹ str ‹‹ endl;</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iterswp1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(6);</code></p>
    <p><code> iota(v1.begin(), v1.end(), 0);</code></p>
    <p><code> iter_swap(v1.begin(), v1.begin() + 3);</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v1.begin(), v1.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>remif1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>bool odd(int a_) {</code></p>
    <p><code> return a_ % 2;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 0, 1, 1, 2, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> remove_if(numbers, numbers + 6, odd);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++)</code></p>
    <p><code> cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>foreach1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>void print_sqr(int a_) {</code></p>
    <p><code> cout ‹‹ a_ * a_ ‹‹ " ";</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> for (int i = 0; i ‹ v1.size(); i++) v1[i] = i;</code></p>
    <p><code> for_each(v1.begin(), v1.end(), print_sqr);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>parsrtc0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {5, 2, 4, 3, 1, 6};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int result[3];</code></p>
    <p><code> partial_sort_copy(numbers, numbers + 6, result, result + 3);</code></p>
    <p><code> for (int i = 0; i ‹ 3; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pqueue2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> priority_queue‹deque‹char*›, greater_s› q;</code></p>
    <p><code> q.push((char*) "cat");</code></p>
    <p><code> q.push((char*) "dog");</code></p>
    <p><code> q.push((char*) "ape");</code></p>
    <p><code> while (!q.empty()) {</code></p>
    <p><code>  cout ‹‹ q.top() ‹‹ endl;</code></p>
    <p><code>  q.pop();</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>binsrch1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int vector[100];</code></p>
    <p><code> for (int i = 0; i ‹ 100; i++) vector[i] = i;</code></p>
    <p><code> if (binary_search(vector, vector + 100, 42)) cout ‹‹ "found 42" ‹‹ endl;</code></p>
    <p><code> else cout ‹‹ "did not find 42" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>ptrunf2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>bool even(int n_) {</code></p>
    <p><code> return (n_ % 2) == 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int* p = find_if(array, array + 3, ptr_fun(even));</code></p>
    <p><code> if (p != array + 3) cout ‹‹ *p ‹‹ " is even" ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rotcopy0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int result[6];</code></p>
    <p><code> rotate_copy(numbers, numbers + 3, numbers + 6, result);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>mkheap0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {5, 10, 4, 13, 11, 19};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> make_heap(numbers, numbers + 6);</code></p>
    <p><code> for (int i = 6; i ›= 1; i--) {</code></p>
    <p><code>  cout ‹‹ numbers[0] ‹‹ endl;</code></p>
    <p><code>  pop_heap(numbers, numbers + i);</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>copy1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>char string[23] = "A string to be copied.";</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> char result[23];</code></p>
    <p><code> copy(string, string + 23, result);</code></p>
    <p><code> cout ‹‹ " Src: " ‹‹ string ‹‹ "\nDest: " ‹‹ result ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>find0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[10] = {0, 1, 4, 9, 16, 25, 36, 49, 64};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int* location;</code></p>
    <p><code> location = find(numbers, numbers + 10, 25);</code></p>
    <p><code> cout ‹‹ "Found 25 at offset " ‹‹ (location - numbers) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>partsum0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {1, 2, 3, 4, 5, 6};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int result[6];</code></p>
    <p><code> partial_sum(numbers, numbers + 6, result);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i ++) cout ‹‹ result[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bvec1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> bit_vector b(3);</code></p>
    <p><code> for (int i = 0; i ‹ b.size(); i++) cout ‹‹ b[i];</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> b[0] = b[2] = 1;</code></p>
    <p><code> for (i = 0; i ‹ b.size(); i++) cout ‹‹ b[i];</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bind2nd1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> replace_if(array, array + 3, binder2nd‹greater‹int› ›(greater‹int›(), 2), 4);</code></p>
    <p><code> for (int i = 0; i ‹ 3; i++) cout ‹‹ array[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bind1st1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int* p = remove_if(array, array + 3, binder1st‹less‹int› ›(less‹int›(), 2));</code></p>
    <p><code> for (int* i = array; i != p; i++) cout ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>reviter2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 5, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(array, array + 4);</code></p>
    <p><code> vector‹int›::reverse_iterator r;</code></p>
    <p><code> for (r = v.rbegin(); r != v.rend(); r++) cout ‹‹ *r ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>copy2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(10);</code></p>
    <p><code> for (int i = 0; i ‹ v.size(); i++) v[i] = i;</code></p>
    <p><code> ostream_iterator‹int› iter(cout, " ");</code></p>
    <p><code> copy(v.begin(), v.end(), iter);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>max2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) ‹ 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> cout ‹‹ max("shoe", "shine", str_compare) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>min2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>bool str_compare(const char* a_, const char* b_) {</code></p>
    <p><code> return ::strcmp(a_, b_) ‹ 0 ? 1 : 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> cout ‹‹ min("shoe", "shine", str_compare) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>parsrt0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {5, 2, 4, 3, 1, 6};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> partial_sort(numbers, numbers + 3, numbers + 6);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>partsrt0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {5, 2, 4, 3, 1, 6};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> partial_sort(numbers, numbers + 3, numbers + 6);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bnegate1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[4] = {4, 9, 7, 1};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> sort(array, array + 4, binary_negate‹greater‹int› ›(greater‹int›()));</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ array[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>nthelem0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {5, 2, 4, 1, 0, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> nth_element(numbers, numbers + 3, numbers + 6);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>revbit2.cpp</p>
    </title>
    <empty-line/>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 5, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> list‹int› v(array, array + 4);</code></p>
    <p><code> list‹int›::reverse_iterator r;</code></p>
    <p><code> for (r = v.rbegin(); r != v.rend(); r++) cout ‹‹ *r ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>count0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[10] = {1, 2, 4, 1, 2, 4, 1, 2, 4, 1};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int result = 0;</code></p>
    <p><code> count(numbers, numbers + 10, 1, result);</code></p>
    <p><code> cout ‹‹ "Found " ‹‹ result ‹‹ " 1's." ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>negate.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int input[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int output[3];</code></p>
    <p><code> transform(input, input + 3, output, negate‹int›());</code></p>
    <p><code> for (int i = 0; i ‹ 3; i++) cout ‹‹ output[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pqueue1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> priority_queue‹deque‹int›, less‹int› › q;</code></p>
    <p><code> q.push(42);</code></p>
    <p><code> q.push(101);</code></p>
    <p><code> q.push(69);</code></p>
    <p><code> while (!q.empty()) {</code></p>
    <p><code>  cout ‹‹ q.top() ‹‹ endl;</code></p>
    <p><code>  q.pop();</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>genern1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stdlib.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v1(10);</code></p>
    <p><code> generate_n(v1.begin(), v1.size(), rand);</code></p>
    <p><code> for (int i = 0; i ‹ 10; i++) cout ‹‹ v1[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rotate0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> rotate(numbers, numbers + 3, numbers + 6);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>foreach0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>void print(int a_) {</code></p>
    <p><code> cout ‹‹ a_ ‹‹ ' ';</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int numbers[10] = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> for_each(numbers, numbers + 10, print);</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>alg2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int i[] = {1, 4, 2, 8, 2, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int n = 0; // Must be initialized, as count increments n.</code></p>
    <p><code> count(i, i + 6, 2, n);</code></p>
    <p><code> cout ‹‹ "Count of 2s = " ‹‹ n ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>gener1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stdlib.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int numbers[10];</code></p>
    <p><code> generate(numbers, numbers + 10, rand);</code></p>
    <p><code> for (int i = 0; i ‹ 10; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>replace0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 0, 1, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> replace(numbers, numbers + 6, 2, 42);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>rndshuf0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {1, 2, 3, 4, 5, 6};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> random_shuffle(numbers, numbers + 6);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bind1st2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int* p = remove_if(array, array + 3, bind1st(less‹int›(), 2));</code></p>
    <p><code> for (int* i = array; i != p; i++) cout ‹‹ *i ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>unique1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[8] = {0, 1, 1, 2, 2, 2, 3, 4};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> unique(numbers, numbers + 8);</code></p>
    <p><code> for (int i = 0; i ‹ 8; i ++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bind2nd2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[3] = {1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> replace_if(array, array + 3, bind2nd(greater‹int (), 2), 4);</code></p>
    <p><code> for (int i = 0; i ‹ 3; i++) cout ‹‹ array[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>vec5.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[] = {1, 4, 9, 16};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(array, array + 4);</code></p>
    <p><code> for (int i = 0; i ‹ v.size(); i++) cout ‹‹ "v[" ‹‹ i ‹‹ "] = " ‹‹ v[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iterswp0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> iter_swap(numbers, numbers + 3);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>remove1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {1, 2, 3, 1, 2, 3};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> remove(numbers, numbers + 6, 1);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>stblsrt1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int array[6] = {1, 50, -10, 11, 42, 19};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> stable_sort(array, array + 6);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ array[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>reverse1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {0, 1, 2, 3, 4, 5};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> reverse(numbers, numbers + 6);</code></p>
    <p><code> for (int i = 0; i ‹ 6; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>logicnot.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>bool input[7] = {1, 0, 0, 1, 1, 1, 1};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int n = 0;</code></p>
    <p><code> count_if(input, input + 7, logical_not‹bool›(), n);</code></p>
    <p><code> cout ‹‹ "count = " ‹‹ n ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>bnegate2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[4] = {4, 9, 7, 1};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> sort(array, array + 4, not2(greater‹int›()));</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ array[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>queue1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> queue‹list‹int› › q;</code></p>
    <p><code> q.push(42);</code></p>
    <p><code> q.push(101);</code></p>
    <p><code> q.push(69);</code></p>
    <p><code> while (!q.empty()) {</code></p>
    <p><code>  cout ‹‹ q.front() ‹‹ endl;</code></p>
    <p><code>  q.pop();</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>stack1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> stack‹deque‹int› › s;</code></p>
    <p><code> s.push(42);</code></p>
    <p><code> s.push(101);</code></p>
    <p><code> s.push(69);</code></p>
    <p><code> while (!s.empty()) {</code></p>
    <p><code>  cout ‹‹ s.top() ‹‹ endl;</code></p>
    <p><code>  s.pop();</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>greateq.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[4] = {3, 1, 4, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> sort(array, array + 4, greater_equal‹int›());</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ array[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>stack2.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> stack‹list‹int› › s;</code></p>
    <p><code> s.push(42);</code></p>
    <p><code> s.push(101);</code></p>
    <p><code> s.push(69);</code></p>
    <p><code> while (!s.empty()) {</code></p>
    <p><code>  cout ‹‹ s.top() ‹‹ endl;</code></p>
    <p><code>  s.pop();</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>lesseq.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[4] = {3, 1, 4, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> sort(array, array + 4, less_equal‹int›());</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ array[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>divides.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int input[3] = {2, 3, 4};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int result = accumulate(input, input + 3, 48, divides‹int›());</code></p>
    <p><code> cout ‹‹ "result = " ‹‹ result ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>greater.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[4] = {3, 1, 4, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> sort(array, array + 4, greater‹int›());</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ array[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>swap1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int a = 42;</code></p>
    <p><code> int b = 19;</code></p>
    <p><code> cout ‹‹ "a = " ‹‹ a ‹‹ " b = " ‹‹ b ‹‹ endl;</code></p>
    <p><code> swap(a, b);</code></p>
    <p><code> cout ‹‹ "a = " ‹‹ a ‹‹ " b = " ‹‹ b ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>times.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int input[4] = {1, 5, 7, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int total = accumulate(input, input + 4, 1, times‹int›());</code></p>
    <p><code> cout ‹‹ "total = " ‹‹ total ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>less.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int array[4] = {3, 1, 4, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> sort(array, array + 4, less‹int› ());</code></p>
    <p><code> for (int i = 0; i ‹ 4; i++) cout ‹‹ array[i] ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>alg1.cpp</p>
    </title>
    <p><code>#include ‹iostream.h›</code></p>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int i = min(4, 7);</code></p>
    <p><code> cout ‹‹ "min(4, 7) = " ‹‹ i ‹‹ endl;</code></p>
    <p><code> char c = maX('a', 'z');</code></p>
    <p><code> cout ‹‹ "maX('a', 'z') = " ‹‹ c ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>filln1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(10);</code></p>
    <p><code> fill_n(v.begin(), v.size(), 42);</code></p>
    <p><code> for (int i = 0; i ‹ 10; i++) cout ‹‹ v[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>iota1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int numbers[10];</code></p>
    <p><code> iota(numbers, numbers + 10, 42);</code></p>
    <p><code> for (int i = 0; i ‹ 10; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>nextprm0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int v1[3] = {0, 1, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> next_permutation(v1, v1 + 3);</code></p>
    <p><code> for (int i = 0; i ‹ 3; i++) cout ‹‹ v1[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>prevprm0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int v1[3] = {0, 1, 2};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> prev_permutation(v1, v1 + 3);</code></p>
    <p><code> for (int i = 0; i ‹ 3; i++) cout ‹‹ v1[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>fill1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v(10);</code></p>
    <p><code> fill(v.begin(), v.end(), 42);</code></p>
    <p><code> for (int i = 0; i ‹ 10; i++) cout ‹‹ v[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pair2.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> pair‹int, int› p = make_pair(1, 10);</code></p>
    <p><code> cout ‹‹ "p.first = " ‹‹ p.first ‹‹ endl;</code></p>
    <p><code> cout ‹‹ "p.second = " ‹‹ p.second ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>error1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <empty-line/>
    <p><code>// Compile this code without defining the symbol OS_USE_EXCEPTIONS.</code></p>
    <p><code>int main() {</code></p>
    <p><code> vector‹int› v;</code></p>
    <p><code> v.pop_back(); // Generates an empty object error.</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pair0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> pair‹int, int› p = make_pair(1, 10);</code></p>
    <p><code> cout ‹‹ "p.first = " ‹‹ p.first ‹‹ ", p.second = " ‹‹ p.second ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>pair1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> pair‹int, int› p = make_pair(1, 10);</code></p>
    <p><code> cout ‹‹ "p.first = " ‹‹ p.first ‹‹ ", p.second = " ‹‹ p.second ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>minelem1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {-10, 15, -100, 36, -242, 42};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> cout ‹‹ *min_element(numbers, numbers + 6) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>maxelem1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[6] = {4, 10, 56, 11, -42, 19};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> cout ‹‹ *max_element(numbers, numbers + 6) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>max1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> cout ‹‹ max(42, 100) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>min1.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> cout ‹‹ min(42, 100) ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>adjdiff0.cpp</p>
    </title>
    <p><code>#include ‹stl.h›</code></p>
    <p><code>#include ‹iostream.h›</code></p>
    <empty-line/>
    <p><code>int numbers[5] = {1, 2, 4, 8, 16};</code></p>
    <empty-line/>
    <p><code>int main() {</code></p>
    <p><code> int difference[5];</code></p>
    <p><code> adjacent_difference(numbers, numbers + 5, difference);</code></p>
    <p><code> for (int i = 0; i ‹ 5; i++) cout ‹‹ numbers[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> for (i = 0; i ‹ 5; i++) cout ‹‹ difference[i] ‹‹ ' ';</code></p>
    <p><code> cout ‹‹ endl;</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
  </section>
 </body>
</FictionBook>
